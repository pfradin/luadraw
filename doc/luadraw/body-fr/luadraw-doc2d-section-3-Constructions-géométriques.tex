\section{Constructions géométriques}

Dans cette section sont regroupées les fonctions construisant des figures géométriques sans méthode graphique dédiée correspondante.

\subsection{circumcircle(), incircle()}

\begin{itemize}
    \item La fonction \textbf{circumcircle(a,b,c)} (ou \textbf{circumcircle(\{a,b,c\})}) , où $a$, $b$ et $c$ sont trois points (trois nombres complexes), renvoie le cercle circonscrit au triangle formé par ces trois points, sous la forme d'une séquence: $C,r$, où $C$ est le centre du cercle (nombre complexe), $r$ son rayon.
    \item La fonction \textbf{incircle3d(a,b,c)} (ou \textbf{incircle3d(\{a,b,c\})}) , où $a$, $b$ et $c$ sont trois points (trois nombres complexes), renvoie le cercle inscrit dans triangle formé par ces trois points, sous la forme d'une séquence: $C,r$, où $C$ est le centre du cercle (nombre complexe), $r$ son rayon.    
\end{itemize}

\subsection{cvx\_hull2d()}

La fonction \textbf{cvx\_hull2d(L)} où $L$ est une liste de complexes, calcule et renvoie une liste de complexes représentant l'enveloppe convexe de $L$.

\subsection{delaunay()}

La fonction \textbf{delaunay(L)} où \emph{L} est une liste de nombres complexes \textbf{distincts}, renvoie une liste de triangles (un triangle étant une liste de trois nombres complexes) obtenus par triangulation de Delaunay des points de \emph{L} (le cercle circonscrit de chacun des triangles ne contient aucun des autres points).

\begin{demo}{Triangulation de Delaunay}
\begin{luadraw}{name=delaunay}
local g = graph3d:new{bbox=false, pictureoptions="scale=2"}
local i = cpx.I; g:Linewidth(6)
local L = {0.285+1.46*i,1.556-0.142*i,2.344+1.313*i,-2.38+1.218*i,1.548-0.624*i,0.969+1.819*i, -0.086-2.191*i,-0.477+1.834*i,-0.904+1.322*i,-2.892+0.025*i}
local T = delaunay(L) -- list of triangles
local n = #T
local num = 7 -- we choose a triangle
local colors = getpalette(palGasFlame,n)
for k = 1, n do
    g:Dpolyline(T[k],true,'fill='..colors[k])
end
g:Ddots(L)
g:Dcircle( {circumcircle(T[num])}, "line width=0.4pt,gray,dashed" )
g:Ddots(T[num],"gray")
g:Show()
\end{luadraw}
\end{demo}

\subsection{voronoi()}

La fonction \textbf{voronoi(L,window)} où \emph{L} est une liste de nombres complexes \textbf{distincts}, détermine le diagramme de Voronoï des points de la liste $L$. Cette fonction renvoie une liste d'éléments de la forme \emph{\{A,polygone\}}  où\emph{A} est un point la liste $L$, et \emph{polygone} une liste de nombres complexes représentant les sommets de la cellule associée à \emph{A}. Il y a ainsi une cellule par point de $L$. La cellule du point $A$ contient les points du plan qui sont plus proches de $A$ que des autres points de $L$. Cette fonction utilise la triangulation de Delaunay. L'argument optionnel \emph{window}, qui vaut par défaut \emph{\{-5,5,-5,5\}}, est utilisée pour clipper les cellules de Voronoï qui sont non bornées, cette fenêtre est automatiquement agrandie si nécessaire, pour contenir tous les points de $L$ ainsi que tous les centes des cercles circonscrits au triangles de Delaunay (attention: cela ne change pas la fenêtre 2d du graphique en cours).

\begin{demo}{Diagramme de Voronoï}
\begin{luadraw}{name=voronoi}
local g = graph:new{ bbox=true, margin={0,0,0,0}, size={10,10}}
local i = cpx.I
local S = {0.285+1.46*i,1.556-0.142*i,2.344+1.313*i,-2.38+1.218*i,1.548-0.624*i,
    0.969+1.819*i,-0.086-2.191*i,-0.477+1.834*i,-0.904+1.322*i,-2.892+0.025*i}
local V = voronoi(S)
local colors = getpalette(rainbow,#V)
for k,T in ipairs(V) do
    local A, polygon = table.unpack(T)
    g:Dpolyline(polygon,true,"color=white, line width=1.2pt,fill="..colors[k])
    g:Ddots(A,"mark=x,white,scale=2,line width=1.2pt")-- A is one of the points of S
end
g:Dpolyline(delaunay(S),true,"dotted,line width=0.6pt") -- Delaunay triangles
g:Show()
\end{luadraw}
\end{demo}

\subsection{line2strip()}

La fonction \textbf{line2strip(L,width,close,ends)} où \emph{L} est une liste de nombres complexes, ou une liste de listes de nombres complexes, renvoie un chemin représentant une "bande" centrée sur \emph{L} et de largeur \emph{width}. L'argument optionnel \emph{close} est un booléen qui indique si \emph{L} doit être refermée (\emph{false} par défaut). L'argument optionnel \emph{ends} est un booléen qui indique si les deux extrémités de la bande doivent être dessinées (\emph{true} par défaut, sauf quand l'argument \emph{close} vaut \emph{true}).

\begin{demo}{Exemple avec \emph{line2strip}}
\begin{luadraw}{name=line2strip}
local g = graph:new{bbox=false, bg="lightgray"}
local i = cpx.I; g:Linewidth(8)
local p = {-3+3*i,-3,"l",0,3,3,1,"ca", 3+3*i,"l"} 
g:Setmatrix({-3+3*i,0.5,0.5*i})
local L = line2strip(path(p),1,true) -- p is first converted to polyline
g:Dpath(L,"Crimson,fill=Gold"); g:Dpath(p,"gray,dashed")
g:Dlabel("close=true",i,{})
g:Setmatrix({3+3*i,0.5,0.5*i})
local L = line2strip(path(p),1,false) -- p is first converted to polyline
g:Dpath(L,"Crimson,fill=Gold"); g:Dpath(p,"gray,dashed")
g:Dlabel("close=false",i,{}) 
g:Setmatrix({-i,0.5,0.5*i})
local L = line2strip(path(p),1,false,false) -- p is first converted to polyline
g:Dpath(L,"Crimson,fill=Gold"); g:Dpath(p,"gray,dashed")
g:Dlabel("close=false",1.5*i,{}); g:Dlabel("ends=false",0.5*i,{}) 
g:Show()
\end{luadraw}
\end{demo}

\subsection{parallel\_polyline()}

La fonction \textbf{parallel\_polyline(L,width,close)} où \emph{L} est une liste de nombres complexes, ou une liste de listes de nombres complexes, renvoie une ligne polygonale parallèle à \emph{L} et située à une "distance" égale à \emph{width}. L'argument \emph{width} peut être positif ou négatif pour être d'un coté ou de l'autre de \emph{L} (cela dépend du sens de parcours de \emph{L}). L'argument optionnel \emph{close} est un booléen qui indique si \emph{L} doit être refermée (\emph{false} par défaut).


\subsection{sss\_triangle()}

La fonction \textbf{sss\_triangle(ab,bc,ca)} où \emph{ab}, \emph{bc} et \emph{ca} sont trois longueurs, calcule et renvoie une liste de trois points (3 complexes) $\{A,B,C\}$ formant les sommets d'un triangle direct dont les longueurs des côtés sont les arguments, c'est à dire $AB=ab$, $BC=bc$ et $CA=ca$, lorsque cela est possible. Le sommet $A$ est toujours le complexe $0$ et le sommet $B$ est toujours le complexe $ab$. Ce triangle peut être dessiné avec la méthode \textbf{g:Dpolyline}.

\subsection{sas\_triangle()}

La fonction \textbf{sas\_triangle(ab,alpha,ca)} où \emph{ab} et \emph{ca} sont deux longueurs, \emph{alpha} un angle en degrés, calcule et renvoie une liste de trois points (3 complexes) $\{A,B,C\}$ formant les sommets d'un triangle tel que $AB=ab$, $CA=ca$, et tel que l'angle $(\vec{AB},\vec{AC})$ a pour mesure \emph{alpha}, lorsque cela est possible. Le sommet $A$ est toujours le complexe $0$ et le sommet $B$ est toujours le complexe $ab$. Ce triangle peut être dessiné avec la méthode \textbf{g:Dpolyline}.

\subsection{asa\_triangle()}

La fonction \textbf{asa\_triangle(alpha,ab,beta)} où \emph{ab} est une longueur, \emph{alpha} et \emph{beta} deux angles en degrés, calcule et renvoie une liste de trois points (3 complexes) $\{A,B,C\}$ formant les sommets d'un triangle tel que $AB=ab$, tel que l'angle $(\vec{AB},\vec{AC})$ a pour mesure \emph{alpha}, et tel que l'angle $(\vec{BA},\vec{BC})$ a pour mesure \emph{beta}, lorsque cela est possible. Le sommet $A$ est toujours le complexe $0$ et le sommet $B$ est toujours le complexe $ab$. Ce triangle peut être dessiné avec la méthode \textbf{g:Dpolyline}.


\begin{demo}{sss\_triangle, sas\_triangle et asa\_triangle}
\begin{luadraw}{name=sss_triangles_and_co}
local g = graph:new{window={-5,5,-3,5},size={10,10}}
g:Labelsize("footnotesize"); g:Linewidth(8)
local i = cpx.I
local T1 = shift( sss_triangle(4,5,3), 2*i-2)
local T2 = shift( sas_triangle(4,60,2), -4-2*i)
local T3 = shift( asa_triangle(30,4,50), 0.5-i)
g:Dpolyline({T1,T2,T3}, true)
g:Linewidth(4)
g:Darc(T2[2],T2[1],T2[3],0.5,1,"->")
g:Darc(T3[2],T3[1],T3[3],0.75,1,"->")
g:Darc(T3[1],T3[2],T3[3],0.75,-1,"->")
g:Dlabel( 
    "$4$",(T1[1]+T1[2])/2,{pos="N"}, "$5$",(T1[2]+T1[3])/2,{pos="NE"},"$3$",(T1[1]+T1[3])/2,{pos="W"},
    "$4$",(T2[1]+T2[2])/2,{pos="N"}, "$60^\\circ$",T2[1]+Zp(0.9,30*deg),{pos="center"},"$2$",(T2[1]+T2[3])/2,{pos="W"},
    "$4$",(T3[1]+T3[2])/2,{pos="N"}, "$30^\\circ$",T3[1]+Zp(1.15,15*deg),{pos="center"},
    "$50^\\circ$",T3[2]+Zp(1.15,155*deg),{pos="center"},
    "sss\\_triangle(4,5,3)",(T1[1]+T1[2])/2,{pos="S"}, "sas\\_triangle(4,60,2)",(T2[1]+T2[2])/2,{}, "asa\\_triangle(30,4,50)",(T3[1]+T3[2])/2,{})
for _,T in ipairs({T1,T2,T3}) do
    g:Dlabel("$A$",T[1],{pos="SW"}, "$B$",T[2],{pos="SE"},"$C$",T[3],{pos="N"})
end
g:Show()
\end{luadraw}
\end{demo}
