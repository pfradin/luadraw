\section{Méthodes graphiques}

On peut créer des lignes polygonales, des courbes, des chemins, des points, des labels.


\subsection{Lignes polygonales}

\subsubsection{Dpolyline}

\textbf{Une ligne polygonale est une liste (table) de composantes connexes, et une composante connexe est une liste (table) de complexes qui représentent les affixes des points}. Par exemple l'instruction :
\begin{Luacode}
local L = { {Z(-4,0), Z(0,2), Z(1,3)}, {Z(0,0), Z(4,-2), Z(1,-1)} }
\end{Luacode}
crée une ligne polygonale à deux composantes dans une variable \emph{L}.

\paragraph{Dessin d'une ligne polygonale.}

C'est la méthode \textbf{g:Dpolyline(L,close, draw\_options,clip)} (où \emph{g} désigne le graphique en cours de création), \emph{L} est une ligne polygonale, \emph{close} un argument facultatif qui vaut \emph{true} ou \emph{false} indiquant si la ligne doit être refermée ou non (\emph{false} par défaut), \emph{draw\_options} est une chaîne de caractères qui sera passée directement à l'instruction \emph{\textbackslash draw} dans l'export. L'argument \emph{clip} doit contenir ou bien \emph{nil} (valeur par défaut) ou bien une table de la forme \emph{\{x1,x2,y1,y2\}},  dans le premier cas la ligne est clippée par la fenêtre 2d courante \textbf{après} sa transformation par la matrice 2d du graphe, dans le second cas la ligne est clippée par la fenêtre $[x_1,x_2]\times[y_1,y_2]$ \textbf{avant} d'être transformée par la matrice du graphe.

\subsubsection{Options de dessin d'une ligne polygonale}

On peut passer des options de dessin directement à l'instruction \emph{\textbackslash draw} dans l'export, mais elles auront un effet local uniquement. Il est possible de modifier ces options de manière globale avec la méthode \textbf{g:Lineoptions(style,color,width,arrows)} (lorsqu'un des arguments vaut \emph{nil}, c'est sa valeur par défaut qui est utilisée) :

\begin{itemize}
\item \emph{color} est une chaîne de caractères représentant une couleur connue de tikz ("black" par défaut),
\item \emph{style} est une chaîne de caractères représentant le type de ligne à dessiner, ce style peut être :
 \begin{itemize}
  \item \emph{"noline"} : trait non dessiné,
  \item \emph{"solid"} : trait plein, valeur par défaut,
  \item \emph{"dotted"} : trait pointillé,
  \item \emph{"dashed"} : tirets,
  \item style personnalisé : l'argument \emph{style} peut être une chaîne de la forme (exemple) \emph{"\{2.5pt\}\{2pt\}"} ce qui signifie : un trait de 2.5pt suivi d'un espace de 2pt, le nombre de valeurs peut être supérieur à 2, ex : \emph{"\{2.5pt\}\{2pt\}\{1pt\}\{2pt\}"} (succession de on, off).
  \end{itemize}
\item \emph{width} est un nombre représentant l'épaisseur de ligne exprimée en dixième de points, par exemple $8$ pour une épaisseur réelle de 0.8pt (valeur de $4$ par défaut),
\item \emph{arrows} est une chaîne qui précise le type de flèche qui sera dessiné, cela peut être :
 \begin{itemize}
  \item \emph{"-"} qui signifie pas de flèche (valeur par défaut),
  \item \emph{"->"} qui signifie une flèche à la fin,
  \item \emph{"<-"} qui signifie une flèche au début,
  \item \emph{"<->"}qui signifie une flèche à chaque bout.\\
  \textbf{ATTENTION} : la flèche n'est pas dessinée lorsque l'argument \emph{close} est true.
  \end{itemize}
\end{itemize}


On peut modifier les options individuellement avec les méthodes : 
\begin{itemize}
    \item \textbf{g:Linecolor(color)}, 
    \item \textbf{g:Linestyle(style)}, 
    \item \textbf{g:Linewidth(width)}, 
    \item \textbf{g:Arrows(arrows)}, 
    \item plus les méthodes suivantes : 
        \begin{itemize}
            \item \textbf{g:Lineopacity(opacity)} qui règle l'opacité du tracé de la ligne, l'argument \emph{opacity} doit être une
valeur entre $0$ (totalement transparent) et $1$ (totalement opaque), par défaut la valeur est de $1$.
            \item \textbf{g:Linecap(style)}, pour jouer sur les extrémités de la ligne, l'argument \emph{style} est une chaîne qui peut valoir :
            \begin{itemize}
                \item \emph{"butt"} (bout droit au point d'arrêt, valeur par défaut),
                \item \emph{"round"} (bout arrondi en demi-cercle),
                \item \emph{"square"} (bout \og arrondi\fg\ en carré).
            \end{itemize}
          
          \item \textbf{g:Linejoin(style)}, pour jouer sur la jointure entre segments, l'argument style est une chaîne qui peut valoir :
            \begin{itemize}
                \item \emph{"miter"} (coin pointu, valeur par défaut),
                \item \emph{"round"} (ou coin arrondi),
                \item \emph{"bevel"} (coin coupé).
            \end{itemize}
        \end{itemize}
\end{itemize}


\paragraph{Options de remplissage d'une ligne polygonale.}

C'est la méthode \textbf{g:Filloptions(style,color,opacity,evenodd)} (qui utilise la librairie \emph{patterns} de tikz, celle-ci est chargée avec le paquet). Lorsqu'un des arguments vaut \emph{nil}, c'est sa valeur par défaut qui est utilisée :

\begin{itemize}
  \item \emph{color} est une chaîne de caractères représentant une couleur connue de tikz ("black" par défaut).
  \item \emph{style} est une chaîne de caractères représentant le type de remplissage, ce style peut être :
      \begin{itemize}
      \item \emph{"none"} : pas de remplissage, c'est la valeur par défaut,
      \item \emph{"full"} : remplissage plein,
      \item \emph{"bdiag"} : hachures descendantes de gauche à droite,
      \item \emph{"fdiag"} : hachures montantes de gauche à droite,
      \item \emph{"horizontal"} : hachures horizontales,
      \item \emph{"`vertical"} : hachures verticales,
      \item \emph{"hvcross"} : hachures horizontales et verticales,
      \item \emph{"diagcross"} : diagonales descendantes et montantes,
      \item \emph{"gradient"} : dans ce cas le remplissage se fait avec un gradient défini avec la méthode \textbf{g:Gradstyle(chaîne)}, ce style est passé tel quel à l'instruction \emph{\textbackslash draw}. Par défaut la chaîne définissant le style de gradient est \emph{"left color = white, right color = red"},
      \item tout autre style connu de la librairie \emph{patterns} est également possible.
      \end{itemize}
\end{itemize}

On peut modifier certaines options individuellement avec les méthodes :
\begin{itemize}
    \item \textbf{g:Fillopacity(opacity)}, 
    \item \textbf{g:Filleo(evenodd)}.
\end{itemize}

\begin{demo}{Champ de vecteurs, courbe intégrale de $y'= 1-xy^2$}
\begin{luadraw}{name=champ}
local g = graph:new{window={-5,5,-5,5},bg="Cyan!30",size={10,10}}
local f = function(x,y) -- éq. diff. y'= 1-x*y^2=f(x,y)
    return 1-x*y^2     
end
local A = Z(-1,1) -- A = -1+i
local deltaX, deltaY, long = 0.5, 0.5, 0.4
local champ = function(f)
    local vecteurs, v = {}
    for y = g:Yinf(), g:Ysup(), deltaY do
        for x = g:Xinf(), g:Xsup(), deltaX do
            v = Z(1,f(x,y)) -- coordonnées 1 et f(x,y)
            v = v/cpx.abs(v)*long -- normalisation de v
            table.insert(vecteurs, {Z(x,y), Z(x,y)+v} )
        end
    end 
    return vecteurs -- vecteurs est une ligne polygonale
end
g:Daxes( {0,1,1}, {labelpos={"none","none"}, arrows="->"} )
g:Dpolyline( champ(f), "->,blue")
g:Dodesolve(f, A.re, A.im, {t={-2.75,5},draw_options="red,line width=0.8pt"})
g:Dlabeldot("$A$", A, {pos="S"})
g:Show()
\end{luadraw}
\end{demo}
\label{champ}


\subsection{Segments et droites}

\textbf{Un segment est une liste (table) de deux complexes représentant les extrémités. Une droite est une liste (table) de deux complexes, le premier représente un point de la droite, et le second un vecteur directeur de la droite (celui-ci doit être non nul).}

\subsubsection{Dangle}
\begin{itemize}
    \item La méthode \textbf{g:Dangle(B,A,C,r,draw\_options)} dessine l'angle \(BAC\) avec un parallélogramme (deux côtés seulement sont dessinés), l'argument facultatif \emph{r} précise la longueur d'un côté (0.25 par défaut). L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction  \emph{\textbackslash draw}.
    \item La fonction \textbf{angleD(B,A,C,r)} renvoie la liste des points de cet angle.
\end{itemize}

\subsubsection{Dbissec}
\begin{itemize}
    \item La méthode \textbf{g:Dbissec(B,A,C,interior,draw\_options)} dessine une bissectrice de l'angle géométrique BAC, intérieure si l'argument facultatif \emph{interior} vaut \emph{true} (valeur par défaut), extérieure sinon. L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction
  \emph{\textbackslash draw}.
  \item La fonction \textbf{bissec(B,A,C,interior)} renvoie cette bissectrice sous forme d'une liste \emph{\{A,u\}} où \emph{u} est un vecteur directeur de la droite.
\end{itemize}

\subsubsection{Dhline}
La méthode \textbf{g:Dhline(d,draw\_options)} dessine une demi-droite, l'argument \emph{d} doit être une liste de de complexes \emph{\{A,B\}}, c'est la demi-droite $[A,B)$ qui est dessinée.

Variante : \textbf{g:Dhline(A,B,draw\_options)}. L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.

\subsubsection{Dline}
La méthode \textbf{g:Dline(d,draw\_options)} trace la droite \emph{d}, celle-ci est une liste du type \emph{\{A,u\}} où \emph{A} représente un point de la droite (un complexe) et \emph{u} un vecteur directeur (un complexe non nul). 

Variante : la méthode \textbf{g:Dline(A,B,draw\_options)} trace la droite passant par les points \emph{A} et \emph{B} (deux complexes). L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.

\subsubsection{DlineEq}
\begin{itemize}
    \item La méthode \textbf{g:DlineEq(a,b,c,draw\_options)} dessine la droite d'équation \(ax+by+c=0\). L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.
    \item La fonction \textbf{lineEq(a,b,c)} renvoie la droite d'équation \(ax+by+c=0\) sous la forme d'une liste \emph{\{A,u\}} où \emph{A} est un point de la droite et \emph{u} un vecteur directeur.
\end{itemize}

\subsubsection{Dmarkarc}
La méthode \textbf{g:Dmarkarc(b,a,c,r,n,long,espace,draw\_options)} permet de marquer l'arc de cercle de centre \emph{a}, de rayon \emph{r}, allant de \emph{b} à \emph{c}, avec \emph{n} petits segments. Par défaut la longueur (argument \emph{long}) est de 0.25, et l'espacement (argument \emph{espace}) et de 0.0625. L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.

\subsubsection{Dmarkseg}
La méthode \textbf{g:Dmarkseg(a,b,n,long,espace,angle,draw\_options)} permet de marquer le segment défini par \emph{a} et \emph{b} avec \emph{n} petits segments penchés de \emph{angle} degrés (45° par défaut). Par défaut la longueur (argument \emph{long}) est de 0.25, et l'espacement (argument \emph{espace}) et de 0.125. L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.

\subsubsection{Dmed}
\begin{itemize}
    \item La méthode \textbf{g:Dmed(A,B, draw\_options)} trace la médiatrice du segment $[A;B]$.

  Variante : \textbf{g:Dmed(seg,draw\_options)} où segment est une liste de deux points représentant le segment. L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.
  \item La fonction \textbf{med(A,B)} (ou \textbf{med(seg)}) renvoie la médiatrice du segment \emph{{[}A,B{]}} sous la forme d'une liste \emph{\{C,u\}} où \emph{C} est un point de la droite et \emph{u} un vecteur directeur.
\end{itemize}

\subsubsection{Dparallel}
\begin{itemize}
    \item La méthode \textbf{g:Dparallel(d,A,draw\_options)} trace la parallèle à \emph{d} passant par \emph{A}. L'argument \emph{d} peut-être soit une droite (une liste constituée d'un point et un vecteur directeur) soit un vecteur non nul. L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.
    \item La fonction \textbf{parallel(d,A)} renvoie la parallèle à \emph{d} passant par \emph{A} sous la forme d'une liste \emph{\{B,u\}} où \emph{B} est un point de la droite et \emph{u} un vecteur directeur.
\end{itemize}

\subsubsection{Dperp}
\begin{itemize}
    \item La méthode \textbf{g:Dperp(d,A,draw\_options)} trace la perpendiculaire à \emph{d} passant par \emph{A}. L'argument \emph{d} peut-être soit une droite (une liste constituée d'un point et un vecteur directeur) soit un vecteur non nul. L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée  telle quelle à l'instruction \emph{\textbackslash draw}.
    \item La fonction \textbf{perp(d,A)} renvoie la perpendiculaire à \emph{d} passant par \emph{A} sous la forme d'une liste \emph{\{B,u\}} où \emph{B} est un point de la droite et \emph{u} un vecteur directeur.
\end{itemize}

\subsubsection{Dseg}
La méthode \textbf{g:Dseg(seg,scale,draw\_options)} dessine le segment défini par l'argument \emph{seg} qui doit être une liste de deux complexes. L'argument facultatif \emph{scale} (1 par défaut) est un nombre qui permet d'augmenter ou réduire la longueur du segment (la longueur naturelle est multipliée par \emph{scale}). L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.

\subsubsection{Dtangent}
\begin{itemize}
    \item La méthode \textbf{g:Dtangent(p,t0,long,draw\_options)} dessine la tangente à la courbe paramétrée par \(p: t \mapsto p(t)\) (à valeurs complexes), au point de paramètre \(t0\). Si l'argument \emph{long} vaut \emph{nil} (valeur par défaut) alors c'est la droite entière qui est dessinée, sinon c'est un segment de longueur \emph{long}. L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.
    \item La fonction \textbf{tangent(p,t0,long)} renvoie soit la droite, soit un segment (suivant que \emph{long} vaut \emph{nil} ou pas).
\end{itemize}

\subsubsection{ DtangentC}
\begin{itemize}
    \item La méthode \textbf{g:DtangentC(f,x0,long,draw\_options)} dessine la tangente à la courbe cartésienne d'équation \(y=f(x)\), au point d'abscisse \emph{x0}. Si l'argument \emph{long} vaut \emph{nil} (valeur par défaut) alors c'est la droite entière qui est dessinée, sinon c'est un segment de longueur \emph{long}. L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.
    \item La fonction \textbf{tangentC(f,x0,long)} renvoie soit la droite, soit un segment (suivant que \emph{long} vaut \emph{nil} ou pas).
\end{itemize}

\subsubsection{ DtangentI}
\begin{itemize}
    \item La méthode \textbf{g:DtangentI(f,x0,y0,long,draw\_options)} dessine la tangente à la courbe implicite d'équation \(f(x,y)=0\), au point \emph{(x0,y0)} supposé sur la courbe. Si l'argument \emph{long} vaut \emph{nil} (valeur par défaut) alors c'est la droite entière qui est dessinée, sinon c'est un segment de longueur \emph{long}. L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.
    \item La fonction \textbf{tangentI(f,x0,y0,long)} renvoie soit la droite, soit un segment (suivant que \emph{long} vaut \emph{nil} ou pas).
\end{itemize}

\subsubsection{ Dtangent\_from}
\begin{itemize}
    \item La méthode \textbf{g:Dtangent\_from(A,p,t1,t2,dp,draw\_options,out)} dessine la ou les tangentes à la courbe paramétrée par \(p: t \mapsto p(t)\) (à valeurs complexes) issue(s) du point $A$ (nombre complexe). Les arguments \emph{t1} et \emph{t2} représentent les bornes de l'intervalle de recherche. L'argument optionnel \emph{dp} est une fonction représentant la dérivée de la fonction $p$, par défaut cet argument vaut \emph{nil} et lé dérivée de $p$ est remplacée par une approximation. L'argument optionnel \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}. L'argument optionnel \emph{out}, s'il est utilisé, doit être le nom d'une variable, celle-ci doit être une table, elle contiendra à la fin de l'exécution les points de la courbe pour lesquels la tangente passe par $A$.
    \item La fonction \textbf{tangent\_from(A,p,t1,t2,dp)} renvoie la liste les points de la courbe paramétrée par $p$, sur l'intervalle\emph{[t1;t2]} pour lesquels la tangente passe par $A$ (nombre complexe). S'il n'y en a pas, la fonction renvoie une liste vide.
\end{itemize}

\begin{demo}{Tangentes issues d'un point}
\begin{luadraw}{name=tangent_from}
local i, cos, sin, pi = cpx.I, math.cos, math.sin, math.pi
local g = graph:new{window={-5,5,-5,5}, size={10,10}}
local p1 = function(t) return t+i*(t^2/4-1) end -- parabola
local p2 = function(t) return 1/2+i+rotate(2*cos(t)+i*sin(t),15) end -- ellipse
local p3 = function(t) return math.sinh(t)+i*math.cosh(t)-i*2 end -- branch of a hyperbola
local p4 = function(t) return 2*cos(3*t)*cpx.exp(i*t) end -- other
local P = 0.5-1.25*i
local draw = function(p,t1,t2)
    local axis_style = { arrows='-Stealth', legend={'$x$','$y$'} }
    local S = {}
    g:Daxes({0, 1, 1}, axis_style)
    g:Dparametric(p,{t={t1,t2}, draw_options="line width=0.8pt, Crimson"})
    g:Dtangent_from(P,p,t1,t2,"blue",S)
    g:Ddots(S,"Crimson"); g:Ddots(P); g:Dlabel("$A$",P,{pos="S"})
end
g:Saveattr(); g:Viewport(-5,-0.25,0.25,5); g:Coordsystem(-3,4,-3,4); draw(p1,-4,4); g:Restoreattr()
g:Saveattr(); g:Viewport(0.25,5,0.25,5); g:Coordsystem(-3,3,-3,3); draw(p2,-pi,pi); g:Restoreattr()
g:Saveattr(); g:Viewport(-5,-0.25,-5,-0.25); g:Coordsystem(-3,4,-3,3); draw(p3,-4,4); g:Restoreattr()
g:Saveattr(); g:Viewport(0.25,5,-5,-0.25); g:Coordsystem(-3,3,-3,3); draw(p4,-pi,pi); g:Restoreattr()
g:Show()
\end{luadraw}
\end{demo}

\subsubsection{Dnormal}
\begin{itemize}
    \item La méthode \textbf{g:Dnormal(p,t0,long,draw\_options)} dessine la normale à la courbe paramétrée par \(p: t \mapsto p(t)\) (à valeurs complexes), au point de paramètre \(t0\). Si l'argument \emph{long} vaut \emph{nil} (valeur par défaut) alors c'est la droite entière qui est dessinée, sinon c'est un segment de longueur \emph{long}. L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.
    \item La fonction \textbf{normal(p,t0,long)} renvoie soit la droite, soit un segment (suivant que \emph{long} vaut \emph{nil} ou pas).
\end{itemize}

\subsubsection{ DnormalC}
\begin{itemize}
    \item La méthode \textbf{g:DnormalC(f,x0,long,draw\_options)} dessine la normale à la courbe cartésienne d'équation \(y=f(x)\), au point d'abscisse \emph{x0}. Si l'argument \emph{long} vaut \emph{nil} (valeur par défaut) alors c'est la droite entière qui est dessinée, sinon c'est un segment de longueur \emph{long}. L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.
    \item La fonction \textbf{normalC(f,x0,long)} renvoie soit la droite, soit un segment (suivant que \emph{long} vaut \emph{nil} ou pas).
\end{itemize}

\subsubsection{DnormalI}
\begin{itemize}
    \item La méthode \textbf{g:DnormalI(f,x0,y0,long,draw\_options)} dessine la normale à la courbe implicite d'équation \(f(x,y)=0\), au point \emph{(x0,y0)} supposé sur la courbe. Si l'argument \emph{long} vaut \emph{nil} (valeur par défaut) alors c'est la droite entière qui est dessinée, sinon c'est un segment de longueur \emph{long}. L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.
    \item La fonction \textbf{normalI(f,x0,y0,long)} renvoie soit la droite, soit un segment (suivant que \emph{long} vaut \emph{nil} ou pas).
\end{itemize}
  

\begin{demo}{Symétrique de l'orthocentre}
\begin{luadraw}{name=orthocentre}
local g = graph:new{window={-5,5,-5,5},bg="cyan!30",size={10,10}}
local i = cpx.I
local A, B, C = 4*i, -2-2*i, 3.5
local h1, h2 = perp({B,C-B},A), perp({A,B-A},C) -- hauteurs
local A1, F = proj(A,{B,C-B}), proj(C,{A,B-A}) -- projetés
local H = interD(h1,h2) -- orthocentre
local A2 = 2*A1-H -- symétrique de H par rapport à BC
g:Dpolyline({A,B,C},true, "draw=none,fill=Maroon,fill opacity=0.3") -- fond du triangle
g:Linewidth(6); g:Filloptions("full", "blue", 0.2)
g:Dangle(C,A1,A,0.25); g:Dangle(B,F,C,0.25) -- angles droits
g:Linecolor("black"); g:Filloptions("full","cyan",0.5)
g:Darc(H,C,A2,1); g:Darc(B,A,A1,1) -- arcs
g:Filloptions("none","black",1) -- on rétablit l'opacité à 1
g:Dmarkarc(H,C,A1,1,2); g:Dmarkarc(A1,C,A2,1,2) -- marques
g:Dmarkarc(B,A,H,1,2)
g:Linewidth(8); g:Linecolor("black")
g:Dseg({A,B},1.25); g:Dseg({C,B},1.25); g:Dseg({A,C},1.25) -- côtés
g:Linecolor("red"); g:Dcircle(A,B,C) -- cercle
g:Linecolor("blue"); g:Dline(h1); g:Dline(h2) -- hauteurs
g:Dseg({A2,C}); g:Linecolor("red"); g:Dseg({H,A2}) -- segments
g:Dmarkseg(H,A1,2); g:Dmarkseg(A1,A2,2) -- marques
g:Labelcolor("blue") -- pour les labels
g:Dlabel("$A$",A, {pos="NW",dist=0.1}, "$B$",B, {pos="SW"}, "$A_2$",A2,{pos="E"}, "$C$", C, {pos="S" }, "$H$", H, {pos="NE"}, "$A_1$", A1, {pos="SW"})
g:Linecolor("black"); g:Filloptions("full"); g:Ddots({A,B,C,H,A1,A2}) -- dessin des points
g:Show(true)
\end{luadraw}
\end{demo}

\subsection{Figures géométriques}

\subsubsection{Darc}
\begin{itemize}
    \item La méthode \textbf{g:Darc(B,A,C,r,sens,draw\_options)} dessine un arc de cercle de centre \emph{A} (complexe), de rayon \emph{r}, allant de \emph{B} (complexe) vers \emph{C} (complexe) dans le sens trigonométrique si l'argument \emph{sens} vaut 1, le sens inverse sinon. L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.
    \item La fonction \textbf{arc(B,A,C,r,sens)} renvoie la liste des points de cet arc (ligne polygonale). 
    \item La fonction \textbf{arcb(B,A,C,r,sens)} renvoie cet arc sous forme d'un chemin (voir Dpath) utilisant des courbes de Bézier.
\end{itemize}

\subsubsection{Dcircle}
\begin{itemize}
    \item La méthode \textbf{g:Dcircle(c,r,d,draw\_options)} trace un cercle. Lorsque l'argument \emph{d} est nil, c'est le cercle de centre \emph{c} (complexe) et de rayon \emph{r}, lorsque \emph{d} est précisé (complexe) alors c'est le cercle passant par les points d'affixe \emph{c},\emph{r} et \emph{d}. L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}. Autre syntaxe possible :  \textbf{g:Dcircle(C,draw\_options)} où \emph{C=\{c,r,d\}}.
  \item La fonction \textbf{circle(c,r,d)} renvoie la liste des points de ce cercle (ligne polygonale). 
  \item La fonction \textbf{circleb(c,r,d)} renvoie ce cercle sous forme d'un chemin (voir Dpath) utilisant des courbes de Bézier.
\end{itemize}

\subsubsection{Dellipse}
\begin{itemize}
    \item  La méthode \textbf{g:Dellipse(c,rx,ry,inclin,draw\_options)} dessine l'ellipse de centre \emph{c} (complexe), les arguments \emph{rx} et \emph{ry} précisent les deux rayons (sur x et sur y), l'argument facultatif \emph{inclin} est un angle en degrés qui indique l'inclinaison de l'ellipse par rapport à l'axe \(Ox\) (angle nul par défaut). L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.
  \item La fonction \textbf{ellipse(c,rx,ry,inclin)} renvoie la liste des points de cette ellipse (ligne polygonale). 
  \item La fonction \textbf{ellipseb(c,rx,ry,inclin)} renvoie cette ellipse sous forme d'un chemin (voir Dpath) utilisant des courbes de Bézier.
\end{itemize}

\subsubsection{Dellipticarc}
\begin{itemize}
    \item La méthode \textbf{g:Dellipticarc(B,A,C,rx,ry,sens,inclin,draw\_options)} dessine un arc d'ellipse de centre \emph{A} (complexe) de rayons \emph{rx} et \emph{ry}, faisant un angle égal à \emph{inclin} par rapport à l'axe \(Ox\) (angle nul par défaut), allant de \emph{B} (complexe) vers \emph{A} (complexe) dans le sens trigonométrique si l'argument \emph{sens} vaut 1, le sens inverse sinon. L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.
    \item La fonction \textbf{ellipticarc(B,A,C,rx,ry,sens,inclin)} renvoie la liste des points de cet arc (ligne polygonale). 
    \item La fonction \textbf{ellipticarcb(B,A,C,rx,ry,sens,inclin)} renvoie cet arc sous forme d'un chemin (voir Dpath) utilisant des courbes de Bézier.
\end{itemize}

\subsubsection{Dparallelogram}
\begin{itemize}
    \item La méthode \textbf{g:Dparallelogram(a,u,v,draw\_options)} où \emph{a}, \emph{u}, \emph{v} désigne trois nombres complexes désignant un sommet et deux vecteurs, dessine le parallélogramme de sommets \emph{\{a,a+u,a+u+v,a+v\}}. L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.
    \item La fonction \textbf{parallelogram(a,u,v)} renvoie la liste des sommets de ce parallélogramme.
\end{itemize}

\subsubsection{Dpolyreg}
\begin{itemize}
    \item La méthode \textbf{g:Dpolyreg(sommet1,sommet2,nbcotes,sens,draw\_options)} ou \par \textbf{g:Dpolyreg(centre,sommet,nbcotes,draw\_options)} dessine un polygone régulier. L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.
    \item La fonction \textbf{polyreg(sommet1,sommet2,nbcotes,sens)} et la fonction \textbf{polyreg(centre,sommet,nbcotes)}, renvoient la liste des sommets de ce polygone régulier.
\end{itemize}

\subsubsection{Drectangle}
\begin{itemize}
    \item La méthode \textbf{g:Drectangle(a,b,c,draw\_options)} dessine le rectangle ayant comme sommets consécutif \emph{a} et \emph{b} et dont le côté opposé passe par \emph{c}. L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.
    \item La fonction \textbf{rectangle(a,b,c)} renvoie la liste des sommets de ce rectangle.
\end{itemize}

\subsubsection{Dsequence}
\begin{itemize}
    \item La méthode \textbf{g:Dsequence(f,u0,n,draw\_options)} fait le dessin des "escaliers" de la suite récurrente définie par son premier terme \emph{u0} et la relation \(u_{k+1}=f(u_k)\). L'argument \emph{f} doit être une fonction d'une variable réelle et à valeurs réelles, l'argument \emph{n} est le nombre de termes calculés. L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.
    \item La fonction \textbf{sequence(f,u0,n)} renvoie la liste des points constituant ces "escaliers".
\end{itemize}

\begin{demo}{Suite $u_{n+1}=\cos(u_n)$}
\begin{luadraw}{name=sequence}
local g = graph:new{window={-0.1,1.7,-0.1,1.1},size={10,10,0}}
local i, pi, cos = cpx.I, math.pi, math.cos
local f = function(x) return cos(x)-x end
local ell = solve(f,0,pi/2)[1]
local L = sequence(cos,0.2,5) -- u_{n+1}=cos(u_n), u_0=0.2
local seg, z = {}, L[1]
for k = 2, #L do 
    table.insert(seg,{z,L[k]})
    z = L[k]
end -- seg est la liste des segments de l'escalier
g:Writeln("\\tikzset{->-/.style={decoration={markings, mark=at position #1 with {\\arrow{Stealth}}}, postaction={decorate}}}")
g:Daxes({0,1,1}, {arrows="-Stealth"})
g:DlineEq(1,-1,0,"line width=0.8pt,ForestGreen")
g:Dcartesian(cos, {x={0,pi/2},draw_options="line width=1.2pt,Crimson"})
g:Dpolyline(seg,false,"->-=0.65,blue")
g:Dlabel("$u_0$",0.2,{pos="S",node_options="blue"})
g:Dseg({ell, ell*(1+i)},1,"dashed,gray")
g:Dlabel("$\\ell\\approx"..round(ell,3).."$", ell,{pos="S"})
g:Ddots(ell*(1+i)); g:Labelcolor("Crimson")
g:Dlabel("${\\mathcal C}_{\\cos}$",Z(1,cos(1)),{pos="E"})
g:Labelcolor("ForestGreen"); g:Labelangle(g:Arg(1+i)*180/pi)
g:Dlabel("$y=x$",Z(0.4,0.4),{pos="S",dist=0.1}) 
g:Show()
\end{luadraw}
\end{demo}

La méthode \textbf{g:Arg(z)} calcule et renvoie l'argument \textit{réel} du complexe $z$, c'est à dire son argument (en radians) à l'export dans le repère de tikz (il faut pour cela appliquer la matrice de transformation du graphe à $z$, puis faire le changement de repère vers celui de tikz). Si le repère du graphe est orthonormé et si la matrice de transformation est l'identité alors le résultat est identique à celui de \textbf{cpx.arg(z)} (ce n'est pas le cas dans l'exemple ci-dessus).

De même, la méthode \textbf{g:Abs(z)} calcule et renvoie le module \textit{réel} du complexe $z$, c'est à dire son module à l'export dans le repère de tikz, c'est donc une longueur en centimètres. Si le repère du graphe est orthonormé avec 1cm par unité sur chaque axe, et si la matrice de transformation est une isométrie alors le résultat est identique à celui de \textbf{cpx.abs(z)}.


\subsubsection{Dsquare}
\begin{itemize}
    \item La méthode \textbf{g:Dsquare(a,b,sens,draw\_options)} dessine le carré ayant comme sommets consécutifs \emph{a} et \emph{b}, dans le sens trigonométrique lorsque \emph{sens} vaut 1 (valeur par défaut). L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.
  \item La fonction \textbf{square(a,b,sens)} renvoie la liste des sommets de ce carré.
\end{itemize}

\subsubsection{Dwedge}
La méthode \textbf{g:Dwedge(B,A,C,r,sens,draw\_options)} dessine un secteur angulaire de centre \emph{A} (complexe), de rayon \emph{r}, allant de \emph{B} (complexe) vers \emph{C} (complexe) dans le sens trigonométrique si l'argument \emph{sens} vaut 1, le sens inverse sinon. L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.


\subsection{Courbes}

\subsubsection{Paramétriques : Dparametric}

\begin{itemize}
\item La fonction \textbf{parametric(p,t1,t2,nbdots,discont,nbdiv)} fait le calcul des points et renvoie une ligne polygonale (pas de dessin).
  \begin{itemize}
    \item L'argument \emph{p} est le paramétrage, ce doit être une fonction d'une variable réelle \emph{t} et à valeurs complexes, par exemple :
    \mintinline{Lua}{local p = function(t) return cpx.exp(t*cpx.I) end}
    \item  Les arguments \emph{t1} et \emph{t2} sont obligatoires avec \(t1 < t2\), ils forment les bornes de l'intervalle pour le paramètre.
    \item L'argument \emph{nbdots} est facultatif, c'est le nombre de points (minimal) à calculer, il vaut 40 par défaut.
    \item L'argument \emph{discont} est un booléen facultatif qui indique s'il y a des discontinuités ou non, c'est \emph{false} par défaut.
    \item L'argument \emph{nbdiv} est un entier positif qui vaut 5 par défaut et indique le nombre de fois que l'intervalle entre deux valeurs consécutives du paramètre peut être coupé en deux (dichotomie) lorsque les points correspondants sont trop éloignés.
  \end{itemize}
  
\item La méthode \textbf{g:Dparametric(p,args)} fait le calcul des points et le dessin de la courbe paramétrée par \emph{p}. Le paramètre \emph{args} est une table à 6 champs :

\begin{TeXcode}
 { t={t1,t2}, nbdots=40, discont=true/false, nbdiv=5, draw_options="", clip={x1,x2,y1,y2} }
\end{TeXcode}

  \begin{itemize}
      \item Par défaut, le champ \emph{t} est égal à \emph{\{g:Xinf(),g:Xsup()\}},
      \item le champ \emph{nbdots} vaut 40, 
      \item le champ \emph{discont} vaut \emph{false},
      \item le champ \emph{nbdiv} vaut 5,
      \item le champ \emph{draw\_options} est une chaîne vide (celle-ci sera transmise telle quelle à l'instruction \emph{\textbackslash draw}),
      \item le champ \emph{clip} est soit \emph{nil} (valeur par défaut), soit une table \emph{\{x1,x2,y1,y2\}}, dans le premier cas la ligne est clippée par la fenêtre 2d courante \textbf{après} sa transformation par la matrice 2d du graphe, dans le second cas la ligne est clippée par la fenêtre $[x_1,x_2]\times[y_1,y_2]$ \textbf{avant} d'être transformée par la matrice du graphe.
  \end{itemize}
\end{itemize}  

\subsubsection{Polaires : Dpolar}

\begin{itemize}
\item La fonction \textbf{polar(rho,t1,t2,nbdots,discont,nbdiv)} fait le calcul des points et renvoie une ligne polygonale (pas de dessin). L'argument \emph{rho} est le paramétrage polaire de la courbe, ce doit être une fonction d'une variable réelle \emph{t} et à valeurs
  réelles, par exemple :

    \mintinline{Lua}{local rho = function(t) return 4*math.cos(2*t) end}

    Les autres arguments sont identiques aux courbes paramétrées.
\item La méthode \textbf{g:Dpolar(rho,args)} fait le calcul des points et le  dessin de la courbe polaire paramétrée par \emph{rho}.  Le paramètre \emph{args} est une table à 6 champs :

\begin{TeXcode}
  { t={t1,t2}, nbdots=40, discont=true/false, nbdiv=5, draw_options="", clip={x1,x2,y1,y2} }
\end{TeXcode}

  \begin{itemize}
      \item Par défaut, le champ \emph{t} est égal à $\{-\pi,\pi\}$,
      \item le champ \emph{nbdots} vaut 40,
      \item le champ \emph{discont} vaut \emph{false}, 
      \item le champ \emph{nbdiv} vaut 5, 
      \item le champ \emph{draw\_options} est une chaîne vide (celle-ci sera transmise telle quelle à l'instruction \emph{\textbackslash draw}),
      \item le champ \emph{clip} est soit \emph{nil} (valeur par défaut), soit une table \emph{\{x1,x2,y1,y2\}}, dans le premier cas la ligne est clippée par la fenêtre 2d courante \textbf{après} sa transformation par la matrice 2d du graphe, dans le second cas la ligne est clippée par la fenêtre $[x_1,x_2]\times[y_1,y_2]$ \textbf{avant} d'être transformée par la matrice du graphe.
  \end{itemize}
\end{itemize}

\subsubsection{Cartésiennes : Dcartesian}

\begin{itemize}
\item La fonction \textbf{cartesian(f,x1,x2,nbdots,discont,nbdiv)} fait le calcul des points et renvoie une ligne polygonale (pas de dessin). L'argument \emph{f} est la fonction dont on veut la courbe, ce doit être une fonction d'une variable réelle \emph{x} et à valeurs réelles, par exemple :

    \mintinline{Lua}{local f = function(x) return 1+3*math.sin(x)*x end}

    Les arguments \emph{x1} et \emph{x2} sont obligatoires et forment les bornes de l'intervalle pour la variable. Les autres arguments sont identiques aux courbes paramétrées.

\item La méthode \textbf{g:Dcartesian(f,args)} fait le calcul des points et le dessin de la courbe de \emph{f}. Le paramètre \emph{args} est une table à 6 champs :

\begin{TeXcode}
  { x={x1,x2}, nbdots=40, discont=true/false, nbdiv=5, draw_options="", clip={x1,x2,y1,y2} }
\end{TeXcode}
  
  \begin{itemize}
      \item   Par défaut, le champ \emph{x} est égal à \emph{\{g:Xinf(),g:Xsup()\}}, 
      \item le champ \emph{nbdots} vaut 40, 
      \item le champ \emph{discont} vaut \emph{false}, 
      \item le champ \emph{nbdiv} vaut 5, 
      \item le champ \emph{draw\_options} est une chaîne vide (celle-ci sera transmise telle quelle à l'instruction \emph{\textbackslash draw}),
      \item le champ \emph{clip} est soit \emph{nil} (valeur par défaut), soit une table \emph{\{x1,x2,y1,y2\}}, dans le premier cas la ligne est clippée par la fenêtre 2d courante \textbf{après} sa transformation par la matrice 2d du graphe, dans le second cas la ligne est clippée par la fenêtre $[x_1,x_2]\times[y_1,y_2]$ \textbf{avant} d'être transformée par la matrice du graphe.
  \end{itemize}
\end{itemize}

\subsubsection{Fonctions périodiques : Dperiodic}

\begin{itemize}
\item La fonction \textbf{periodic(f,period,x1,x2,nbdots,discont,nbdiv)} fait le calcul des points et renvoie une ligne polygonale (pas de dessin).

  \begin{itemize}
    \item L'argument \emph{f} est la fonction dont on veut la courbe, ce doit être une fonction d'une variable réelle \emph{x} et à valeurs réelles.
    \item L'argument \emph{period} est une table du type \emph{\{a,b\}} avec \(a<b\) représentant une période de la fonction \emph{f}.
    \item Les arguments \emph{x1} et \emph{x2} sont obligatoires et forment les bornes de l'intervalle pour la variable.
    \item Les autres arguments sont identiques aux courbes paramétrées.
  \end{itemize}
\item La méthode \textbf{g:Dperiodic(f,period,args)} fait le calcul des points et le dessin de la courbe de \emph{f}. Le paramètre \emph{args} est une table à 6 champs :

\begin{TeXcode}
  { x={x1,x2}, nbdots=40, discont=true/false, nbdiv=5, draw_options="", clip={x1,x2,y1,y2} }
\end{TeXcode}

  \begin{itemize}
      \item Par défaut, le champ \emph{x} est égal à \emph{\{g:Xinf(),g:Xsup()\}},
      \item le champ \emph{nbdots} vaut 40, 
      \item le champ \emph{discont} vaut \emph{false}, 
      \item le champ \emph{nbdiv} vaut 5, 
      \item le champ \emph{draw\_options} est une chaîne vide (celle-ci sera transmise telle quelle à l'instruction \emph{\textbackslash draw}),
      \item le champ \emph{clip} est soit \emph{nil} (valeur par défaut), soit une table \emph{\{x1,x2,y1,y2\}}, dans le premier cas la ligne est clippée par la fenêtre 2d courante \textbf{après} sa transformation par la matrice 2d du graphe, dans le second cas la ligne est clippée par la fenêtre $[x_1,x_2]\times[y_1,y_2]$ \textbf{avant} d'être transformée par la matrice du graphe.

  \end{itemize}

\end{itemize}

\subsubsection{Fonctions en escaliers : Dstepfunction}

\begin{itemize}
\item La fonction \textbf{stepfunction(def,discont)} fait le calcul des points et renvoie une ligne polygonale (pas de dessin).

  \begin{itemize}
  \item  L'argument \emph{def} permet de définir la fonction en escaliers, c'est une table à deux champs :

\begin{TeXcode}
  { {x1,x2,x3,...,xn}, {c1,c2,...} }
\end{TeXcode}

  Le premier élément \emph{\{x1,x2,x3,\ldots,xn\}} doit être une subdivision du segment \([x1,xn]\).
  
  Le deuxième élément \emph{\{c1,c2,\ldots\}} est la liste des constantes avec \emph{c1} pour le morceau \emph{{[}x1,x2{]}}, \emph{c2} pour le morceau \emph{{[}x2,x3{]}}, etc.
  
  \item   L'argument \emph{discont} est un booléen qui vaut \emph{true} par défaut.
  \end{itemize}
  
\item La méthode \textbf{g:Dstepfunction(def,args)} fait le calcul des points et le dessin de la courbe de la fonction en escalier.

  \begin{itemize}
  \item L'argument \emph{def} est le même que celui décrit au-dessus (définition de la fonction en escalier).
  \item L'argument \emph{args} est une table à 3 champs : 
  
\begin{TeXcode}
  { discont=true/false, draw_options="",clip={x1,x2,y1,y2} }
\end{TeXcode}

  Par défaut, le champ \emph{discont} vaut true, et le champ \emph{draw\_options} est une chaîne vide (celle-ci sera transmise telle quelle à l'instruction \emph{\textbackslash draw}). Le champ \emph{clip} est soit \emph{nil} (valeur par défaut), soit une table \emph{\{x1,x2,y1,y2\}}, dans le premier cas la ligne est clippée par la fenêtre 2d courante \textbf{après} sa transformation par la matrice 2d du graphe, dans le second cas la ligne est clippée par la fenêtre $[x_1,x_2]\times[y_1,y_2]$ \textbf{avant} d'être transformée par la matrice du graphe.

  \end{itemize}
\end{itemize}

\subsubsection{Fonctions affines par morceaux : Daffinebypiece}

\begin{itemize}
\item La fonction \textbf{affinebypiece(def,discont)} fait le calcul des points et renvoie une ligne polygonale (pas de dessin).

  \begin{itemize}
  \item  L'argument \emph{def} permet de définir la fonction en escaliers, c'est une table à deux champs :

\begin{TeXcode}
 { {x1,x2,x3,...,xn}, { {a1,b1}, {a2,b2},...} }
\end{TeXcode}

  Le premier élément \emph{\{x1,x2,x3,\ldots,xn\}} doit être une subdivision du segment \([x1,xn]\).
  
  Le deuxième élément \emph{\{ \{a1,b1\}, \{a2,b2\}, \ldots\}} signifie que sur \emph{{[}x1,x2{]}} la fonction est \(x\mapsto a_1x+b_1\), sur \emph{{[}x2,x3{]}} la fonction est
  \(x\mapsto a_2x+b_2\), etc.
  
  \item L'argument \emph{discont} est un booléen qui vaut \emph{true} par défaut.
  \end{itemize}
  
\item La méthode \textbf{g:Daffinebypiece(def,args)} fait le calcul des points et le dessin de la courbe de la fonction affine par morceaux.

  \begin{itemize}
  \item L'argument \emph{def} est le même que celui décrit au-dessus (définition de la fonction affine par morceaux).
  \item L'argument \emph{args} est une table à 3 champs :
  
\begin{TeXcode}
  { discont=true/false, draw_options="", clip={x1,x2,y1,y2} }
\end{TeXcode}

  Par défaut, le champ \emph{discont} vaut \emph{true}, et le champ \emph{draw\_options} est une chaîne vide (celle-ci sera transmise telle quelle à l'instruction \emph{\textbackslash draw}). Le champ \emph{clip} est soit \emph{nil} (valeur par défaut), soit une table \emph{\{x1,x2,y1,y2\}}, dans le premier cas la ligne est clippée par la fenêtre 2d courante \textbf{après} sa transformation par la matrice 2d du graphe, dans le second cas la ligne est clippée par la fenêtre $[x_1,x_2]\times[y_1,y_2]$ \textbf{avant} d'être transformée par la matrice du graphe.
  \end{itemize}
\end{itemize}

\subsubsection{Équations différentielles : Dodesolve}

\begin{itemize}
\item La fonction \textbf{odesolve(f,t0,Y0,tmin,tmax,nbdots,method)} permet une résolution approchée de l'équation différentielle \(Y'(t)=f(t,Y(t))\) dans l'intervalle {[}tmin,tmax{]} qui doit contenir \emph{t0}, avec la condition initiale $Y(t0)=Y0$.

\begin{itemize}
  \item L'argument \emph{f} est une fonction \(f: (t,Y) -> f(t,Y)\) à valeurs dans \(R^n\) et où \emph{Y} est également dans \(R^n\) : \emph{Y=\{y1, y2,\ldots, yn\}} (lorsque $n=1$, \emph{Y} est un réel).
  \item Les arguments \emph{t0} et \emph{Y0} donnent les conditions initiales avec \emph{Y0=\{y1(t0), \ldots, yn(t0)\}} (les yi sont réels), ou \emph{Y0=y1(t0)} lorsque $n=1$.
  \item Les arguments \emph{tmin} et \emph{tmax} définissent l'intervalle de résolution, celui-ci doit contenir \(t0\).
  \item L'argument \emph{nbdots} indique le nombre de points calculés de part et d'autre de \(t0\).
  \item L'argument optionnel \emph{method} est une chaîne qui peut valoir \emph{"rkf45"} (valeur par défaut), ou \emph{"rk4"}. Dans le premier cas, on utilise la méthode de Runge Kutta-Fehlberg (à pas variable), dans le second cas c'est la méthode classique de Runge-Kutta d'ordre 4.
  \item En sortie, la fonction renvoie la matrice suivante (liste de listes de réels) :

\begin{TeXcode}
{ {tmin,...,tmax}, {y1(tmin),...,y1(tmax)}, {y2(tmin),...,y2(tmax)},...}
\end{TeXcode}

  La première composante est la liste des valeurs de \emph{t} (dans l'ordre croissant), la deuxième est la liste des valeurs (approchées) de la composante \emph{y1} correspondant à ces valeurs de \emph{t}, ... etc.
    \end{itemize}
    
\item La méthode \textbf{g:DplotXY(X,Y,draw\_options,clip)}, où les arguments \emph{X} et \emph{Y} sont deux listes de réels de même longueur, dessine la ligne polygonale constituée des points $(X[k],Y[k])$. L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}. Le champ \emph{clip} est soit \emph{nil} (valeur par défaut), soit une table \emph{\{x1,x2,y1,y2\}}, dans le premier cas la ligne est clippée par la fenêtre 2d courante \textbf{après} sa transformation par la matrice 2d du graphe, dans le second cas la ligne est clippée par la fenêtre $[x_1,x_2]\times[y_1,y_2]$ \textbf{avant} d'être transformée par la matrice du graphe.


\begin{demo}{Un système différentiel de Lokta-Volterra}
\begin{luadraw}{name=lokta_volterra}
local g = graph:new{window={-5,50,-0.5,5},size={10,10,0}, border=true}
local i = cpx.I
local f = function(t,y) return {y[1]-y[1]*y[2],-y[2]+y[1]*y[2]} end
g:Labelsize("footnotesize")
g:Daxes({0,10,1},{limits={{0,50},{0,4}}, nbsubdiv={4,0}, legendsep={0.1,0}, originpos={"center","center"}, legend={"$t$",""}})
local y0 = {2,2}
local M = odesolve(f,0,y0,0,50,250) -- résolution approchée
-- M est une table à 3 éléments: t, x et y
g:Lineoptions("solid","blue",8)
g:Dseg({5+3.5*i,10+3.5*i}); g:Dlabel("$x$",10+3.5*i,{pos="E"})
g:DplotXY(M[1],M[2]) -- points (t,x(t))
g:Linecolor("red"); g:Dseg({5+3*i,10+3*i}); g:Dlabel("$y$",10+3*i,{pos="E"})
g:DplotXY(M[1],M[3])  -- points (t,y(t))
g:Lineoptions(nil,"black",4)
g:Saveattr(); g:Viewport(20,50,3,5) -- changement de vue
g:Coordsystem(-0.5,3.25,-0.5,3.25) -- nouveau repère associé
g:Daxes({0,1,1},{legend={"$x$","$y$"},arrows="->"})
g:Lineoptions(nil,"ForestGreen",8); g:DplotXY(M[2],M[3]) -- points (x(t),y(t))
g:Restoreattr() -- retour à l'ancienne vue
g:Dlabel("$\\begin{cases}x'=x-xy\\\\y'=-y+xy\\end{cases}$", 5+4.75*i,{})
g:Show()
\end{luadraw}
\end{demo}
    
\item La méthode \textbf{g:Dodesolve(f,t0,Y0,args)} permet le dessin d'une solution à l'équation \(Y'(t)=f(t,Y(t))\).
  \begin{itemize}
  \item L'argument obligatoire \emph{f} est une fonction \(f: (t,Y) -> f(t,Y)\) à valeurs dans \(R^n\) et où \emph{Y} est également dans \(R^n\) : \emph{Y=\{y1, y2,\ldots, yn\}} (lorsque $n=1$, \emph{Y} est un réel).
  \item Les arguments \emph{t0} et \emph{Y0} donnent les conditions initiales avec \emph{Y0=\{y1(t0), \ldots, yn(t0)\}} (les yi sont réels), ou \emph{Y0=y1(t0)} lorsque $n=1$.
  \item L'argument \emph{args} (facultatif) permet de définir les paramètres pour la courbe, c'est une table à 6 champs : 
  
\begin{TeXcode}
  { t={tmin,tmax}, out={i1,i2}, nbdots=50, method="rkf45"/"rk4", draw_options="", clip={x1,x2,y1,y2} }
\end{TeXcode}  

      \begin{itemize}
        \item Le champ \emph{t} détermine l'intervalle pour la variable \(t\), par défaut il vaut \emph{\{g:Xinf(), g:Xsup()\}}.
        \item Le champ \emph{out} est une table de deux entiers \{i1, i2\}, si \emph{M} désigne la matrice renvoyée par la fonction \emph{odesolve}, les points dessinés auront pour abscisses les M{[}i1{]} et pour ordonnées les M{[}i2{]}. Par défaut on a \emph{i1=1} et \emph{i2=2}, ce qui correspond à la fonction \emph{y1} en fonction de \emph{t}.
        \item Le champ \emph{nbdots} détermine le nombre de points à calculer pour la fonction (50 par défaut).
        \item Le champ \emph{method} détermine la méthode à utiliser, les valeurs possibles sont \emph{"rkf45"} (valeur par défaut), ou \emph{"rk4"}.
        \item Le champ \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.
      \item le champ \emph{clip} est soit \emph{nil} (valeur par défaut), soit une table \emph{\{x1,x2,y1,y2\}}, dans le premier cas la ligne est clippée par la fenêtre 2d courante \textbf{après} sa transformation par la matrice 2d du graphe, dans le second cas la ligne est clippée par la fenêtre $[x_1,x_2]\times[y_1,y_2]$ \textbf{avant} d'être transformée par la matrice du graphe.

      \end{itemize}
  \end{itemize}
\end{itemize}

\subsubsection{Courbes implicites : Dimplicit}

\begin{itemize}
\item La fonction \textbf{implicit(f,x1,x2,y1,y2,grid)} calcule et renvoie une une ligne polygonale constituant la courbe implicite d'équation $f(x,y)=0$ dans le pavé $[x_1,x_2]\times[y_1,y_2]$. Ce pavé est découpé en fonction du paramètre \emph{grid}.

      \begin{itemize}
      \item L'argument obligatoire \emph{f} est une fonction \(f: (x,y) -> f(x,y)\) à valeurs dans \(R\).
      \item Les arguments \emph{x1}, \emph{x2} ,\emph{y1}, \emph{y2} définissent la fenêtre du tracé, qui sera le pavé $[x_1,x_2]\times[y_1,y_2]$, on doit avoir \(x1<x2\) et \(y1<y2\).
      \item L'argument \emph{grid} est une table contenant deux entiers positifs : \{n1,n2\}, le premier entier indique le nombre de subdivisions suivant $x$, et le second le nombre de subdivisions suivant $y$.
      \end{itemize}
  
\item La méthode \textbf{g:Dimplicit(f,args)} fait le dessin de la courbe implicite d'équations $f(x,y)=0$.

      \begin{itemize}
      \item L'argument obligatoire \emph{f} est une fonction \(f: (x,y) -> f(x,y)\) à valeurs dans \(R\).
      \item   L'argument \emph{args} permet de définir les paramètres du tracé, c'est une table à 3 champs :
      
      \begin{TeXcode}
      { view={x1,x2,y1,y2}, grid={n1,n2}, draw_options="" }
      \end{TeXcode}
            \begin{itemize}
                \item Le champ \emph{view} détermine la zone de dessin $[x_1,x_2]\times[y_1,y_2]$.  Par défaut on a \emph{view=\{g:Xinf(), g:Xsup(), g:Yinf(), g:Ysup()\}},
                \item le champ \emph{grid} détermine la grille, ce champ vaut par défaut \emph{\{50,50\}},
                \item le champ \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.
            \end{itemize}
      \end{itemize}
\end{itemize}

\subsubsection{Courbes de niveau : Dcontour}

La méthode \textbf{g:Dcontour(f,z,args)} fait le dessin de \textbf{lignes de niveau} de la fonction \(f: (x,y) -> f(x,y)\) à valeurs réelles.

\begin{itemize}
  \item L'argument \emph{z} (obligatoire) est la liste des différents niveaux à tracer.
  \item L'argument \emph{args} (facultatif) permet de définir les paramètres du tracé, c'est une table à 4 champs :
  
  \begin{TeXcode}
    { view={x1,x2,y1,y2}, grid={n1,n2}, colors={"color1","color2",...}, draw_options="" }
  \end{TeXcode}

    \begin{itemize}
        \item Le champ \emph{view} détermine la zone de dessin {[}x1,x2{]}x{[}y1,y2{]}, par défaut on a \emph{view=\{g:Xinf(),g:Xsup(), g:Yinf(), g:Ysup()\}}.
        \item Le champ \emph{grid} détermine la grille, par défaut on a \emph{grid=\{50,50\}}.
        \item Le champ \emph{colors} est la liste des couleurs par niveau, par défaut cette liste est vide et c'est la couleur courante de tracé qui est utilisée.
        \item Le champ \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.
    \end{itemize}
\end{itemize}

\begin{demo}{Exemple avec Dcontour}
\begin{luadraw}{name=Dcontour}
local g = graph:new{window={-1,6.5,-1.5,11},size={10,10,0}}
local i, sin, cos = cpx.I, math.sin, math.cos
local f = function(x,y) return (x+y)/(2+cos(x)*sin(y)) end
local Lz = range(1,10) -- niveaux à tracer
local Colors = getpalette(palRainbow,10)
g:Dgradbox({0,5+10*i,1,1},{legend={"$x$","$y$"}, grid=true, title="$z=\\frac{x+y}{2+\\cos(x)\\sin(y)}$"})
g:Linewidth(12); g:Dcontour(f,Lz,{view={0,5,0,10}, colors=Colors})
for k = 1, 10 do
    local y = (2*k+4)/3*i
    g:Dseg({5.25+y,5.5+y},1,"color="..Colors[k])
    g:Labelcolor(Colors[k])
    g:Dlabel("$z="..k.."$",5.5+y,{pos="E"})
end
g:Show()
\end{luadraw}
\end{demo}

\subsubsection{Paramétrisation d'une ligne polygonale : \emph{curvilinear\_param}}
Soit $L$ une liste de complexe représentant une ligne \og continue \fg, il est possible d'obtenir une paramétrisation de cette ligne en fonction d'un paramètre $t$ entre $0$ et $1$ ($t$ est l'abscisse curviligne divisée par la longueur totale de $L$).

La fonction \textbf{curvilinear\_param(L,close)} renvoie une fonction d'une variable $t\in[0;1]$ et à valeurs sur la ligne  $L$ (nombres complexes), la valeur en $t=0$ est le premier point de $L$, et la valeur en $t=1$ est le dernier point; cette fonction est suivie d'un nombre qui représente la longueur total de L. L'argument optionnel \emph{close} indique si la ligne $L$  doit être refermée (\emph{false} par défaut).

\begin{demo}{Points répartis sur une ligne polygonale}
\begin{luadraw}{name=curvilinear_param}
local g = graph:new{bbox=false,size={10,10}}
local i = cpx.I; g:Linewidth(8)
local L = cartesian(math.sin,-5,5)[1]
insert(L, {5-2*i, -5-2*i})
local f = curvilinear_param(L, true)
local I = map(f,linspace(0,1,20)) -- 20 points répartis sur L
g:Shift(4*i)
g:Lineoptions(nil,"ForestGreen",6); g:Dpolyline(L,true)
g:Filloptions("full","white"); g:Ddots(I) -- le premier et le dernier point sont confondus car L est fermée

-- autre exemple d'utilisation:
local nb = 16 --nb arrows
local t = linspace(0,1,3*nb+1)
g:Shift(-4*i)
for k = 0,nb-1 do
    g:Dparametric(f,{t={t[3*k+1],t[3*k+3]},nbdots=10,nbdiv=2,draw_options="-stealth"})
end
g:Show() 
\end{luadraw}
\end{demo}


\subsection{Domaines liés à des courbes cartésiennes}

\subsubsection{Ddomain1}


\begin{itemize}
    \item La fonction \textbf{domain1(f,a,b,nbdots,discont,nbdiv)} renvoie une liste de complexes qui représente le contour de la partie du plan délimitée par la courbe de la fonction \emph{f} sur un intervalle \([a;b]\), l'axe \emph{Ox}, et les droites \(x=a\), \(x=b\).

    \item La méthode \textbf{g:Ddomain1(f,args)} dessine ce contour. L'argument \emph{args} (facultatif) permet de définir les paramètres pour la courbe, c'est une table à 5 champs : 

  \begin{TeXcode}
    { x={a,b},  nbdots=50, discont=false, nbdiv=5, draw_options="" }
  \end{TeXcode}
  
    \begin{itemize}
        \item Le champ \emph{x} détermine l'intervalle d'étude, par défaut il vaut \emph{\{g:Xinf(), g:Xsup()\}}.
        \item Le champ \emph{nbdots} détermine le nombre de points à calculer pour la fonction (50 par défaut).
        \item Le champ \emph{discont} indique s'il y a ou non des discontinuité pour la fonction (\emph{false} par défaut).
        \item Le champ \emph{nbdiv} est utilisé dans la méthode de calcul des points de la courbe (5 par défaut).
        \item Le champ \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.
    \end{itemize}
\end{itemize}
    
\subsubsection{Ddomain2}

\begin{itemize}
    \item La fonction \textbf{domain2(f,g,a,b,nbdots,discont,nbdiv)} renvoie une liste de complexes qui représente le contour de la partie du plan délimitée par la courbe de la fonction \emph{f}, la courbe de la fonction \emph{g}, et les droites \(x=a\), \(x=b\).
    
    \item La méthode \textbf{g:Ddomain2(f,g,args)} dessine ce contour. L'argument \emph{args} (facultatif) permet de définir les paramètres pour les courbes, c'est une table à 6 champs : 

\begin{TeXcode}
    { x={a,b}, nbdots=50, discont=false, nbdiv=5, draw_options="" }
\end{TeXcode}

\begin{itemize}
  \item Le champ \emph{x} détermine l'intervalle d'étude, par défaut il vaut \emph{\{g:Xinf(), g:Xsup()\}}.
  \item Le champ \emph{nbdots} détermine le nombre de points à calculer pour la fonction (50 par défaut).
  \item Le champ \emph{discont} indique s'il y a ou non des discontinuité pour la fonction (false par défaut).
  \item Le champ \emph{nbdiv} est utilisé dans la méthode de calcul des points de la courbe (5 par défaut).
  \item Le champ \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.
\end{itemize}
\end{itemize}
  
\subsubsection{Ddomain3}

\begin{itemize}
    \item La fonction \textbf{domain3(f,g,a,b,nbdots,discont,nbdiv)} renvoie une liste de complexes qui représente le contour de la partie du plan délimitée par la courbe de la fonction \emph{f} et celle de la fonction \emph{g} (avec recherche de points d'intersection dans l'intervalle $[a;b]$).
 
    \item La méthode \textbf{g:Ddomain3(f,g,args)} dessine ce contour. L'argument \emph{args} (facultatif) permet de définir les paramètres pour la courbe, c'est une table à 5 champs : 

\begin{TeXcode}
    { x={a,b}, nbdots=50, discont=false, nbdiv=5, draw_options="" }
\end{TeXcode}

\begin{itemize}
  \item Le champ \emph{x} détermine l'intervalle d'étude, par défaut il vaut \emph{\{g:Xinf(), g:Xsup()\}}.
  \item Le champ \emph{nbdots} détermine le nombre de points à calculer pour la fonction (50 par défaut).
  \item Le champ \emph{discont} indique s'il y a ou non des discontinuité pour la fonction (false par défaut).
  \item Le champ \emph{nbdiv} est utilisé dans la méthode de calcul des points de la courbe (5 par défaut).
  \item Le champ \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.
\end{itemize}
\end{itemize}

\begin{demo}{Partie entière, fonctions Ddomain1 et Ddomain3}
\begin{luadraw}{name=courbe}
local g = graph:new{ window={-5,5,-5,5}, bg="", size={10,10} }
local f = function(x) return (x-2)^2-2 end
local h = function(x) return 2*math.cos(x-2.5)-2.25 end
g:Daxes( {0,1,1},{grid=true,gridstyle="dashed", arrows="->"})
g:Filloptions("full","brown",0.3)
g:Ddomain1( math.floor, { x={-2.5,3.5} })
g:Filloptions("none","white",1); g:Lineoptions("solid","red",12)
g:Dstepfunction( {range(-5,5), range(-5,4)},{draw_options="arrows={Bracket-Bracket[reversed]},shorten >=-2pt"})
g:Labelcolor("red")
g:Dlabel("Partie entière",Z(-3,3),{node_options="fill=white"})
g:Ddomain3(f,h,{draw_options="fill=blue,fill opacity=0.6"})
g:Dcartesian(f, {x={0,5}, draw_options="blue"})
g:Dcartesian(h, {x={0,5}, draw_options="green"})
g:Show()
\end{luadraw}
\end{demo}

\subsection{Points (Ddots) et labels (Dlabel)}

\begin{itemize}
\item La méthode pour dessiner un ou plusieurs points est : \textbf{g:Ddots(dots, mark\_options)}.

    \begin{itemize}
    \item L'argument \emph{dots} peut être soit un seul point (donc un complexe), soit une liste (une table) de complexes, soit une liste  de liste de complexes. Les points sont dessinés dans la couleur courante du tracé de lignes.
    \item L'argument \emph{mark\_options} est une chaîne de caractères facultative qui sera passée telle quelle à l'instruction \emph{\textbackslash draw} (modifications locales), exemple :
\begin{TeXcode}
    "color=green, line width=1.2, scale=0.25"
\end{TeXcode}

    \item  Deux méthodes pour modifier globalement l'apparence des points :
        \begin{itemize}
        \item La méthode \textbf{g:Dotstyle(style)} qui définit le style de point, l'argument \emph{style} est une chaîne de caractères qui vaut par défaut \emph{"*"}. Les styles possibles sont ceux de la librairie \emph{plotmarks}.
        \item La méthode \textbf{g:Dotscale(scale)} permet de jouer sur la taille du point, l'argument \emph{scale} est un entier positif qui vaut $1$ par défaut, il sert à multiplier la taille par défaut du point. La largeur courante de tracé de ligne intervient également dans la taille du point. Pour les style de points "pleins" (par exemple le style \emph{triangle*}), le style et la couleur de remplissage courants sont utilisés par la librairie.
        \end{itemize}
    \end{itemize}
    
\item La méthode pour placer un label est : 

\hfil\textbf{g:Dlabel(text1, anchor1, args1, text2, anchor2, args2, ...)}.\hfil

    \begin{itemize}
    \item  Les arguments \emph{text1, text2,...} sont des chaînes de caractères, ce sont les labels.
    \item  Les arguments \emph{anchor1, anchor2,...} sont des complexes représentant les points d'ancrage des labels.
    \item  Les arguments \emph{args1,arg2,...}  permettent de définir localement les paramètres des labels, ce sont des tables à 4 champs :
\begin{TeXcode}
    { pos=nil, dist=0, dir={dirX,dirY,dep}, node_options="" }
\end{TeXcode}
        \begin{itemize}
            \item Le champ \emph{pos} indique la position du label par rapport au point d'ancrage, il peut valoir \emph{"N"} pour nord, \emph{"NE"} pour nord-est, \emph{"NW"} pour nord-ouest, ou encore \emph{"S"}, \emph{"SE"}, \emph{"SW"}. Par défaut, il vaut \emph{center}, et dans ce cas le label est centré sur le point  d'ancrage.
            \item Le champ \emph{dist} est une distance en cm qui vaut $0$ par défaut, c'est la distance entre le label et son point d'ancrage lorsque \emph{pos} n'est pas égal a \emph{center}.
            \item \emph{dir=\{dirX,dirY,dep\}} est la direction de l'écriture. Les 3 valeurs \emph{dirX}, \emph{dirY} et \emph{dep} sont trois complexes représentant 3 vecteurs, les deux premiers indiquent le sens de l'écriture, le troisième un déplacement (translation) du label par rapport au point d'ancrage. Le vecteur \emph{dep} est nul par défaut, et le vecteur \emph{dirY}, s'il est absent, est égal au vecteur \emph{dirX} tourné de 90 degrés dans le sens direct.
            Par défaut l'option \emph{dir} est égale à la valeur courante de la direction de l'écriture.
            \item L'argument \emph{node\_options} est une chaîne (vide par défaut) destinée à recevoir des options qui seront directement passées à tikz dans l'instruction \emph{node{[}{]}}.
            \item Les labels sont dessinés dans la couleur courante du texte du document, mais on peut changer de couleur avec l'argument \emph{node\_options} en mettant par exemple : \emph{node\_options="color=blue"}.
            
            \textbf{Attention} : les options choisies pour un label s'appliquent aussi aux labels suivants si elles sont inchangées.
        \end{itemize}
  \end{itemize}

Options globales pour les labels :

    \begin{itemize}
        \item la méthode \textbf{g:Labelstyle(position)} permet de préciser la position des labels par rapport aux points d'ancrage. L'argument \emph{position} est une chaîne qui peut valoir : \emph{"N"} pour  nord, \emph{"NE"} pour nord-est, \emph{"NW"} pour nord-ouest, ou  encore \emph{"S"}, \emph{"SE"}, \emph{"SW"}. Par défaut, il
  vaut \emph{center}, et dans ce cas le label est centré sur le point  d'ancrage.
  
    \item La méthode \textbf{g:Labelcolor(color)} permet de définir la couleur des labels. L'argument \emph{color} est une chaîne représentant une couleur pour tikz. Par défaut l'argument est une chaîne vide ce qui représente la couleur courante du document.
    
    \item La méthode \textbf{g:Labelangle(angle)} permet de préciser un angle (en degrés) de rotation des labels autour du point d'ancrage, cet angle est nul par défaut.
    
    \item La méthode \textbf{g:Labelsize(size)} permet de gérer la taille des labels. L'argument \emph{size} est une chaîne qui peut valoir : \emph{"tiny"}, ou \emph{"scriptsize"} ou \emph{"footnotesize"}, etc. Par défaut l'argument est une chaîne vide, ce qui représente la taille \emph{"normalsize"}.
    
    \item La méthode \textbf{g:Labeldir(dir)} permet de gérer la direction l'écriture. l'argument \emph{dir} est une table de la forme \emph{dir=\{dirX, dirY, dep\}}, les 3 valeurs \emph{dirX}, \emph{dirY} et \emph{dep} sont trois complexes représentant 3 vecteurs, les deux premiers indiquent le sens de l'écriture, le troisième un déplacement (translation) du label par rapport au point d'ancrage. Le vecteur \emph{dep} est nul par défaut, et le vecteur \emph{dirY}, s'il est absent, est égal au vecteur \emph{dirX} tourné de 90 degrés dans le sens direct. Lorsque \emph{dir=\{\}}, cela représente le sens usuel de l'écriture.
  \end{itemize}
  
  
\item La méthode \textbf{g:Dlabeldot(texte,anchor,args)} permet de placer un label et de dessiner le point d'ancrage en même temps.

    \begin{itemize}
    \item L'argument \emph{texte} est une chaîne de caractères, c'est le label.
    \item L'argument \emph{anchor} est un complexe représentant le point d'ancrage du label.
    \item L'argument \emph{args} (facultatif) permet de définir les paramètres du label et du point, c'est une table à 4 champs :
    
\begin{TeXcode}
    { pos=nil, dist=0, node_options="", mark_options="" }
\end{TeXcode}

    On retrouve les champs identiques à ceux de la méthode \emph{Dlabel}, plus le champ \emph{mark\_options} qui est une chaîne de caractères qui sera passée telle quelle à l'instruction \emph{\textbackslash draw} lors du dessin du point d'ancrage.
    \end{itemize}
\end{itemize}

\subsection{Chemins : Dpath, Dspline et Dtcurve}

\subsubsection{Qu'est ce qu'un chemin}

Un chemin est une table de nombres complexes et d'instructions (sous forme de chaînes), cette table représente une succession de différents "morceaux", chaque morceau est une succession de données (points 2d et parfois valeurs numériques) et se termine par une chaîne de caractères qui représente une instruction. Le chemin est régi par la règle suivante: \par
\hfil\textbf{ le dernier point d'un morceau est le premier point du morceau suivant (il n'est donc pas répété) }\hfil\par

\paragraph{Exemple:}
\begin{Luacode}
 local L = { Z(-3,2),"m",-3,-2,"l",0,2,2,-1,"ca",3,Z(3,3),0.5,"la",1,Z(-1,5),Z(-3,2),"b" } 
\end{Luacode}
Le chemin \emph{L} est composé de cinq morceaux, qui sont:
    \begin{enumerate}
        \item \emph{\{Z(-3,2),"m"\}}: il y a une donnée et l'instruction "m" qui signifie \emph{moveto}, cette instruction ne fait pas de dessin proprement dit, mais elle permet de commencer une nouvelle composante dont le premier point est $Z(-3,2)$ (le dernier point du morceau précédent, s'il y en a un, n'est pas pris en compte par cette instruction, c'est la seule exception).
        
        \item \emph{\{Z(-3,2),-3,-2,"l"\}}:  le premier point du deuxième morceau est bien $Z(-3,2)$ et non pas $-3$, car $Z(-3,2)$ est le dernier point du morceau précédent. Il y a donc trois données et l'instruction "l" qui signifie \emph{lineto}, c'est comme si on exécutait l'instruction \verb|g:Dpolyline( {Z(-3,2),-3,-2} )|, ces trois points sont donc reliés par un segment. Le dernier point de ce morceau est \emph{-2}.
        
        \item \emph{\{-2,0,2,2,-1,"ca"\}}: le premier point du troisième morceau est bien $-2$ et non pas $0$, car $-2$ est le dernier point du morceau précédent.  Il y a cinq données et l'instruction "ca" qui signifie \emph{circle arc}, c'est comme si on exécutait l'instruction \verb|g:Darc(-2,0,2,2,-1)|, donc le centre est $0$, l'arc va de $-2$ à $2$ avec un rayon égal à $2$ et dans le sens des aiguilles d'un montre (dernière valeur $-1$). Le dernier point de ce morceau est $2$.
        \item \emph{\{2,3,Z(3,3),0.5,"la"\}}: le premier point du quatrième morceau est $2$ (et non pas $3$), il y a quatre données et l'instruction "la" qui signifie \emph{line arc}, c'est une ligne polygonale aux angles arrondis avec un arc de cercle de rayon $0.5$ (valeur qui précède l'instruction). Les points de cette ligne sont \emph{2, 3, Z(3,3)}, il y aura donc un arrondi en $3$. Le dernier point de ce morceau est $Z(3,3)$.
        
        \item \emph{\{Z(3,3),1,Z(-1,5),Z(-3,2),"b"\}}: le premier point du cinquième morceau est $Z(3,3)$ (et non pas $1$), l'instruction "b" signifie \emph{bezier}, on dessine donc une courbe de Bézier allant de $Z(3,3)$ jusqu'à $Z(-3,2)$, les deux autres points, $1$ et $Z(-1,5)$ sont le premier et le deuxième point de contrôle de la courbe.
    \end{enumerate}

Voici ce que donne ce chemin:
\begin{demo}{Path example}
\begin{luadraw}{name=path_example}
local g = graph:new{window={-4,4,-0.5,3}, size={10,10}}
local L = { Z(-3,2),"m",-3,-2,"l",0,2,2,-1,"ca",3,Z(3,3),0.5,"la",1,Z(-1,5),Z(-3,2),"b" } 
g:Dpath(L, "line width=0.8pt, blue")
g:Ddots({Z(-3,2),-3,-2,0,2,3,Z(3,3)})
g:Dlabel("$Z(-3,2)$",Z(-3,2),{pos="W"}, "$-3$",-3,{pos="S"}, "$-2$",-2,{}, "$0$",0,{}, "$2$",2,{}, "$3$",3,{}, "$Z(3,3)$",Z(3,3),{pos="E"})
g:Show()
\end{luadraw}
\end{demo}

\noindent\textbf{Remarque}: dans l'exemple ci-dessus, vous pouvez remplacer la partie: \emph{Z(-3,2),"m",-3,-2,"l"}, par: \emph{Z(-3,2),-3,-2,"l"} car il n'y a pas d'autre morceau avant le \emph{moveto}.

\noindent\textbf{Instructions disponibles et leur syntaxe}, le mot \emph{last} représente le dernier point du morceau précédent:
      \begin{itemize}
      \item \emph{z1,"m"} (moveto), permet de commencer une nouvelle composante du chemin au point d'affixe $z1$.
      \item \emph{z1,...,zn,"l"} (lineto), dessine la ligne polygonale \emph{\{last,z1,...,zn\}}.
      \item \emph{c1,c2,z2,"b"} (bézier) dessine la courbe de Bézier \emph{\{last,c1,c2,z2\}}, où $c1$ et $c2$ sont les deux points de contrôle.
      \item \emph{z1,...,zn,"s"} (spline), dessine la spline cubique naturelle passant par les points \emph{\{last,z1,...,zn\}}.
      \item \emph{z1,"c"} (cercle), dessine le cercle de centre $z1$ et passant par le point \emph{last}. Il y a une autre syntaxe possible pour le cercle : \emph{z1,z2,"c"}, dans ce cas on dessine le cercle passant par les points \emph{last}, $z1$ et $z2$.
      \item \emph{z1,z2,r,sens,"ca"} (arc de cercle), dessine un arc de cercle de centre $z1$, de rayon $r$, allant de \emph{last} vers $z2$, dans le sens trigonométrique lorsque \emph{sens=1} (et donc dans le sens inverse si \emph{sens=-1}).
      \item \emph{z1,z2,rx,ry,inclinaison,"ea"} (arc d'ellipse), dessine un arc d'ellipse de centre $z1$ allant de \emph{last} vers $z2$, $rx$ et $ry$ sont les deux rayons suivant les deux axes de l'ellipse, \emph{inclinaison} est l'angle en degrés que fait le premier axe de l'ellipse (celui qui porte $rx$) avec l'horizontal. Le paramètre \emph{inclinaison} est facultatif, il vaut $0$ par défaut.
      \item \emph{z1,rx,ry,inclinaison,"e"} (ellipse), dessine l'ellipse de centre $z1$, passant par \emph{last}, $rx$ et $ry$ sont les deux rayons suivant les deux axes de l'ellipse, \emph{inclinaison} est l'angle en degrés que fait le premier axe de l'ellipse (celui qui porte $rx$) avec l'horizontal. Le paramètre \emph{inclinaison} est facultatif, il vaut $0$ par défaut. Lorsque le point \emph{last} n'est pas sur cette ellipse, alors un segment est tracé entre ce point et un point de l'ellipse.
      \item \emph{z1,...,zn,r,"la"} (line arc), dessine la ligne polygonale \emph{\{last,z1,...,zn\}} en remplaçant chaque "angle" par un arc de cercle de rayon $r$.
      \item \emph{z1,...,zn,r,"cla"} (closed line arc), même chose que l'instruction précédente, sauf que la ligne est refermée. 
      \item \emph{"cl"} (closepath), cette instruction s'utilise seule, elle permet de refermer la composante courante en traçant un segment reliant le dernier point au premier point (de la composante courante).
      \end{itemize}
  
\subsubsection{Dessiner un chemin}

\begin{itemize}
\item La fonction \textbf{path(chemin,nbdots)} renvoie une ligne polygonale contenant les points constituant le \emph{chemin}. L'argument facultatif, \emph{nbdots} est le nombre minimal de points calculés pour chaque courbe de Bézier, sa valeur par défaut est la variable globale \emph{bezier\_nbdots} qui est initialisée à $8$.

\item La méthode \textbf{g:Dpath(chemin,draw\_options)} fait le dessin du \emph{chemin} (en utilisant au maximum les courbes de Bézier, y compris pour les arcs, les ellipses, etc). L'argument \emph{draw\_options} est une chaîne de caractères qui sera passée directement à l'instruction \emph{\textbackslash draw}.
      \begin{itemize}
      \item L'argument \emph{chemin} a été décrit ci-dessus.
      \item L'argument \emph{draw\_options} est une chaîne (vide par défaut) qui sera passée telle quelle à l'instruction \emph{\textbackslash draw}.
      \end{itemize}
  
\item La fonction \textbf{spline(points,v1,v2)} renvoie sous forme de chemin (à dessiner avec Dpath) la spline cubique passant par les points de l'argument \emph{points} (qui doit être une liste de complexes). Les arguments \emph{v1} et \emph{v2} sont vecteurs tangents imposés aux extrémités (contraintes), lorsque ceux-ci sont égaux à \emph{nil}, c'est une spline cubique naturelle (c'est à dire sans contrainte) qui est calculée.

\item La méthode \textbf{g:Dspline(points,v1,v2,draw\_options)} fait le dessin de la spline décrite ci-dessus. L'argument \emph{draw\_options} est une chaîne de caractères qui sera passée directement à l'instruction \emph{\textbackslash draw}.

\begin{demo}{Path et Spline}
\begin{luadraw}{name=path_spline}
local g = graph:new{window={-5,5,-5,5},size={10,10},bg="Beige"}
local i = cpx.I
local p = {-3+2*i,"m",-3,-2,"l",0,2,2,1,"ca",3,3+3*i,0.5,"la",1,-1+5*i,-3+2*i,"b",-1,"m",0,"c"}
g:Daxes( {0,1,1} )
g:Filloptions("full","blue!30",1,true); g:Dpath(p,"line width=0.8pt")
g:Filloptions("none")
local A,B,C,D,E = -4-i,-3*i,4,3+4*i,-4+2*i
g:Lineoptions(nil,"ForestGreen",12); g:Dspline({A,B,C,D,E},nil,-5*i) -- contrainte en E
g:Ddots({A,B,C,D,E},"fill=white,scale=1.25")
g:Show()
\end{luadraw}
\end{demo}

\item La fonction \textbf{tcurve(L} renvoie sous forme de chemin une courbe passant par des points donnés avec des vecteurs tangents (à gauche et à droite) imposés à chaque point. \emph{L} est une table de la forme :
\begin{Luacode}
L = {point1,{t1,a1,t2,a2}, point2,{t1,a1,t2,a2}, ..., pointN,{t1,a1,t2,a2}}
\end{Luacode}
\emph{point1}, ..., \emph{pointN} sont les points d'interpolation de la courbe (affixes), et chacun d'eux est suivi d'une table de la forme \verb|{t1,a1,t2,a2}| qui précise les vecteurs tangents à la courbe à gauche du point (avec \emph{t1} et \emph{a1}) et à droite du point (avec \emph{t2} et \emph{a2}). Le vecteur tangent à gauche est donné par la formule $V_g = t_1\times e^{ia_1\pi/180}$, donc $t1$ représente le module et $a1$ est un argument \textbf{en degrés} de ce vecteur. C'est la même chose avec \emph{t2} et \emph{a2} pour le vecteur tangent à droite, \textbf{mais ceux-ci sont facultatifs}, et s'ils ne sont pas précisés alors ils prennent les mêmes valeurs que \emph{t1} et \emph{a1}.

Deux points consécutifs seront reliés par une courbe de Bézier, la fonction calcule les points de contrôle pour avoir les vecteurs tangents souhaités.

\item La méthode \textbf{g:Dtcurve(L,options)} fait le dessin du chemin obtenu par \emph{tcurve} décrit ci-dessus. L'argument \emph{options} est une table à deux champs:
    \begin{itemize}
        \item \emph{showdots=true/false} (false par défaut), cette option permet de dessiner les points d'interpolation donnés ainsi que les points de contrôles calculés, ce qui permet une visualisation des contraintes.
        \item \emph{draw\_options=""}, c'est une chaîne de caractères qui sera passée directement à l'instruction \emph{\textbackslash draw}.
    \end{itemize}
\end{itemize}

\begin{demo}{Courbe d'interpolation avec vecteurs tangents imposés}
\begin{luadraw}{name=tcurve}
local g = graph:new{window={-0.5,10.5,-0.5,6.5},size={10,10,0}}
local i = cpx.I
local L = {
    1+4*i,{2,-20},
    2+3*i,{2,-70},
    4+i/2,{3,0},
    6+3*i,{4,15},
    8+6*i,{4,0,4,-90}, -- point anguleux
    10+i,{3,-15}}
g:Dgrid({0,10+6*i},{gridstyle="dashed"})
g:Daxes(nil,{limits={{0,10},{0,6}},originpos={"center","center"}, arrows="->"})
g:Dtcurve(L,{showdots=true,draw_options="line width=0.8pt,red"})
g:Show()
\end{luadraw}
\end{demo}

\subsection{Chemins et clipping : Beginclip() et Endclip()}

Un chemin peut être utilisé pour faire du clipping grâce à deux fonctions : \textbf{g:Beginclip(chemin,inverse)} et \textbf{g:Endclip()}. La première ouvre un groupe \emph{scope} et passe le \emph{chemin} comme argument à la fonction \emph{\textbackslash clip} de tikz. La seconde referme le groupe \emph{scope}, elle est indispensable (sinon il y aura une erreur de compilation).
L'argument \emph{inverse} est un booléen qui vaut \emph{false} par défaut, lorsqu'il a la valeur \emph{true} le clipping est inversé, c'est à dire que seul ce qui est à l'extérieur du \emph{chemin} sera dessiné, mais il faut pour cela que celui-ci soit dans le sens trigonométrique.

\begin{demo}{Exemple de clipping}
\begin{luadraw}{name=polygon_with_different_line_color_and_rounded_corners}
local g = graph:new{window={-5,5,-5,5},size={10,10}}
local i = cpx.I
local Dcolored_polyreg = function(c,a,nb,r,wd,colors) 
-- c=center, a=vertice, nb=number of sides, r=radius, wd=width in point, colors=list of colors
    local L = polyreg(c,a,nb)
    insert(L,{r,"cla"}) --polygon width rounded corners (radius=r)
    local angle = 360/nb
    local b = a
    for k = 1, nb do
        a = b; b = rotate(a,angle,c)
        g:Beginclip({2*a-c,c,2*b-c,"l"})  -- définition d'un secteur angulaire pour clipper
        g:Dpath(L,"line width="..wd.."pt,color="..colors[k])
        g:Endclip()
    end
end
Dcolored_polyreg(3+2*i,5+2*i,5,0.8,12,{"red","blue","orange","green","yellow"}) -- pentagon
Dcolored_polyreg(-2.5-2*i,-5-2*i,7,1,24,getpalette(palGasFlame,7))  -- heptagon
g:Show()
\end{luadraw}
\end{demo}


\subsection{Axes et grilles}

Variables globales utilisées pour les axes et les grilles :
\begin{itemize}
    \item \emph{maxGrad = 100} : nombre max de graduations sur un axe.
    \item \emph{defaultlabelshift = 0.125} : lorsqu'une grille est dessinée avec les axes (option \emph{grid=true}) les labels sont automatiquement décalés le long de l'axe avec cette variable.
    \item \emph{defaultxylabelsep = 0} : définit la distance par défaut entre les labels et les graduations.
    \item \emph{defaultlegendsep = 0.2} : définit la distance par défaut entre la légende et l'axe.
    \item \emph{digits = 4} : nombre de décimales par défaut dans les conversions en chaînes de caractères, les $0$ terminaux sont supprimés.
    \item \emph{dollar = true} :  pour ajouter des dollars autour des labels des graduations.
    \item \emph{siunitx = false} :  avec la valeur \emph{true} les labels sont formatés avec la macro \verb|\num{..}| du package \emph{siunitx}, ce qui permet d'utiliser certaines options de ce package, comme remplacer le point décimal par une virgule en faisant :\par
    \begin{TeXcode}
    \usepackage[local=FR]{siunitx}
    \end{TeXcode}
    ou bien en faisant :
    \begin{TeXcode}
    \usepackage{siunitx}
    \sisetup{output-decimal-marker={,}}
    \end{TeXcode}
\end{itemize}
Pour les axes, en 2d comme en 3d, tous les labels sont formatés en chaînes de caractères avec la fonction \textbf{num(x)}, celle-ci transforme le nombre $x$ en une chaîne \emph{str} avec le nombre de décimales fixées par la variable globale \emph{digits}, lorsque la variable \emph{siunitx} a la valeur \emph{true}, la fonction renvoie \verb|"\num{str}"|, sinon elle renvoie simplement \emph{str}. Ceci vaut pour également pour les axes en 3d. Voici le code de cette fonction:
\begin{Luacode}
function num(x) -- x is a real, returns a string
    local rep = strReal(x) -- conversion to string with digits decimals max
    if siunitx then rep = "\\num{"..rep.."}" end --needs \usepackage{siunitx}
    return rep
end
\end{Luacode}

\subsubsection{Daxes}
\def\opt#1{\textcolor{blue}{\texttt{#1}}}%
Le tracé des axes s'obtient avec la méthode \textbf{g:Daxes( \{A,xpas,ypas\}, options)}.
\begin{itemize}
    \item Le premier argument précise le point d'intersection des deux axes (c'est le complexe \emph{A}), le pas des graduations sur l'axe $Ox$ (c'est \emph{xpas}) et le pas des graduations sur $Oy$ (c'est \emph{ypas}). Par défaut le point \emph{A} est l'origine $Z(0,0)$, et les deux pas sont égaux à $1$.
    \item L'argument \emph{options} est une table précisant les options possibles. Voici ces options avec leur valeur par défaut :
        \begin{itemize}
            \item \opt{showaxe=\{1,1\}}. Cette option précise si les axes doivent être tracés ou pas ($1$ ou $0$). La première valeur est pour l'axe $Ox$ et la seconde pour l'axe $Oy$.
            \item \opt{arrows="-"}. Cette option permet d'ajouter ou non une flèche aux axes (pas de flèche par défaut, mettre "->" pour ajouter une flèche).
            \item \opt{limits=\{"auto","auto"\}}. Cette option permet de préciser l'étendue des deux axes (première valeur pour $Ox$, seconde valeur pour $Oy$). La valeur "auto" signifie que c'est la droite en entier, mais on peut préciser les abscisses extrêmes, par exemple : \opt{limits=\{\{-4,4\},"auto"\}}.
            \item \opt{gradlimits=\{"auto","auto"\}}. Cette option permet de préciser l'étendue des graduations sur les deux axes (première valeur pour $Ox$, seconde valeur pour $Oy$). La valeur "auto" signifie que c'est la droite en entier, mais on peut préciser les graduations extrêmes, par exemple : \opt{gradlimits=\{\{-4,4\},\{-2,3\}\}}.
            \item \opt{unit=\{"",""\}}. Cette option permet de préciser de combien en combien vont les graduations sur les axes. La valeur par défaut ("") signifie qu'il faut prendre la valeur du pas (\emph{xpas} sur $Ox$, ou \emph{ypas} sur $Oy$), SAUF lorsque l'option \opt{labeltext} n'est pas la chaîne vide, dans ce cas \emph{unit} prend la valeur $1$.
            \item \opt{nbsubdiv=\{0,0\}}. Cette option permet de préciser le nombre de subdivisions entre deux graduations principales sur l'axe.
            \item \opt{tickpos=\{0.5,0.5\}}. Cette option précise la position des graduations par rapport à chaque axe, ce sont deux nombres entre $0$ et $1$, la valeur par défaut de $0.5$ signifie qu'ils sont centrés sur l'axe. ($0$ et $1$ représentent les extrémités).
            \item \opt{tickdir=\{"auto","auto"\}}. Cette option indique la direction des graduations sur l'axe. Cette direction est un vecteur (complexe) non nul. La valeur par défaut "auto" signifie que les graduations sont orthogonales à l'axe.
            \item \opt{xyticks=\{0.2,0.2\}}. Cette option précise la longueur des graduations sur l'axe.
            \item \opt{xylabelsep=\{0,0\}}. Cette option précise la distance entre les labels et les graduations sur l'axe.
            \item \opt{originpos=\{"right","top"\}}. Cette option précise la position du label à l'origine sur l'axe, les valeurs possibles sont : "none", "center", "left", "right" pour $Ox$, et "none", "center", "bottom", "top" pour $Oy$.
            \item \opt{originnum=\{A.re,A.im\}}. Cette option précise la valeur de la graduation au croisement des axes (graduation numéro $0$). 
            
            La formule qui définit le label à la graduation numéro $n$ est : \textbf{(originnum + unit*n)"labeltext"/labelden}.
            \item \opt{originloc=A}. Cette option précise le point de croisement des axes.
            \item \opt{legend=\{"",""\}}. Cette option permet de préciser une légende pour l'axe.
            \item \opt{legendpos=\{0.975,0.975\}}. Cette option précise la position (entre $0$ et $1$) de la légende par rapport à chaque axe.
            \item \opt{legendsep=\{0.2,0.2\} }. Cette option précise la distance entre la légende et l'axe. La légende est de l'autre côté de l'axe par rapport aux graduations.
            \item \opt{legendangle=\{"auto","auto"\}}. Cette option précise l'angle (en degrés) que doit faire la légende pour l'axe. La valeur "auto" par défaut signifie que la légende doit être parallèle à l'axe si l'option \emph{labelstyle} est aussi à "auto", sinon la légende est horizontale.
            \item \opt{legendstyle=\{"auto","auto"\}}. Précise le style de label pour les légendes, avec la valeur \emph{"auto"} celui-ci est déterminé automatiquement, sinon on peut utiliser les valeurs: "N", "NW", "W", "SW", "S", "SE", "E", "NE".
            \item \opt{labelpos=\{"bottom","left"\}}. Cette option précise la position des labels par rapport à l'axe. Pour l'axe $Ox$, les valeurs possibles sont : "none", "bottom" ou "top", pour l'axe $Oy$ c'est :  "none", "right" ou "left".
            \item \opt{labelden=\{1,1\}}. Cette option précise le dénominateur des labels (entier) pour l'axe. La formule qui définit le label à la graduation numéro $n$ est : \textbf{(originnum + unit*n)"labeltext"/labelden}.
            \item \opt{labeltext=\{"",""\}}. Cette option définit le texte qui sera ajouté au numérateur des labels pour l'axe.
            \item \opt{labelstyle=\{"S","W"\}}. Cette option définit le style des labels pour chaque axe. Les valeurs possibles sont "auto","N", "NW", "W", "SW", "S", "SE", "E".
            \item \opt{labelangle=\{0,0\}}. Cette option définit pour chaque axe l'angle des labels en degrés par rapport à l'horizontale.
            \item \opt{labelcolor=\{"",""\}}. Cette option permet de choisir une couleur pour les labels sur chaque axe. La chaîne vide représente la couleur par défaut.
            \item \opt{labelshift=\{0,0\}}. Cette option permet de définir un décalage systématique pour les labels sur l'axe (décalage de long de l'axe).
            \item \opt{nbdeci=\{2,2\}}. Cette option précise le nombre de décimales pour les valeurs numériques sur l'axe.
            \item \opt{numericFormat=\{0,0\}}. Cette option précise le type d'affiche numérique (non encore implémenté).
            \item \opt{myxlabels=""}. Cette option permet d'imposer des labels personnels sur l'axe $Ox$. Lorsqu'il y en a, la valeur passée à l'option doit être une liste du type : \verb|{pos1,"text1", pos2,"text2",...}|. Le nombre \emph{pos1} représente une abscisse dans le repère (A,xpas), ce qui correspond au point d'affixe $A+$pos1$*$xpas.
            \item \opt{myylabels=""}. Cette option permet d'imposer des labels personnels sur l'axe $Oy$. Lorsqu'il y en a, la valeur passée à l'option doit être une liste du type : \verb|{pos1,"text1", pos2,"text2",...}|. Le nombre \emph{pos1} représente une abscisse dans le repère (A,i*ypas), ce qui correspond au point d'affixe $A+$pos1$*$ypas$*i$.
            \item \opt{grid=false}. Cette option permet d'ajouter ou non une grille.
            \item \opt{drawbox=false}. Cette option de dessiner les axes sous la forme d'une boite, dans ce cas, les graduations sont sur le côté gauche et le côté bas.
            \item \opt{gridstyle="solid"}. Cette option définit le style ligne pour la grille principale.
            \item \opt{subgridstyle="solid"}. Cette option définit le style ligne pour la grille secondaire. Une grille secondaire apparaît lorsqu'il y a des subdivisions sur un des axes.
            \item  \opt{gridcolor="gray"}. Ceci définit la couleur de la grille principale.
            \item \opt{subgridcolor="lightgray"}. Ceci définit la couleur de la grille secondaire.
            \item \opt{gridwidth=4}. Épaisseur de trait de la grille principale (ce qui fait 0.4pt).
            \item \opt{subgridwidth=2}. Épaisseur de trait de la grille secondaire (ce qui fait 0.2pt).
        \end{itemize}
\end{itemize}

\begin{demo}{Exemple avec axes avec grille}
\begin{luadraw}{name=axes_grid}
local g = graph:new{window={-6.5,6.5,-3.5,3.5}, size={10,10,0}}
local i, pi, a = cpx.I, math.pi, math.sqrt(2)
local f = function(x) return 2*a*math.sin(x) end
g:Labelsize("footnotesize"); g:Linewidth(8)
g:Daxes({0,pi/2,a},{labeltext={"\\pi","\\sqrt{2}"}, labelden={2,1},nbsubdiv={1,1},grid=true,arrows="->"})
g:Lineoptions("solid","Crimson",12); g:Dcartesian(f, {x={-2*pi,2*pi}})
g:Show()
\end{luadraw}
\end{demo}

\subsubsection{DaxeX et DaxeY}

Les méthodes \textbf{g:DaxeX(\{A,xpas\}, options)} et \textbf{g:DaxeY(\{A,ypas\}, options)} permettent de tracer les axes séparément.
\begin{itemize}
    \item Le premier argument précise le point servant d'origine (c'est le complexe \emph{A}) et le pas des graduations sur l'axe. Par défaut le point \emph{A} est l'origine $Z(0,0)$, et le pas est égal à $1$.
    \item L'argument \emph{options} est une table précisant les options possibles. Voici ces options avec leur valeur par défaut :
        \begin{itemize}
            \item \opt{showaxe=1}. Cette option précise si l'axe doit être tracé ou non ($1$ ou $0$).
            \item \opt{arrows="-"}. Cette option permet d'ajouter ou non une flèche à l'axe (pas de flèche par défaut, mettre "->" pour ajouter une flèche).
            \item \opt{limits="auto"}. Cette option permet de préciser l'étendue des deux axes. La valeur "auto" signifie que c'est la droite en entier, mais on peut préciser les abscisses extrêmes, par exemple : \opt{limits=\{-4,4\}}.
            \item \opt{gradlimits="auto"}. Cette option permet de préciser l'étendue des graduations sur les deux axes. La valeur "auto" signifie que c'est la droite en entier, mais on peut préciser les graduations extrêmes, par exemple : \opt{gradlimits=\{-2,3\}}.
            \item \opt{unit=""}. Cette option permet de préciser de combien en combien vont les graduations sur l'axe. La valeur par défaut ("") signifie qu'il faut prendre la valeur du pas, SAUF lorsque l'option \opt{labeltext} n'est pas la chaîne vide, dans ce cas \emph{unit} prend la valeur $1$.
            \item \opt{nbsubdiv=0}. Cette option permet de préciser le nombre de subdivisions entre deux graduations principales.
            \item \opt{tickpos=0.5}. Cette option précise la position des graduations par rapport à l'axe, ce sont deux nombres entre $0$ et $1$, la valeur par défaut de $0.5$ signifie qu'ils sont centrés sur l'axe. ($0$ et $1$ représentent les extrémités).
            \item \opt{tickdir="auto"}. Cette option indique la direction des graduations sur l'axe. Cette direction est un vecteur (complexe) non nul. La valeur par défaut "auto" signifie que les graduations sont orthogonales à l'axe.
            \item \opt{xyticks=0.2}. Cette option précise la longueur des graduations.
            \item \opt{xylabelsep=0}. Cette option précise la distance entre les labels et les graduations.
            \item \opt{originpos="center"}. Cette option précise la position du label à l'origine sur l'axe, les valeurs possibles sont : "none", "center", "left", "right" pour $Ox$, et "none", "center", "bottom", "top" pour $Oy$.
            \item \opt{originnum=A.re} pour $Ox$ et \opt{originnum=A.im} pour $Oy$. Cette option précise la valeur de la graduation à l'origine (graduation numéro $0$). 
            
            La formule qui définit le label à la graduation numéro $n$ est : \textbf{(originnum + unit*n)"labeltext"/labelden}.

            \item \opt{legend=""}. Cette option permet de préciser une légende pour l'axe.
            \item \opt{legendpos=0.975}. Cette option précise la position (entre $0$ et $1$) de la légende par rapport à l'axe.
            \item \opt{legendsep=0.2}. Cette option précise la distance entre la légende et l'axe. La légende est de l'autre côté de l'axe par rapport aux graduations.
            \item \opt{legendangle="auto"}. Cette option précise l'angle (en degrés) que doit faire la légende pour l'axe. La valeur "auto" par défaut signifie que la légende doit être parallèle à l'axe si l'option \emph{labelstyle} est aussi à "auto", sinon la légende est horizontale.
            \item \opt{legendstyle="auto"}. Précise le style de label pour la légende, avec la valeur \emph{"auto"} celui-ci est déterminé automatiquement, sinon on peut utiliser les valeurs: "N", "NW", "W", "SW", "S", "SE", "E", "NE".
            \item \opt{labelpos="bottom"} pour $Ox$ et \opt{labelpos="left"} pour $Oy$. Cette option précise la position des labels par rapport à l'axe. Pour l'axe $Ox$, les valeurs possibles sont : "none", "bottom" ou "top", pour l'axe $Oy$ c'est :  "none", "right" ou "left".
            \item \opt{labelden=1}. Cette option précise le dénominateur des labels (entier) pour l'axe. La formule qui définit le label à la graduation numéro $n$ est : \textbf{(originnum + unit*n)"labeltext"/labelden}.
            \item \opt{labeltext=""}. Cette option définit le texte qui sera ajouté au numérateur des labels.
            \item \opt{labelstyle="S"} pour $Ox$ et \opt{labelstyle="W"} pour $Oy$. Cette option définit le style des labels. Les valeurs possibles sont "auto","N", "NW", "W", "SW", "S", "SE", "E".
            \item \opt{labelangle=0}. Cette option définit l'angle des labels en degrés par rapport à l'horizontale.
            \item \opt{labelcolor=""}. Cette option permet de choisir une couleur pour les labels. La chaîne vide représente la couleur courante du texte.
            \item \opt{labelshift=0}. Cette option permet de définir un décalage systématique pour les labels sur l'axe (décalage de long de l'axe).
            \item \opt{nbdeci=2}. Cette option précise le nombre de décimales pour les labels numériques.
            \item \opt{numericFormat=0}. Cette option précise le type d'affiche numérique (non encore implémenté).
            \item \opt{mylabels=""}. Cette option permet d'imposer des labels personnels. Lorsqu'il y en a, la valeur passée à l'option doit être une liste du type : \verb|{pos1,"text1", pos2,"text2",...}|. Le nombre \emph{pos1} représente une abscisse dans le repère (A,xpas) pour $Ox$, ou (A,ypas$*$i) pour $Oy$, ce qui correspond au point d'affixe $A+$pos1$*$xpas pour $Ox$, et $A+$pos1$*$ypas$*i$ pour $Oy$.
        \end{itemize}
\end{itemize}

\subsubsection{Dgradline}

Les méthodes de tracé des axes s'appuient sur la méthode \textbf{g:Dgradline(\{A,u\}, options)}, où \emph{\{A,u\}} représente la droite passant par $A$ (un complexe) et dirigé par le vecteur $u$ (un complexe non nul), le couple (A,u) sert de repère sur cette droite (et oriente cette droite), donc chaque point $M$ de cette droite a une abscisse $x$ telle $M=A+xu$. Cette méthode permet de dessiner cette droite graduée, l'argument \emph{options} est une table précisant les options possibles, qui sont (avec leur valeur par défaut) :
\begin{itemize}
    \item \opt{showaxe=1}. Cette option précise si l'axe doit être tracé ou non ($1$ ou $0$).
    \item \opt{arrows="-"}. Cette option permet d'ajouter ou non une flèche à l'axe (pas de flèche par défaut, mettre "->" pour ajouter une flèche).
    \item \opt{limits="auto"}. Cette option permet de préciser l'étendue des deux axes. La valeur "auto" signifie que c'est la droite en entier, mais on peut préciser les abscisses extrêmes, par exemple : \opt{limits=\{-4,4\}}.
    \item \opt{gradlimits="auto"}. Cette option permet de préciser l'étendue des graduations sur les deux axes. La valeur "auto" signifie que c'est la droite en entier, mais on peut préciser les graduations extrêmes, par exemple : \opt{gradlimits=\{-2,3\}}.
    \item \opt{unit=1}. Cette option permet de préciser de combien en combien vont les graduations sur l'axe.
    \item \opt{nbsubdiv=0}. Cette option permet de préciser le nombre de subdivisions entre deux graduations principales.
    \item \opt{tickpos=0.5}. Cette option précise la position des graduations par rapport à l'axe, ce sont deux nombres entre $0$ et $1$, la valeur par défaut de $0.5$ signifie qu'ils sont centrés sur l'axe. ($0$ et $1$ représentent les extrémités).
    \item \opt{tickdir="auto"}. Cette option indique la direction des graduations sur l'axe. Cette direction est un vecteur (complexe) non nul. La valeur par défaut "auto" signifie que les graduations sont orthogonales à l'axe.
    \item \opt{xyticks=0.2}. Cette option précise la longueur des graduations.
    \item \opt{xylabelsep=defaultxylabelsep}. Cette option précise la distance entre les labels et les graduations, \emph{defaultxylabelsep} est une variable globale valant $0$ par défaut.
    \item \opt{originpos="center"}. Cette option précise la position du label à l'origine sur l'axe, les valeurs possibles sont : "none", "center", "left", "right".
    \item \opt{originnum=0}. Cette option précise la valeur de la graduation à l'origine $A$ (graduation numéro $0$).
    
    La formule qui définit le label à la graduation numéro $n$ (au point $A+nu$) est : \textbf{(originnum + unit*n)"labeltext"/labelden}.

    \item \opt{legend=""}. Cette option permet de préciser une légende pour l'axe.
    \item \opt{legendpos=0.975}. Cette option précise la position (entre $0$ et $1$) de la légende par rapport à l'axe.
    \item \opt{legendsep=defaultlegendsep}. Cette option précise la distance entre la légende et l'axe. La légende est de l'autre côté de l'axe par rapport aux graduations, \emph{defaultlegendsep} est une variable globale qui vaut 0.2 par défaut.
    \item \opt{legendangle="auto"}. Cette option précise l'angle (en degrés) que doit faire la légende pour l'axe. La valeur "auto" par défaut signifie que la légende doit être parallèle à l'axe si l'option \emph{labelstyle} est aussi à "auto", sinon la légende est horizontale.
    \item \opt{legendstyle="auto"}. Précise le style de label pour la légende, avec la valeur \emph{"auto"} celui-ci est déterminé automatiquement, sinon on peut utiliser les valeurs: "N", "NW", "W", "SW", "S", "SE", "E", "NE".
    \item \opt{labelpos="bottom"}. Cette option précise la position des labels par rapport à l'axe, les valeurs possibles sont : "none", "bottom" ou "top". Cette position détermine en même temps celle de la légende : de l'autre côté de l'axe.
    \item \opt{labelden=1}. Cette option précise le dénominateur des labels (entier) pour l'axe. La formule qui définit le label à la graduation numéro $n$ est : \textbf{(originnum + unit*n)"labeltext"/labelden}.
    \item \opt{labeltext=""}. Cette option définit le texte qui sera ajouté au numérateur des labels.
    \item \opt{labelstyle="auto"}. Cette option définit le style des labels. Les valeurs possibles sont "auto","N", "NW", "W", "SW", "S", "SE", "E".
    \item \opt{labelangle=0}. Cette option définit l'angle des labels en degrés par rapport à l'horizontale.
    \item \opt{labelcolor=""}. Cette option permet de choisir une couleur pour les labels. La chaîne vide représente la couleur courante du texte.
    \item \opt{labelshift=0}. Cette option permet de définir un décalage systématique pour les labels sur l'axe (décalage de long de l'axe).
    \item \opt{nbdeci=2}. Cette option précise le nombre de décimales pour les labels numériques.
    \item \opt{numericFormat=0}. Cette option précise le type d'affiche numérique (non encore implémenté).
    \item \opt{mylabels=""}. Cette option permet d'imposer des labels personnels. Lorsqu'il y en a, la valeur passée à l'option doit être une liste du type : \verb|{x1,"text1", x2,"text2",...}|. Les nombres \emph{x1, x2, ...} représentent des abscisses dans le repère $(A,u)$.
\end{itemize}

\begin{demo}{Exemples de droites graduées}
\begin{luadraw}{name=gradline}
local g = graph:new{window={-5,5,-5,5},size={10,10}}
g:Labelsize("footnotesize")
local i = cpx.I
g:Dgradline({3.25*i,1+i/2}, {limits={-4,4}, legend="Axe", legendpos=0.5, arrows="-stealth"})
g:Dgradline({-3,1}, {legend="demo", labeltext="\\pi", labelden=3, unit=2, nbsubdiv=1, arrows="-latex"})
g:Dgradline({3-4*i,-1.25+i/5}, {legend="A", labelstyle="N", gradlimits={-1,5}, nbsubdiv=3, unit=1.411, nbdeci=3, arrows="-Latex"})
g:Show()
\end{luadraw}
\end{demo}

\subsubsection{Dgrid}

La méthode \textbf{g:Dgrid(\{A,B\},options} permet le dessin d'une grille.
\begin{itemize}
    \item Le premier argument est obligatoire, il précise le coin inférieur gauche (c'est le complexe \emph{A}), le coin supérieur droit (c'est le complexe $B$) de la grille.
    \item L'argument \emph{options} est une table précisant les options possibles. Voici ces options avec leur valeur par défaut :
        \begin{itemize}
            \item \opt{unit=\{1,1\}}. Cette option définit les unités sur les axes pour la grille principale.
            \item \opt{gridwidth=4}. Cette option définit l'épaisseur du trait de la grille principale (0.4pt par défaut).
            \item \opt{gridcolor="gray"}. Couleur grille de la grille principale.
            \item \opt{gridstyle="solid"}. Style de trait pour la grille principale.
            \item \opt{nbsubdiv=\{0,0\}}. Nombre de subdivisions (pour chaque axe) entre deux traits de la grille principale. Ces subdivisions déterminent la grille secondaire.
            \item \opt{subgridcolor="lightgray"}. Couleur de la grille secondaire.
            \item \opt{subgridwidth=2}. Épaisseur du trait de la grille secondaire (0.2pt par défaut).
            \item \opt{subgridstyle="solid"}. Style de trait pour la grille secondaire.
            \item \opt{originloc=A}. Localisation de l'origine de la grille.
        \end{itemize}
\end{itemize}

\paragraph{Exemple : } il est possible de travailler dans un repère non orthogonal. Voici un exemple où l'axe $Ox$ est conservé, mais la première bissectrice devient le nouvel axe $Oy$, on modifie pour cela la matrice de transformation du graphe. À partir de cette modification les affixes représentent les coordonnées dans le nouveau repère.
\begin{demo}{Exemple de repère non orthogonal}
\begin{luadraw}{name=axes_non_ortho}
local g = graph:new{window={-5.25,5.25,-4,4},size={10,10}}
local i, pi = cpx.I, math.pi
local f = function(x) return 2*math.sin(x) end
g:Setmatrix({0,1,1+i}); g:Labelsize("small")
g:Dgrid({-5-4*i,5+4*i},{gridstyle="dashed"})
g:Daxes({0,1,1}, {arrows="-Stealth"})
g:Lineoptions("solid","ForestGreen",12); g:Dcartesian(f,{x={-5,5}})
g:Dcircle(0,3,"Crimson")
g:DlineEq(1,0,3,"Navy") -- droite d'équation x=-3
g:Lineoptions("solid","black",8); g:DtangentC(f,pi/2,1.5,"<->")
g:Dpolyline({pi/2,pi/2+2*i,2*i},"dotted")
g:Ddots(Z(pi/2,2))
g:Dlabeldot("$\\frac{\\pi}2$",pi/2,{pos="SW"})
g:Show()
\end{luadraw}
\end{demo}

\subsubsection{Dgradbox}

La méthode \textbf{g:Dgradbox(\{A,B,xpas,ypas\},options} permet le dessin d'une boîte graduée.
\begin{itemize}
    \item Le premier argument est obligatoire, il précise le coin inférieur gauche (c'est le complexe \emph{A}) et le coin supérieur droit (c'est le complexe $B$) de la boîte, ainsi que le pas sur chaque axe.
    \item L'argument \emph{options} est une table précisant les options possibles. Ce sont les mêmes que pour les axes, mises à part certaines valeurs par défaut. À celles-ci s'ajoute l'option suivante : \opt{title=""} qui permet d'ajouter un titre en haut de la boite, attention cependant à laisser suffisamment de place pour cela.
\end{itemize}

\begin{demo}{Utilisation de Dgradbox}
\begin{luadraw}{name=gradbox}
local g = graph:new{window={-5,4,-5.5,5},size={10,10}}
local i, pi = cpx.I, math.pi
local h = function(x) return x^2/2-2 end
local f = function(x) return math.sin(3*x)+h(x) end
g:Dgradbox({-pi-4*i,pi+4*i,pi/3,1},{grid=true,originloc=0, originnum={0,0},labeltext={"\\pi",""},labelden={3,1}, title="\\textbf{Title}",legend={"Legend $x$","Legend $y$"}})
g:Saveattr(); g:Viewport(-pi,pi,-4,4) -- on limite la vue (clip)
g:Filloptions("full","blue",0.6); g:Linestyle("noline"); g:Ddomain2(f,h,{x={-pi/2,2*pi/3}})
g:Filloptions("none",nil,1); g:Lineoptions("solid",nil,8); g:Dcartesian(h,{x={-pi,pi}, draw_options="DarkBlue"})
g:Dcartesian(f,{x={-pi,pi},draw_options="Crimson"})
g:Restoreattr()
g:Show()
\end{luadraw}
\end{demo}

\subsection{Dessins d'ensembles (diagrammes de Venn)}

\subsubsection{Dessiner un ensemble}

La fonction \textbf{set(center,angle,scale)} renvoie un chemin représentant un ensemble (en forme d'oeuf), donc le centre est \emph{center} (complexe), l'argumen \emph{angle} représente l'inclinaison (en degrés) de l'axe vertical de l'ensemble (0 par défaut), et l'argument \emph{scale} est un facteur d'échelle permettant de modifier la taille de l'ensemble (1 par défaut). Un tel chemin peut être dessiné avec la méthode \textbf{g:Dpath()}.

\begin{demo}{Dessiner un ensemble}
\begin{luadraw}{name=set}
local g = graph:new{window={-5.25,5.25,-5,5},size={10,10}}
local i = cpx.I
local A, B, C = set(i,0), set(-2-i,25), set(2-i,-25)
g:Fillopacity(0.3)
g:Dpath(A,"fill=orange"); g:Dpath(B,"fill=blue")
g:Dpath(C,"fill=green")
g:Fillopacity(1)
g:Dlabel("$A$",5*i,{pos="N"},"$B$",-4+3*i,{pos="W"},"$C$",4+3*i,{pos="E"})
g:Show()
\end{luadraw}
\end{demo}

\subsubsection{Opérations sur les ensembles}

Notons $C_1$ et $C_2$ deux listes de complexes représentant le contour de deux ensembles (courbes fermées simples, d'un seul tenant).
Les opérations possibles sont au nombre de trois :
\begin{itemize}
    \item La fonction \textbf{cap(C1,C2)} renvoie une liste de complexes représentant le contour de l'intersection des ensembles correspondant à $C_1$ et $C_2$.
    \item La fonction \textbf{cup(C1,C2)} renvoie une liste de complexes représentant le contour de la réunion des ensembles correspondant à $C_1$ et $C_2$.
        \item La fonction \textbf{setminus(C1,C2)} renvoie une liste de complexes représentant le contour de la différence des ensembles correspondant à $C_1$ et $C_2$ ($C_1\setminus C_2$).    
\end{itemize}
Le résultat de ces opérations, étant une liste de complexes, peut être dessiné avec la méthode \textbf{g:Dpolyline()}.

\begin{demo}{Opérations sur les ensembles}
\begin{luadraw}{name=cap_and_cup}
local g = graph:new{window={-5.5,5.5,-5,5},size={10,10}}
local i = cpx.I
local A, B, C = set(i,0), set(-2-i,25), set(2-i,-25)
g:Fillopacity(0.3)
g:Dpath(A,"fill=orange"); g:Dpath(B,"fill=blue"); g:Dpath(C,"fill=green")
g:Fillopacity(1)
local C1, C2, C3 = path(A), path(B), path(C) -- conversion chemin -> liste de complexes
local I = cap(cup(C1,C2),C3)
g:Linecolor("red"); g:Filloptions("full","white")
g:Dpolyline(I,true,"line width=0.8pt,fill opacity=0.8")
g:Dlabel("$A$",5*i,{pos="N"},"$B$",-4+3*i,{pos="W"},"$C$",4+3*i,{pos="E"},
"$(A\\cup B) \\cap C$",-i,{pos="NE",node_options="red,draw"})
g:Show()
\end{luadraw}
\end{demo}

\paragraph{NB} : le résultat n'est pas toujours satisfaisant lorsque les contours deviennent trop complexes, ou lorsque les contours ont des tronçons en commun.


\subsection{Importer une image}

\subsubsection{Placer une image dans le graphique}

Pour importer une image dans le graphique en cours (et éventuellement dessiner par dessus), il y a la méthode :\par 
\hfil\textbf{g:Dimage(filename, anchor, options)},\hfil\par
où:
\begin{itemize}
    \item \emph{filename} est le nom complet du fichier image, celle-ci sera affichée par la commande \verb|\includegraphics[]{}| dans un node,
    \item \emph{anchor} est un nombre complexe représentant le point d'ancrage de l'image dans le graphique,
    \item \emph{options} est une table dont les champs définissent les paramètres d'affichage, qui sont (avec leur valeur par défaut):
    \begin{itemize}
        \item \opt{pos = "center"} qui indique la position de l'image par rapport au point d'ancrage, sur le même principe que pour les labels. Les valeurs possibles sont: "center", "N", "NE", "E", "SE", "S", "SW", "W", "NW".
        \item \opt{name = ""} qui permet éventuellement de donner un nom au node qui va être créé (nom qui pourra être utilisé par tikz ensuite),
        \item \opt{graphics\_options = ""} qui est une chaîne contenant des options pour la commande \verb|\includegraphics|,
        \item \opt{matrix = nil} qui est une table représentant une matrice de transformation affine, celle-ci sera appliquée localement au node créé (pour le node, l'origine est le point d'ancrage). Il est à noter que la matrice 2d de transformation globale du graphique en cours est également prise en compte par cette méthode.
    \end{itemize}
\end{itemize}

\begin{demo}{Importer une image}
\begin{luadraw}{name=Dimage}
local g = graph:new{margin={0,0,0,0}, size={10,10},bg="green!30"}
local filename = cachedir.."flower.jpg"
local g_options = "width=4.5cm,height=4.5cm"
g:Dimage(filename,Z(-5,5),{pos="SE", graphics_options=g_options})
g:Dimage(filename,Z(5,5),{pos="SE", matrix={0,-1,cpx.I}, graphics_options=g_options})
g:Rotate(180)
g:Dimage(filename,Z(-5,5),{pos="SE", graphics_options=g_options})
g:IDmatrix()
g:Dimage(filename,Z(-5,-5),{pos="SE", matrix={0,1,-cpx.I}, graphics_options=g_options})
g:Dlabel( "Original", Z(-5,5),{pos="SE"},
    "Vertical symetry", Z(5,5), {pos="SW"},
    "Rotation (global)", Z(5,-5), {pos="NW"},
    "Horizontal symetry", Z(-5,-5), {pos="NE"} )
g:Show()
\end{luadraw}
\end{demo}

\subsubsection{Mapper une image sur un parallélogramm}

Ceci est possible avec la méthode : \textbf{g:Dmapimage( filename, parallelo, options} ), où :
\begin{itemize}
    \item  \emph{filename} est le nom complet du fichier image, 
    \item \emph{parallelo} est une liste de la forme \emph{\{a,u,v\}} constituée de trois nombres complexes, cette liste représente le parallélogramme de sommets \{a, a+u, a+u+v, a+v\}.
    \item \emph{options} est une table dont les champs définissent les paramètres, qui sont (avec leur valeur par défaut):
    \begin{itemize}
        \item \opt{name = ""} qui permet éventuellement de donner un nom au node qui va être créé (nom qui pourra être utilisé par tikz ensuite).
        \item \opt{clip = false} qui est un booléen indiquant si l'image doit être clippée avec le parallélogramme, mais normalement cela n'est pas nécessaire.
        \item \opt{border\_options = nil}, lorsque cette option n'est pas égale à \emph{nil}, ce doit être une chaîne de caractères contenant les options de dessin le contour du parallélogramme, \emph{border\_options} sera alors transmise directement à l'instruction \verb|\draw| pour dessiner le contour.
    \end{itemize}    
\end{itemize}

\begin{demo}{Mapper une image}
\begin{luadraw}{name=Dmapimage}
local g = graph:new{window={-2,3.5,-0.5,7}, margin={0,0,0,0}, size={10,10},bg="green!30"}
local filename = cachedir.."flower.jpg"
local i = cpx.I
local a, u, v, w = 0, 3, -1.5+i, 4*i
local facets = {{a,u,w}, {a+v,-v,w}, {a+v+w,-v,u} }
local portrait = {a+w+(2*v+u)/3+0.2, (u-v)/4, 1.5*i+0.2}
for _,f in ipairs(facets) do
    g:Dmapimage(filename,f,{border_options="Navy"})
end
g:Dmapimage(cachedir.."russell.jpg", portrait, {border_options="lightgray,line width=1.5mm"})
g:Show()
\end{luadraw}
\end{demo}


\subsection{Les couleurs}

Dans l'environnement \emph{luadraw} les couleurs sont des chaînes de caractères qui doivent correspondre à des couleurs connues de tikz. Le package \emph{xcolor} est fortement conseillé pour ne pas être limité aux couleurs de bases.

\subsubsection{Calculs sur les couleurs}

Afin de pouvoir faire des manipulations sur les couleurs, celles-ci ont été définies (dans le module \emph{luadraw\_colors.lua}) sous la forme de tables de trois composantes : rouge, vert, bleu, chaque composante étant un nombre entre $0$ et $1$, et avec leur nom au format \emph{svgnames} du package \emph{xcolor}, par exemple on y trouve (entre autres) les déclarations :
\begin{Luacode}
AliceBlue = {0.9412, 0.9725, 1}
AntiqueWhite = {0.9804, 0.9216, 0.8431}
Aqua = {0.0, 1.0, 1.0}
Aquamarine = {0.498, 1.0, 0.8314}
\end{Luacode}
On pourra se référer à la documentation de \emph{xcolor} pour avoir la liste de ces couleurs.

Pour utiliser celles-ci dans l'environnement \emph{luadraw}, on peut :
\begin{itemize}
    \item soit les utiliser avec leur nom si on a déclaré dans le préambule : \verb|\usepackage[svgnames]{xcolor}|, par exemple : \mintinline{Lua}{g:Linecolor("AliceBlue")},
    \item soit les utiliser avec la fonction \textbf{rgb()} de \emph{luadraw}, par exemple : \mintinline{Lua}{g:Linecolor(rgb(AliceBlue))}. Par contre, avec cette fonction \emph{rgb()}, pour changer localement de couleur il faut faire comme ceci (exemple) : \par
    \mintinline{Lua}{g:Dpolyline(L,"color="..rgb(AliceBlue))}, ou \mintinline{Lua}{g:Dpolyline(L,"fill="..rgb(AliceBlue))}. Car la fonction \emph{rgb()} ne renvoie pas un nom de couleur, mais une définition de couleur.
\end{itemize}

\paragraph{Fonctions pour la gestion des couleurs :}
\begin{itemize}
    \item La fonction \textbf{rgb(r,g,b)} ou \textbf{rgb(\{r,g,b\})}, renvoie la couleur sous forme d'une chaîne de caractères compréhensible par tikz dans les options \verb|color=...| et \verb|fill=...|. Les valeurs de $r$, $g$ et $b$ doivent être entre $0$ et $1$.
    
    \item La fonction \textbf{hsb(h,s,b,table)} renvoie la couleur sous forme d'une chaîne de caractères compréhensible par tikz. L'argument $h$ (hue) doit être un nombre enter $0$ et $360$, l'argument $s$ (saturation) doit être entre $0$ et $1$, et l'argument $b$ (brightness) doit être aussi entre $0$ et $1$.
    L'argument (facultatif) \emph{table} est un booléen (false par défaut) qui indique si le résultat doit être renvoyé sous forme de table \verb|{r,g,b}| ou non (par défaut c'est sous forme d'une chaîne).
    
    \item La fonction \textbf{mixcolor(color1,proportion1 color2,proportion1,...,colorN,proportionN)} mélange les couleurs \emph{color1}, ...,\emph{colorN} dans les proportions demandées et renvoie la couleur qui en résulte sous forme d'une chaîne de caractères compréhensible par tikz, suivie de cette même couleur sous forme de table \verb|{r,g,b}| . Chacune des couleurs doit être une table de trois composantes \verb|{r,g,b}|.
    
    \item La fonction \textbf{palette(colors,pos,table)} : l'argument \emph{colors} est une liste (table) de couleurs au format \verb|{r,b,g}|, l'argument \emph{pos} est un nombre entre $0$ et $1$, la valeur $0$ correspond à la première couleur de la liste et la valeur $1$ à la dernière. La fonction calcule et renvoie la couleur correspondant à la position \emph{pos} dans la liste par interpolation linéaire. L'argument (facultatif) \emph{table} est un booléen (false par défaut) qui indique si le résultat doit être renvoyé sous forme de table \verb|{r,g,b}| ou non (par défaut c'est sous forme d'une chaîne).
    
    \item La fonction \textbf{getpalette(colors,nb,table)} : l'argument \emph{colors} est une liste (table) de couleurs au format \verb|{r,b,g}|, l'argument \emph{nb} indique le nombre de couleurs souhaité. La fonction renvoie une liste de \emph{nb} couleurs régulièrement réparties dans \emph{colors}. L'argument (facultatif) \emph{table} est un booléen (false par défaut) qui indique si les couleurs sont renvoyées sous forme de tables \verb|{r,g,b}| ou non (par défaut c'est sous forme de chaînes).  
    
    \item La méthode \textbf{g:Newcolor(name,color)} permet de définir dans l'export tikz au format rgb une nouvelle couleur dont le nom sera \emph{name} (chaîne), l'argument \emph{color} peut être soit une table de trois composantes : rouge, vert, bleu (entre 0 et 1) définissant cette couleur, soit une chaîne de caractères représentant une couleur. Dans le premier cas la méthode utilise un \verb|\definecolor| et dans le second cas elle utilise un \verb|\colorlet|.
    
\end{itemize}
On peut également utiliser toutes les possibilités habituelles de tikz pour la gestion des couleurs.

Par défaut, il y a cinq palettes de couleurs\footnote{Une palette est une table de couleurs, celles-ci sont elle-mêmes des tables de nombres entre $0$ et $1$ représentant les composantes rouge, vert, bleu.}.

\begin{demo}{Les cinq palettes par défaut}
\begin{luadraw}{name=palettes}
local g = graph:new{window={-5,5,-5,5},bbox=false, border=true}
g:Linewidth(1)
local Dpalette = function(pal,A,h,L,N,name)
    local dl = L/N
    for k = 1, N do
        local color = palette(pal,(k-1)/(N-1))
        g:Drectangle(A,A+h,A+h+dl,"color="..color..",fill="..color)
        A = A+dl
    end
    g:Drectangle(A,A+h,A+h-L); g:Dlabel(name,A+h/2,{pos="E"})
end
local A, h, dh, L, N = Z(-5,4), Z(0,-1), Z(0,-1.1), 5, 100
Dpalette(rainbow,A,h,L,N,"rainbow"); A = A+dh
Dpalette(palAutumn,A,h,L,N,"palAutumn"); A = A+dh
Dpalette(palGistGray,A,h,L,N,"palGistGray"); A = A+dh
Dpalette(palGasFlame,A,h,L,N,"palGasFlame"); A = A+dh
Dpalette(palRainbow,A,h,L,N,"palRainbow")
g:Show()
\end{luadraw}
\end{demo}
