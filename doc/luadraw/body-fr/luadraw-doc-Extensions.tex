\section{Extensions}

\subsection{Le module \emph{luadraw\_polyhedrons}}

Ce module est encore à l'état d'ébauche et est appelé à s'étoffer par la suite. Comme son nom l'indique, il contient la définition de polyèdres. Toutes les données numériques sont issues du site \href{https://dmccooey.com/polyhedra/}{Visual Polyhedra}.

Toutes les fonctions sont sur le même modèle : \textbf{<nom>(C,S,all)} où $C$ est le centre du polyèdre (point 3d) et $S$ un sommet du polyèdre (point 3d), lorsque $C$ ou $S$ ont la valeur \emph{nil}, c'est le polyèdre non transformé (de centre l'origine) qui est renvoyé . L'argument facultatif \emph{all} est un booléen, lorsqu'il a la valeur \emph{true} la fonction renvoie quatre choses : \emph{P, V, E, F} où :
    \begin{itemize}
        \item $P$ est le solide en tant que polyèdre,
        \item $V$ la liste (table) des sommets,
        \item $E$ la liste (table) des arêtes (avec points 3d),
        \item $F$ la liste des facettes (avec points 3d). Certains polyèdres ont plusieurs types de facettes, dans ce cas la résultat renvoyé est de la forme : \emph{P, V, E, F1, F2, ...}, où $F1$, $F2$ ..., sont des listes de facettes.Cela peut permettre de les dessiner avec des couleurs différentes par exemple.
        \end{itemize}
L'argument \emph{all} la valeur \emph{false},qui est la valeur par défaut, la fonction ne renvoie que le polyèdre.

Voici les solides actuellement contenus dans ce module :

\begin{itemize}
    \item Les solides de Platon, ces solides n'ont qu'un type des faces :
        \begin{itemize}
            \item  la fonction \textbf{tetrahedron(C,S,all)} permet la construction d'un tétraèdre régulier de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d).
            \item La fonction \textbf{octahedron(C,S,all)} permet la construction d'un octaèdre de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d).
            \item La fonction \textbf{cube(C,S,all)} permet la construction d'un cube de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d).
            \item La fonction \textbf{icosahedron(C,S,all)} permet la construction d'un icosaèdre de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d).
            \item La fonction \textbf{dodecahedron(C,S,all)} permet la construction d'un dodécaèdre de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d).
        \end{itemize}

    \item Les solides d'Archimède :
        \begin{itemize}
            \item La fonction \textbf{cuboctahedron(C,S,all)} permet la construction d'un cuboctaèdre de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux types de faces.
            \item La fonction \textbf{icosidodecahedron(C,S,all)} permet la construction d'un icosidodécaèdre de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux types de faces.
            \item La fonction \textbf{lsnubcube(C,S,all)} permet la construction d'un cube adouci (forme 1) de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux types de faces.
            \item La fonction \textbf{lsnubdodecahedron(C,S,all)} permet la construction d'un dodécaèdre adouci (forme 1) de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux types de faces.
            \item La fonction \textbf{rhombicosidodecahedron(C,S,all)} permet la construction d'un rhombicosidodécaèdre de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a trois types de faces.
            \item La fonction \textbf{rhombicuboctahedron(C,S,all)} permet la construction d'un rhombicuboctaèdre de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux types de faces.
            \item La fonction \textbf{rsnubcube(C,S,all)} permet la construction d'un cube adouci (forme 2) de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux types de faces.
            \item La fonction \textbf{rsnubdodecahedron(C,S,all)} permet la construction d'un dodécaèdre adouci (forme 2) de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux types de faces.
            \item La fonction \textbf{truncatedcube(C,S,all)} permet la construction d'un cube tronqué de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux types de faces.
            \item La fonction \textbf{truncatedcuboctahedron(C,S,all)} permet la construction d'un cuboctaèdre tronqué de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a trois types de faces.
            \item La fonction \textbf{truncateddodecahedron(C,S,all)} permet la construction d'un dodécaèdre tronqué de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux types de faces.
            \item La fonction \textbf{truncatedicosahedron(C,S,all)} permet la construction d'un icosaèdre tronqué de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux types de faces.
             \item La fonction \textbf{truncatedicosidodecahedron(C,S,all)} permet la construction d'un icosidodécaèdre tronqué de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux trois de faces.
            \item La fonction \textbf{truncatedoctahedron(C,S,all)} permet la construction d'un octaèdre tronqué de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux types de faces.             
            \item La fonction \textbf{truncatedtetrahedron(C,S,all)} permet la construction d'un tétraèdre tronqué de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux types de faces.
        \end{itemize}

    \item Autres solides :
    \begin{itemize}
        \item La fonction \textbf{octahemioctahedron(C,S,all)} permet la construction d'un octahémioctaèdre de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux types de faces.
        \item La fonction \textbf{small\_stellated\_dodecahedron(C,S,all)} permet la construction d'un petit dodécaèdre étoilé de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a un seul type de faces.
    \end{itemize}
\end{itemize}

\begin{demo}{Polyèdres du module \emph{luadraw\_polyhedrons}}
\begin{luadraw}{name=polyhedrons}
local i = cpx.I
require 'luadraw_polyhedrons' -- chargement du module
local g = graph3d:new{bg="LightGray", size={10,10}}
g:Labelsize("small"); Hiddenlines = false
-- en haut à gauche 
g:Saveattr(); g:Viewport(-5,0,0,5); g:Coordsystem(-5,5,-5,5,true)
local T,S,A,F = icosahedron(Origin,M(0,2,4.5),true) 
g:Dscene3d(
    g:addFacet(F, {color="Crimson",opacity=0.8}),
    g:addPolyline(A, {color="Pink", width=8}),
    g:addDots(S) )
g:Dlabel("Icosaèdre",5*i,{})
g:Restoreattr()
-- en haut à droite
g:Saveattr()
g:Viewport(0,5,0,5); g:Coordsystem(-5,5,-5,5,true)
local T,S,A,F1,F2 = truncatedtetrahedron(Origin,M(0,0,5),true) -- sortie complète, affichage dans une scène 3d
g:Dscene3d(
    g:addFacet(F1, {color="Crimson",opacity=0.8}),
    g:addFacet(F2, {color="Gold"}),
    g:addPolyline(A, {color="Pink", width=8}),
    g:addDots(S) )
g:Dlabel("Tétraèdre tronqué",5*i,{})
g:Restoreattr()
-- en bas à gauche
g:Saveattr(); g:Viewport(-5,0,-5,0); g:Coordsystem(-5,5,-5,5,true)
local T,S,A,F1,F2,F3 = rhombicosidodecahedron(Origin,M(0,0,4.5),true)
g:Dscene3d(
    g:addFacet(F1, {color="Crimson",opacity=0.8}),
    g:addFacet(F2, {color="Gold",opacity=0.8}), g:addFacet(F3, {color="ForestGreen"}),
    g:addPolyline(A, {color="Pink", width=8}), g:addDots(S) )
g:Dlabel("Rhombicosidodécaèdre",-5*i,{})
g:Restoreattr()
-- en bas à droite
g:Saveattr(); g:Viewport(0,5,-5,0); g:Coordsystem(-5,5,-5,5,true)
local T,S,A,F1 = small_stellated_dodecahedron(Origin,M(0,0,5),true)
g:Dscene3d(
    g:addFacet(F1, {color="Crimson",opacity=0.8}),
    g:addPolyline(A, {color="Pink", width=8}),
    g:addDots(S) )
g:Dlabel("Petit dodécaèdre étoilé",-5*i,{})
g:Restoreattr()
g:Show()
\end{luadraw}

\end{demo}

\subsection{Le module \emph{luadraw\_spherical}}

Ce module permet de dessiner un certain nombre d'objets sur une sphère (comme par exemple des cercles, des triangles sphériques,...) sans avoir à gérer à la main les parties visibles ou non visibles. Le dessin se fait en trois temps:
\begin{enumerate}
    \item On définit les caractéristiques de la sphère (centre, rayon, couleur,...)
    \item On définit les objets à ajouter dans la scène, grâce à des méthodes dédiées.
    \item On affiche le tout avec la méthode \textbf{g:Dspherical()}.
\end{enumerate}
Bien sûr, toutes les méthodes de dessin 2d et 3d restent utilisables.

\subsubsection{Variables et fonctions globales du module}

\begin{itemize}
    \item Variables avec leur valeur par défaut:
        \begin{itemize}
            \item \textbf{Insidelabelcolor} = "DarkGray": définit la couleur des labels dont le point d'ancrage est intérieur à la sphère.
            \item \textbf{arrowBstyle} = "->" : type de flèche en fin de ligne
            \item \textbf{arrowAstyle} = "<-" : type de flèche en début de ligne
            \item \textbf{arrowABstyle} = "<->": très peu utilisée car la plupart du temps les lignes tracées sur la sphère doivent être découpées.
        \end{itemize}
    \item Fonctions :
        \begin{itemize}
            \item \textbf{sM(x,y,z)}: renvoie un point de la sphère, c'est le point $I$ de la sphère tel que la demi-droite $[O,I)$ ($O$ étant le centre de la sphère) passe par le point $A$ de coordonnées cartésiennes $(x,y,z)$. C'est le projeté du point $(Mx,y,z)$ sur la sphère partant du centre.
            \item \textbf{sM(theta,phi)}: où \emph{theta} et \emph{phi} sont des angles en degrés, renvoie un point de la sphère donc les coordonnées sphériques sont \emph{(R,theta,phi)} où $R$ est le rayon de la sphère.
            \item \textbf{toSphere(A)}: renvoie le projeté du point $A$ sur la sphère partant du centre.
            \item \textbf{clear\_spherical()}: supprime les objets qui ont été ajoutés à la scène, et remet les valeurs par défaut.
        \end{itemize}
\end{itemize}

Si la variable globale \textbf{Hiddenlines} a la valeur \emph{true}, alors les parties cachées seront dessinées dans le style défini par la variable globale \textbf{Hiddenlinestyle}, cependant on peut modifier ce comportement l'option locale \emph{hidden=true/false} .

\subsubsection{Définition de la sphère}
Par défaut, la sphère est centrée à l'origine, de rayon $3$ et de couleur orange, mais ceci peut être modifié avec la méthode \textbf{g:Define\_sphere( options )} où \emph{options} est une table permettant d'ajuster chaque paramètre. Ceux-ci sont les suivants (avec leur valeur par défaut entre parenthèses):
\begin{itemize}
    \item \opt{center =} (Origin),
    \item \opt{radius =} (3),
    \item \opt{color =} ("Orange"),
    \item \opt{opacity =} (1),
    \item \opt{mode =} (\emph{mBorder}), mode d'affichage de la sphère (\emph{mWireframe} ou \emph{mGrid} ou \emph{mBorder}, voir \textbf{Dsphere}),
    \item \opt{edgecolor =} ("LightGray"),
    \item \opt{edgestyle =} ("solid"),
    \item \opt{hiddenstyle =} (Hiddenlinestyle),
    \item \opt{hiddencolor =} ("gray"),
    \item \opt{edgewidth =} (4),
    \item \opt{show =} (true), pour montrer ou non la sphère.
\end{itemize}

\subsubsection{Ajouter un cercle : g:DScircle}

La méthode \textbf{g:DScircle(P,options)} permet d'ajouter un cercle sur la sphère, l'argument \emph{P} est une table de la forme $\{A,n\}$ qui représente un plan (passant par $A$ et normal à $n$, deux points 3d). Le cercle est alors défini comme l'intersection de ce plan avec la sphère. L'argument \emph{options} est une table à 5 champs, qui sont :
    \begin{itemize}
        \item \opt{style =} (style courant de ligne), 
        \item \opt{color =} (couleur courante des lignes),
        \item \opt{width =} (épaisseur courante des lignes en dixième de point),
        \item \opt{opacity =} (opacité courante des lignes),
        \item \opt{hidden =} (valeur de \emph{Hiddenlines}),
        \item \opt{out =} (nil), si on affecte une variable de type liste à ce paramètre \emph{out}, alors la fonction ajoute à cette liste les deux points correspondant aux extrémités de l'arc caché, s'il y en a un, ce qi permet de les récupérer sans avoir à les calculer.
    \end{itemize}
    
\subsubsection{Ajouter un grand cercle : g:DSbigcircle}

La méthode \textbf{g:DSbigcircle(AB,options)} permet d'ajouter un grand cercle sur la sphère, l'argument \emph{AB} est une table de la forme $\{A,B\}$ où $A$ et $B$ sont deux points distincts de la sphère. Le grand cercle est alors le cercle de centre le centre de la sphère, et passant par $A$ et $B$. L'argument \emph{options} est une table à 5 champs, qui sont :
    \begin{itemize}
        \item \opt{style =} (style courant de ligne), 
        \item \opt{color =} (couleur courante des lignes),
        \item \opt{width =} (épaisseur courante des lignes en dixième de point),
        \item \opt{opacity =} (opacité courante des lignes),
        \item \opt{hidden =} (valeur de \emph{Hiddenlines}),
        \item \opt{out =} (nil), si on affecte une variable de type table à ce paramètre \emph{out}, alors la fonction ajoute à cette liste les deux points correspondant aux extrémités de l'arc caché, s'il y en a un, ce qi permet de les récupérer sans avoir à les calculer.
    \end{itemize}

\subsubsection{Ajouter un arc de grand cercle : g:DSarc}

La méthode \textbf{g:DSarc(AB,sens,options)} permet d'ajouter un arc de grand cercle sur la sphère, l'argument \emph{AB} est une table de la forme $\{A,B\}$ où $A$ et $B$ sont deux points distincts de la sphère, on trace alors l'arc de grand cercle allant de $A$ vers $B$. L'argument \emph{sens} vaut 1 ou -1 pour indiquer le sens de l'arc. Lorsque $A$ et $B$ ne sont pas diamétralement opposés, le plan $OAB$ (où $O$ est le centre de la sphère) est orienté avec $\vec{OA}\wedge\vec{OB}$.  L'argument \emph{options} est une table à 6 champs, qui sont :
    \begin{itemize}
        \item \opt{style =} (style courant de ligne), 
        \item \opt{color =} (couleur courante des lignes),
        \item \opt{width =} (épaisseur courante des lignes en dixième de point),
        \item \opt{opacity =} (opacité courante des lignes),
        \item \opt{hidden =} (valeur de \emph{Hiddenlines}),
        \item \opt{arrows =} (0), trois valeurs possibles : 0 (pas de flèche), 1 (une flèche en $B$), 2 (flèche en $A$ et en $B$).
        \item \opt{normal =} (nil), permet de préciser un vecteur normal au plan $OAB$ lorsque ces trois points sont alignés.
    \end{itemize}

\subsubsection{Ajouter un angle : g:DSangle}

La méthode \textbf{g:DSangle(B,A,C,r,sens,options)} où $A$, $B$ et $C$ sont trois points de la sphère, permet de dessiner un arc de grand cercle sur la sphère pour représenter l'angle $(\vec{AB},\vec{AC})$ avec un rayon de \emph{r}. L'argument \emph{sens} vaut 1 ou -1 pour indiquer le sens de l'arc, le plan $ABC$ est orienté avec $\vec{AB}\wedge\vec{AC}$.  L'argument \emph{options} est une table à 6 champs, qui sont :
    \begin{itemize}
        \item \opt{style =} (style courant de ligne), 
        \item \opt{color =} (couleur courante des lignes),
        \item \opt{width =} (épaisseur courante des lignes en dixième de point),
        \item \opt{opacity =} (opacité courante des lignes),
        \item \opt{hidden =} (valeur de \emph{Hiddenlines}),
        \item \opt{arrows =} (0), trois valeurs possibles : 0 (pas de flèche), 1 (une flèche en $B$), 2 (flèche en $A$ et en $B$).
        \item \opt{normal =} (nil), permet de préciser un vecteur normal au plan $ABC$ lorsque ces trois points sont "alignés" sur un même grand cercle.
    \end{itemize}
    
\subsubsection{Ajouter une facette sphérique : g:DSfacet}

La méthode \textbf{g:DSfacet(F,options)} où \emph{F} est une liste de points de la sphère, permet de dessiner la facette représentée par $F$, les arêtes étant des arcs de grands cercles. L'argument \emph{options} est une table à 6 champs, qui sont :
    \begin{itemize}
        \item \opt{style =} (style courant de ligne), 
        \item \opt{color =} (couleur courante des lignes),
        \item \opt{width =} (épaisseur courante des lignes en dixième de point),
        \item \opt{opacity =} (opacité courante des lignes),
        \item \opt{hidden =} (valeur de \emph{Hiddenlines}),
        \item \opt{fill =} (""), chaîne représentant la couleur de remplissage (aucune par défaut),
        \item \opt{fillopacity =} (0.3), opacité de la couleur de remplissage.
    \end{itemize}
    
\subsubsection{Ajouter une courbe sphérique : g:DScurve}

La méthode \textbf{g:DScurve(L,options)} où \emph{L} est une liste de points de la sphère, permet de dessiner la courbe représentée par $L$. L'argument \emph{options} est une table à 6 champs, qui sont :
    \begin{itemize}
        \item \opt{style =} (style courant de ligne), 
        \item \opt{color =} (couleur courante des lignes),
        \item \opt{width =} (épaisseur courante des lignes en dixième de point),
        \item \opt{opacity =} (opacité courante des lignes),
        \item \opt{hidden =} (valeur de \emph{Hiddenlines}),
        \item \opt{out =} (nil), si on affecte une variable de type table à ce paramètre \emph{out}, alors la fonction ajoute à cette liste les points correspondant aux extrémités des parties cachées.
    \end{itemize}
    
Nous allons maintenant traiter d'objets qui ne sont pas forcément sur la sphère, mais qui peuvent la traverser, ou être à l'intérieur, ou à l'extérieur.

\subsubsection{ Ajouter un segment : g:DSseg}

La méthode \textbf{g:DSseg(AB,options)} permet d'ajouter un segment, l'argument \emph{AB} est une table de la forme $\{A,B\}$ où $A$ et $B$ sont deux points de l'espace. La fonction traite les interactions avec la sphère. L'argument \emph{options} est une table à 5 champs, qui sont :
    \begin{itemize}
        \item \opt{style =} (style courant de ligne), 
        \item \opt{color =} (couleur courante des lignes),
        \item \opt{width =} (épaisseur courante des lignes en dixième de point),
        \item \opt{opacity =} (opacité courante des lignes),
        \item \opt{hidden =} (valeur de \emph{Hiddenlines}),
        \item \opt{arrows =} (0), trois valeurs possibles : 0 (pas de flèche), 1 (une flèche en $B$), 2 (flèche en $A$ et en $B$).
    \end{itemize}
    
\subsubsection{Ajouter une droite : g:DSline}

La méthode \textbf{g:DSline(d,options)} permet d'ajouter une droite, l'argument \emph{d} est une table de la forme $\{A,u\}$ où $A$ et un point de la droite et $u$ un vecteur directeur (deux points 3d). La fonction traite les interactions avec la sphère.  Le segment tracé est obtenu en intersectant la droite avec la fenêtre 3d, il peut être vide si la fenêtre est trop étroite. L'argument \emph{options} est une table à 6 champs, qui sont :
    \begin{itemize}
        \item \opt{style =} (style courant de ligne), 
        \item \opt{color =} (couleur courante des lignes),
        \item \opt{width =} (épaisseur courante des lignes en dixième de point),
        \item \opt{opacity =} (opacité courante des lignes),
        \item \opt{hidden =} (valeur de \emph{Hiddenlines}),
        \item \opt{arrows =} (0), trois valeurs possibles : 0 (pas de flèche), 1 (une flèche en $B$), 2 (flèche en $A$ et en $B$),
        \item \opt{scale =} (1), permet de modifier la taille du segment tracé.
    \end{itemize}
    
\subsubsection{ Ajouter une ligne polygonale : g:DSpolyline}

La méthode \textbf{g:DSpolyline(L,options)} permet d'ajouter une ligne polygonale, l'argument \emph{L} est une liste de points de l'espace, ou une liste de listes de points de l'espace. La fonction traite les interactions avec la sphère. L'argument \emph{options} est une table à 6 champs, qui sont :
    \begin{itemize}
        \item \opt{style =} (style courant de ligne), 
        \item \opt{color =} (couleur courante des lignes),
        \item \opt{width =} (épaisseur courante des lignes en dixième de point),
        \item \opt{opacity =} (opacité courante des lignes),
        \item \opt{hidden =} (valeur de \emph{Hiddenlines}),
        \item \opt{arrows =} (0), trois valeurs possibles : 0 (pas de flèche), 1 (une flèche en $B$), 2 (flèche en $A$ et en $B$),
        \item \opt{close =} (false), indique si la ligne doit être refermée.
    \end{itemize}    

\subsubsection{Ajouter un plan : g:DSplane}

La méthode \textbf{g:DSplane(P,options)} permet d'ajouter le contour d'un plan, l'argument \emph{P} est une table de la forme \emph{\{A,n\}} où $A$ est un point du plan et $n$ un vecteur normal. La fonction dessine un parallélogramme représentant le plan $P$ en traitant les interactions avec la sphère. L'argument \emph{options} est une table à 7 champs, qui sont :
    \begin{itemize}
        \item \opt{style =} (style courant de ligne), 
        \item \opt{color =} (couleur courante des lignes),
        \item \opt{width =} (épaisseur courante des lignes en dixième de point),
        \item \opt{opacity =} (opacité courante des lignes),
        \item \opt{hidden =} (valeur de \emph{Hiddenlines}),
        \item \opt{scale =} (1), permet de changer la taille du parallélogramme,
        \item \opt{angle =} (0), angle en degrés, permet de faire pivoter le parallélogramme autour de la droite perpendiculaire passant par le centre de la sphère.
        \item \opt{trace =} (true), permet de dessiner ou non, l'intersection du plan avec la sphère lorsqu'elle n'est pas vide.
    \end{itemize}    

\subsubsection{Ajouter un label : g:DSlabel}

La méthode \textbf{g:DSlabel(text1,anchor1,options1, text2,anchor2,options2,...)} permet d'ajouter un ou plusieurs labels sur le même principe que la méthode \emph{g:Dlabel3d}, sauf qu'ici la fonction traite les cas où le point d'ancrage est à l'intérieur de la sphère, derrière la sphère ou devant la sphère. Dans le cas où il est à l'intérieur la couleur du label est donnée par la variable globale \textbf{Insidelabelcolor} qui vaut \emph{"DarkGray"} par défaut.

\subsubsection{Ajouter des points : g:DSdots et g:DSstars}

La méthode \textbf{g:DSdots(dots,options)} permet d'ajouter des points dans la scène, l'argument \emph{dots} est une liste de points 3d. La fonction dessine les points en gérant les interactions avec la sphère. L'argument \emph{options} est une table à 2 champs, qui sont :
    \begin{itemize}
        \item \opt{hidden =} (valeur de \emph{Hiddenlines}),
        \item \opt{mark\_options =} (""), chaîne qui sera passée directement à l'instruction \emph{\textbackslash draw}.
    \end{itemize}
Dans le cas où un point est à l'intérieur de la sphère, ou sur la face cachée, la couleur du point est donnée par la variable globale \textbf{Insidelabelcolor} qui vaut \emph{"DarkGray"} par défaut.

La méthode \textbf{g:DSstars(dots,options)} permet d'ajouter des points sur la sphère, l'argument \emph{dots} est une liste de points 3d qui seront projetés sur la sphère. La fonction dessine ces points en forme d'astérisque. L'argument \emph{options} est une table à 2 champs, qui sont :
   \begin{itemize}
        \item \opt{style =} (style courant de ligne), 
        \item \opt{color =} (couleur courante des lignes),
        \item \opt{width =} (épaisseur courante des lignes en dixième de point),
        \item \opt{opacity =} (opacité courante des lignes),
        \item \opt{hidden =} (valeur de \emph{Hiddenlines}),
        \item \opt{scale =} (1), permet de changer la taille du parallélogramme,
        \item \opt{circled =} (false), permet d'ajouter une cercle autour de l'étoile,
        \item \opt{fill =} (""), chaîne représentant une couleur, lorsqu'elle n'est pas vide, l'astérisque est remplacée par une facette hexagonale cerclée et remplie avec la couleur précise par cette option.
    \end{itemize}   
Les points qui sont sur la face cachée de la sphère ont la couleur donnée par la variable globale \textbf{Insidelabelcolor} qui vaut \emph{"DarkGray"} par défaut.

\subsubsection{Stéréographie inverse : g:DSinvstereo\_curve et g:DSinvstereo\_polyline}

La méthode \textbf{g:DSinvstereo\_curve(L,options)}, où \emph{L} est une ligne polygonale 3d représentant une courbe tracée sur un plan d'équation $z =$cte, dessine sur la sphère l'image de $L$ par stéréographie inverse, le pôle étant le point \emph{C+r*vecK}, où $C$ est le centre de la sphère et $r$ le rayon.

La méthode \textbf{g:DSinvstereo\_polyline(L,options)}, où \emph{L} est une ligne polygonale 3d tracée sur un plan d'équation $z =$cte, dessine sur la sphère l'image de $L$ par stéréographie inverse, le pôle étant le point \emph{C+r*vecK}, où $C$ est le centre de la sphère et $r$ le rayon.

Dans les deux cas, les \emph{options} sont les mêmes que pour la méthode \textbf{g:DScurve}.

\subsubsection{Exemples}

\begin{demo}{Cube dans une sphère}
\begin{luadraw}{name=cube_in_sphere}
local g = graph3d:new{window={-9,9,-4,5},viewdir={25,70},size={16,8}}
require 'luadraw_spherical'
arrowBstyle = "-stealth"
g:Linewidth(6); Hiddenlinestyle = "dashed"
local a = 4
local O = Origin
local cube = parallelep(O,a*vecI,a*vecJ,a*vecK)
local G = isobar3d(cube.vertices)
cube = shift3d(cube,-G) -- pour centrer le cube à l'origine
local R = pt3d.abs(cube.vertices[1])

local dessin = function()
    g:DSpolyline({{O,5*vecI},{O,5*vecJ},{O,5*vecK}},{arrows=1, width=8}) -- axes
    g:DSplane({a/2*vecK,vecK},{color="blue",scale=0.9,angle=20}); 
    g:DScircle({-a/2*vecK,vecK},{color="blue"})
    g:DSpolyline( facetedges(cube) ); g:DSlabel("$O$",O,{pos="W"})
    g:Dspherical()
end

g:Saveattr(); g:Viewport(-9,0,-4,5); g:Coordsystem(-5,5,-5,5)
Hiddenlines = true; g:Define_sphere({radius=R})
dessin()
g:Dlabel3d("$x$",5*vecI,{pos="SW"},"$y$",5*vecJ,{pos="E"},"$z$",5*vecK,{pos="N"})
g:Dlabel("Hiddenlines=true",0.5-4.5*cpx.I,{})
g:Restoreattr()

clear_spherical() -- supprime les objets précédemment créés

g:Saveattr(); g:Viewport(0,9,-4,5); g:Coordsystem(-5,5,-5,5)
Hiddenlines = false; g:Define_sphere({radius=R,opacity=0.7} )
dessin()
g:Dlabel3d("$x$",5*vecI,{pos="SW"},"$y$",5*vecJ,{pos="E"},"$z$",5*vecK,{pos="N"})
g:Dlabel("Hiddenlines=false, opacity=0.7",0.5-4.5*cpx.I,{})
g:Restoreattr()
g:Show()
\end{luadraw}
\end{demo}

\paragraph{Courbe sphérique}

\begin{demo}{Fenêtre de Viviani}
\begin{luadraw}{name=courbe_spherique}
local g = graph3d:new{window={-4.5,4.5,-4.5,4.5},viewdir={30,60},margin={0,0,0,0},size={10,10}}
require 'luadraw_spherical'
arrowBstyle = "-stealth"
g:Linewidth(6); Hiddenlinestyle = "dotted"
Hiddenlines = false; 
local C = cylinder(M(1.5,0,-3.5),1.5,M(1.5,0,3.5),35,true)
local L = parametric3d( function(t) return Ms(3,t-math.pi/2,t) end, -math.pi,math.pi) -- la courbe
g:Define_sphere()
g:DSpolyline(facetedges(C),{color="gray"}) -- affichage cylindre
g:DSpolyline({{-5*vecI,5*vecI},{-5*vecJ,5*vecJ},{-5*vecK,5*vecK}},{arrows=1}) --axes
Hiddenlines=true; g:DScurve(L,{width=12,color="blue"}) -- courbe avec partie cachée
g:Dspherical()
g:Show()
\end{luadraw}
\end{demo}

Pour ne pas nuire à la lisibilité du dessin, les parties cachées n'ont pas été affichées sauf celle de la courbe.

\paragraph{Un pavage sphérique}

\begin{demo}{Un pavage sphérique}
\begin{luadraw}{name=pavage_spherique}
local g = graph3d:new{window={-3,3,-3,3},viewdir={30,60},size={10,10}}
require 'luadraw_spherical'
require "luadraw_polyhedrons"
g:Linewidth(6); Hiddenlines = true; Hiddenlinestyle = "dotted"
local P = poly2facet( octahedron(Origin,sM(30,10)) )
local colors = {"Crimson","ForestGreen","Gold","SteelBlue","SlateGray","Brown","Orange","Navy"}
g:Define_sphere()
for k,F in ipairs(P) do
    g:DSfacet(F,{fill=colors[k],style="noline",fillopacity=0.7})  -- facettes sans les bords
end
for _, A in ipairs(facetedges(P)) do
    g:DSarc(A,1,{width=8}) -- chaque arête est un arc de grand cercle
end
g:Dspherical()
g:Show()
\end{luadraw}
\end{demo}

Pour ce pavage sphérique, on a choisi un octaèdre régulier de centre identique celui de la sphère et avec un sommet sur la sphère (et donc tous les sommets sont sur la sphère).

\paragraph{Tangentes à la sphère issues d'un point}

\begin{demo}{Tangentes à la sphère issues d'un point}
\begin{luadraw}{name=tangent_to_sphere}
local g = graph3d:new{window={-4,5.5,-4,4},viewdir={30,60},size={10,10}}
require 'luadraw_spherical'
Hiddenlines=true; g:Linewidth(6)
local O, I = Origin, M(0,6,0)
local S,S1 = {O, 3}, {(I+O)/2,pt3d.abs(I-O)/2}
-- the circle of tangency is the intersection between spheres S and S1
local C,r,n = interSS(S,S1) 
local L = circle3d(C,r,n)[1] -- list of 3d points on the circle
local dots, lines = {}, {}
-- draw
g:Define_sphere({opacity=1})
g:DScircle({C,n},{color="red"})
for k = 1, math.floor(#L/4) do
    local A = L[4*(k-1)+1]
    table.insert(dots,A)
    table.insert(lines,{I, 2*A-I})
end
g:DSpolyline(lines ,{color="gray"})
g:DSstars(dots) -- dessin de points sur la sphère
g:DSdots({O,I});  -- points dans la scène
g:DSlabel("$I$",I,{pos="S",node_options="red"},"$O$",O,{})
g:Dspherical()
g:Dseg3d({O,dots[1]},"gray,dashed"); g:Dangle3d(O,dots[1],I,0.2,"gray")
g:Show() 
\end{luadraw}
\end{demo}

\paragraph{Stéréographie inverse}

\begin{demo}{Méthodes \emph{DSinvstereo\_curve} et \emph{DSinvstereo\_polyline}}
\begin{luadraw}{name=stereographic_curve}
local g = graph3d:new{window3d={-5,5,-2,2,-2,2},window={-4.25,4.25,-2.5,2},size={10,10}, viewdir={40,70}}
Hiddenlines = true; Hiddenlinestyle="dashed"; g:Linewidth(6)
require 'luadraw_spherical'
local C, R = Origin, 1
local a = -R
local P = planeEq(0,0,1,-a)
local L = {M(2,0,a), M(2,2.5,a), M(-1,2,a)}
local L2 = circle3d(M(2.25,-1,a),0.5,vecK)[1]
local A, B = (L[2]+L[3])/2, L2[20]
local a,b = table.unpack( inv_projstereo({A,B},{C,R},C+R*vecK) )
g:Dplane(P,vecJ,6,6,15,"draw=none,fill=Beige")
g:Define_sphere( {center=C,radius=R, color="SlateGray!30", show=true} )
g:DSpolyline(L,{color="blue",close=true}); g:DSinvstereo_polyline(L,{color="red",width=8,close=true})
g:DSpolyline(L2,{color="Navy"}); g:DSinvstereo_curve(L2,{color="Brown",width=6})
g:DSplane(P,{scale=1.5})
g:DSpolyline({{C+R*vecK,A},{C+R*vecK,B}}, {color="ForestGreen",width=8})
g:DSpolyline({{-vecK,2*vecK}}, {arrows=1})
g:DSstars({C+R*vecK,a,b}, {scale=0.75})
g:Dspherical()
g:Dballdots3d({A,B},"ForestGreen",0.75)
g:Show()
\end{luadraw}
\end{demo}


\subsection{Le module \emph{luadraw\_palettes}}

Le module \emph{luadraw\_palettes}\footnote{Ce module est une contribution de \href{https://github.com/projetmbc/for-writing/tree/main/@prism}{Christphe BAL}.} définit $261$ palettes de couleurs portant chacune un nom. Une palette est une liste (table) de couleurs qui sont elles-mêmes des listes de trois valeurs numériques entre $0$ et $1$ (composantes rouge, verte et bleue). Toutes les palettes ont pour préfixe "pal", la liste de ces palettes ainsi que leur rendu, peuvent être visualisés dans ce \href{luadraw_palettes_list.pdf}{document}. L'extension fournit également la fonction \emph{getPal(name,options)} dont voici un exemple d'utilisation:
\begin{Luacode}
BlackbodyTransformed = getPal(
    "Blackbody", -- nom de la palette sans le préfixe pal
    {
    extract = {2, 5, 8, 9}, -- numéros des couleurs à extraire
    shift = 1, -- décalage parmi les couleurs extraites, ce qui donne ici: 5,8,9,2
    reverse = true -- inversion de l'ordre, ce qui donne ici: 2,9,8,5    
    }
)
\end{Luacode}


\subsection{Le module \emph{luadraw\_compile\_tex}}

\textbf{Attention} : ce module nécessite que soit installés les programmes \emph{pdf2ps} et \emph{pstoedit} sur votre système.

Ce module permet de :

\begin{enumerate}
    \item compiler un fragment de texte en \TeX,
    \item de convertir le fichier obtenu en un fichier \emph{eps} contenant du \og flattened postscript\fg,
    \item de lire le contenu du fichier \emph{eps} et renvoyer son contenu sous forme d'une liste de chemins, avec l'épaisseur de ligne en tête de chaque chemin, et l'instruction de remplissage à la fin.
    \item La liste ainsi obtenue peut être :
        \begin{enumerate}
            \item dessinée à l'écran,
            \item convertie en chemins 3d dans un plan donné et être dessinée,
            \item convertie en lignes polygonales 3d dans un plan donné (on perd alors l'épaisseur et la commande de remplissage) et être dessinée.
        \end{enumerate}
\end{enumerate}

\subsubsection{Première partie : compilation et lecture}

\paragraph{Attention} : cette étape nécessite une compilation du document avec l'option \emph{-shell-escape} ou \emph{-enable-write18}.
Sans cette option, le fragment ne sera pas compilé, ce qui n'est pas un problème si le fichier \emph{<filename>.eps} existe déjà et que l'on ne souhaitait pas le modifier.


La première étape est le rôle de la fonction \textbf{compile\_tex(text,filename)}, l'argument \emph{text} est une chaîne de caractères, c'est le fragment à compiler, l'argument optionnel \emph{filename} est aussi une chaîne de caractères, c'est le nom du fichier qui sera créé, ce nom ne doit contenir \textbf{ni chemin, ni extension}, par défaut ce nom est \emph{"tex2FlatPs"}, il est créé dans le dossier courant (mais sera ensuite effacé). Le processus se déroule en plusieurs étapes :
    \begin{enumerate}
        \item création du fichier tex. Celui-ci utilise deux variables globales qui sont :\par
            \verb|preamble = "\\documentclass[12pt]{article}\n"|\par
            \verb|usepackage = "\\usepackage{amsmath,amssymb}\n\\usepackage{fourier}\n"|\par
            La compilation se fait avec \emph{pdflatex}.
        \item Le fichier obtenu est transformé en postscript avec l'utilitaire \emph{pdf2ps}.
        \item Le fichier \emph{ps} obtenu est à son tour transformé avec l'utilitaire \emph{pstoedit} en un fichier \emph{eps} en \emph{ flattened postscript} (tout le contenu est sous forme de chemins).
        \item Le fichier  \emph{<filename>.eps} ainsi obtenu est copié dans le dossier de travail de \emph{luadraw} (le nom de ce dossier est dans la variable globale \emph{cachedir}), et tous les résidus de la compilation sont effacés.
        \item Le contenu du fichier ainsi créé est automatiquement lu par la fonction \emph{read\_compiled\_tex(filename)}, qui renvoie une liste de chemins, chaque chemin est une liste commençant par l'épaisseur de ligne, suivi de points et d'instructions comme un chemin ordinaire, et se terminant par la commande de remplissage (\emph{"fill"}, ou \emph{"eofill"} ou \emph{"stroke"}).
   \end{enumerate}
   
\subsubsection{Deuxième partie : exploitation du résultat}

\paragraph{En 2d} Le résultat peut être dessiné avec la méthode \textbf{g:Dcompiled\_tex(anchor,L,options)} où \emph{L} est le résultat renvoyé par la fonction \emph{compile\_tex()}. L'argument \emph{anchor} est un nombre complexe, il représente le centre de la boîte englobante du dessin contenu dans \emph{L}. L'argument \emph{options} est une table dont les champs sont :
\begin{itemize}
    \item \opt{scale =} (1), permet de jouer sur la taille du dessin, cette option peut être un nombre ou bien une table de deux nombres : \emph{\{scaleX, scaleY\}},
    \item \opt{color =} (couleur courante par défaut),
    \item \opt{dir =} (nil), table constituée de deux vecteurs \emph{\{v1, v2\}} indiquant le sens de l'écriture (nil signifie le sens habituel ce qui correspond à la table \emph{\{1,cpx.I\}}),
    \item \opt{hollow =} (false), permet d'activer ou désactiver le remplissage des formes. Avec la valeur \emph{true} seuls les contours sont dessinés.
    \item \opt{drawbox =} (false) : permet de dessiner ou non la boîte englobante,
    \item \opt{draw\_options =} ("") : chaîne contenant les options qui seront passées directement à la commande \emph{\backslash draw}.
\end{itemize}

Le résultat peut être transformé en ligne polygonale (liste de listes de complexes) avec la fonction \textbf{compiled\_tex2polyline(L,scale)} où \emph{L} est le résultat renvoyé par la fonction \emph{compile\_tex()}. L'argument optionnel \emph{scale} permet de jouer sur la taille, ce peut être un nombre ou bien une table de deux nombres : \emph{\{scaleX, scaleY\}}.


\begin{demo}{Exemple avec \emph{compile\_tex} en 2d}
\begin{luadraw}{name=compile_tex2d}
local g = graph:new{bbox=false}
require 'luadraw_compile_tex'
local i = cpx.I
local text = "\\[\\int_0^{+\\infty} e^{-\\frac{x^2}2}dx = \\frac{\\sqrt{2\\pi}}2\\]" -- text to compile
local L = compile_tex(text,"gauss_integral") -- compile with -shell-escape the first time to create the gauss_integral.eps file
g:Shift(2*i) -- a first drawing
g:Dcompiled_tex(0,L,{scale=2,hollow=true, drawbox=true, draw_options="fill=pink", dir={1-i/4,i}}) -- we draw L

g:Shift(-4*i) -- a second drawing
L = compiled_tex2polyline(L,{3,3}) -- L is converted to a polygonal line
local f = function(z) return Z(z.re,z.im+math.sin(z.re*1.5)) end  -- this function produces sinusoidal waves
L = ftransform(L,f) -- we apply f to L
g:Dpath( polyline2path(L), 'draw=none,fill=blue') -- we draw L as a path
g:Show()
\end{luadraw}
\end{demo}


\paragraph{En 3d} Le résultat peut être converti en 3d avec la méthode \textbf{g:Compiled\_tex2path3d(L,options)} où \emph{L} est le résultat renvoyé par la fonction \emph{compile\_tex()}. L'argument \emph{options} est une table dont les champs sont :
\begin{itemize}
    \item \opt{scale =} (1), permet de jouer sur la taille du dessin, cette option peut être un nombre ou bien une table de deux nombres : \emph{\{scaleX, scaleY\}},
    \item \opt{anchor =} (Origin), point 3d qui représente le centre de la boîte englobante du dessin,
    \item \opt{color =} (couleur courante par défaut),
    \item \opt{dir =} (\{vecJ,vecK\}), base du plan dans lequel sera le résultat (ce plan contiendra également le point \emph{anchor}), ces deux vecteurs indiquent le sens de l'écriture,
    \item \opt{polyline =} (false), avec la valeur \emph{true} le résultat renvoyé sera une liste de listes de points 3d et pourra donc être dessiné avec la méthode \emph{g:Dpolyline3d()}, par contre les informations : épaisseur de ligne et commande de remplissage, sont perdues. Avec la valeur \emph{false} le résultat est une liste de chemins, chaque chemin est une liste commençant par l'épaisseur de ligne, suivi de points 3d et d'instructions comme un chemin 3d ordinaire, et se terminant par la commande de remplissage (\emph{"fill"}, ou \emph{"eofill"} ou \emph{"stroke"}).
\end{itemize}

Avec l'option \opt{polyline=false} (valeur par défaut), le résultat envoyé peut être dessiné avec la méthode \textbf{g:Dcompiled\_tex3d(L, options)} où \emph{L} est le résultat de la méthode \emph{g:Compiled\_tex2path3d()}. L'argument \emph{options} est une table dont les champs sont :
\begin{itemize}
    \item \opt{color =} (couleur courante par défaut),
    \item \opt{hollow =} (false), permet d'activer ou désactiver le remplissages des formes. Avec la valeur \emph{true} seuls les contours sont dessinés,
    \item \opt{drawbox =} (false) : permet de dessiner ou non la boîte englobante,
    \item \opt{draw\_options =} ("") : chaîne contenant les options qui seront passées directement à la commande \emph{\backslash draw}.
\end{itemize}

\begin{demo}{Écrire sur un cylindre}
\begin{luadraw}{name=compile_tex3d}
local g = graph3d:new{ window={-3,3,-4,4}, margin={0,0,0,0}, size={10,10}, viewdir={-50,60}}
require 'luadraw_compile_tex'

function curve_on_cylinder(curve,cylinder,screenNormal) 
-- curve is a 3d polyline on a cylinder,
-- cylinder = {A,r,B}
-- this function separate the visible part from the hidden part of the curve
    local A,r,B = table.unpack(cylinder)
    local U = B-A
    local visibility_function = function(N)
        local I = dproj3d(N,{A,U})
        return (pt3d.dot(N-I,screenNormal) >= 0)
    end
    return split_points_by_visibility(curve,visibility_function)
end

local A, r, B = -3*vecK, 2, 2.5*vecK -- the cylinder
local text = "Euler theorem: \\par \\(e^{i\\pi}=-1\\)"
local L = compile_tex(text, "essai") -- compile with shell-escape the first time to create "essai.eps" file 
local C = g:Compiled_tex2path3d(L,{scale=3, anchor=M(r,0,0), dir={vecJ,vecK}, polyline=true})
-- C is the text converted into 3d polylines, in the plane passing through anchor and basic direction dir, with a scale of 3.

local f = function(A) return Mc(r,A.y/r,A.z) end -- returns the image of a point A on the cylinder by winding
C = ftransform3d(C,f) -- plane curve -> cylindrical curve transformation
local Cv, Ch = curve_on_cylinder(C, {A,r,B}, g.Normal) -- visible part and hidden part of C, this may take some time
Ch = polyline2path3d(Ch) -- hidden part, conversion to path
g:Dpath3d(Ch, "draw=none,fill=red!30") -- hidden part first
g:Dcylinder(A,r,B,{color="blue",opacity=0.5}) -- cylinder
Cv = polyline2path3d(Cv) -- visible part, conversion to path
g:Dpath3d(Cv, "draw=none,fill=red")
g:Show()
\end{luadraw}
\end{demo}

\subsection{Le module \emph{luadraw\_cvx\_polyhedra\_nets}}

\subsubsection{La fonction de base}

Le module \emph{luadraw\_cvx\_polyhedra\_nets} permet de \og déplier\fg\ un polyèdre \textbf{convexe} afin d'en obtenir un patron. La fonction réalisant le dépliage est :\par
\hfil \textbf{unfold\_polyhedron(P, options)}\hfil\par
L'argument \emph{P} doit être un polyèdre convexe. L'argument \emph{options} est une table permettant d'ajuster certains paramètres. Ceux-ci sont les suivants (avec leur valeur par défaut entre parenthèses):
\begin{itemize}
    \item \opt{opening = 1}, valeur comprise entre $0$ et $1$ représentant le "taux" d'ouverture. Avec la valeur $1$ le polyèdre est totalement déplié, les facettes renvoyées par la fonction seront donc toutes dans un même plan. Avec la valeur $0$, la fonction renvoie les facettes du polyèdre sans modification.
    
    \item \opt{root = 1}, numéro de la facette du polyèdre qui servira de racine, car la fonction met le polyèdre sous la forme d'un arbre en déterminant pour chaque facette quelles sont les voisines (facettes adjacentes) ainsi que les arêtes communes et les angles.
    Cette option permet de choisir la facette qui servira de point de départ.
    
    \item \opt{model = nil}, liste de listes de numéros de facettes pour imposer un modèle de patron, par exemple \emph{model=\{ \{1,6\},\{1,3\},\{1,4\},\{1,5,2\}\}}, la sous-liste  \emph{\{1,5,2\}} signifie que la facette $1$ est l'ancêtre de la facette $5$, et que la facette $5$ est l'ancêtre de la facette $2$, c'est à dire que les facettes $5$ et $1$  sont adjacentes, et la facette $5$ tournera autour de son arête commune avec la facette $1$ (même chose $5$ et $2$). Pour que le modèle soit cohérent, toutes les facettes du polyèdre SAUF une (qui sera la facette \emph{root}), doivent avoir un et un seul ancêtre; si dans le polyèdre les facettes $1$ et $5$ ne sont pas adjacentes, la fonction s'arrête et affiche une erreur dans le terminal. Lorsque l'option \emph{model} vaut \emph{nil} (valeur par défaut), l'algorithme calcule lui-même un modèle cohérent.
    
    \item \opt{to2d = false}, booléen qui permet d'obtenir une version 2d du patron dans le repère du plan de l'écran. Avec la valeur \emph{true}, l'option \emph{opening} prend automatiquement la valeur $1$ et les facettes renvoyées par la fonction auront des sommets exprimés en nombres complexes.
    
    \item \opt{tabs = false}, booléen qui permet d'ajouter ou non des languettes au patron dans la version 2d.  Avec la valeur \emph{true}, l'option \emph{to2d} prend automatiquement la valeur \emph{true} également, les facettes renvoyées par la fonction auront des sommets exprimés en nombres complexes dans le repère de l'écran, et la fonction renvoie en plus une ligne polygonale 2d représentant des languettes pour certaines arêtes (celles-ci sont déterminées automatiquement).
    
    \item \opt{tabs\_wd = 0.2}, valeur numérique représentant l'épaisseur des languettes lorsque l'option \emph{tabs} a la valeur \emph{true}.
    
    \item \opt{tabs\_lg = 0.5}, valeur numérique entre $0$ et $1$, permettant de déterminer la longueur du petit côté des languettes  celle-ci est égale à la longueur de l'arête (qui est le grand côté) multipliée par \emph{tabs\_lg} (lorsque l'option \emph{tabs} a la valeur \emph{true}).
    
    \item \opt{rotate = 0}, lorsque l'option \emph{to2d} a la valeur \emph{true}, le dessin est tourné d'un angle égal à \emph{rotate} (en degrés) autour de son centre. Dans la version 3d, le dessin est tourné le dessin est tourné d'un angle égal à \emph{rotate} (en degrés) autour de l'axe passant par le centre de gravité de la facette \emph{root} et orienté par un vecteur normal à cette facette dirigé vers l'extérieur du polyèdre.
\end{itemize}

La fonction renvoie en résultat une table constituée des champs suivants :
    \begin{itemize}
        \item Le champ \emph{facets} : qui contient la liste des facettes, avec les sommets en 2d (nombres complexes) si l'option \emph{to2d} vaut \emph{true}, ou sommets en 3d (points 3d) dans le cas contraire.
        
        \item Le champ \emph{tree} : qui est une liste de la forme : \par\hfil\emph{\{ \{ancestor,n1,n2,angle,vertices\}, ...\} }\hfil\par
    chaque élément de cette liste représente une facette avec pour chacune d'elles les informations suivantes :
            \begin{itemize}
            \item \emph{ancestor} : numéro de la facette ancêtre, c'est son rang dans la liste \emph{tree} (la facette qui a servi de racine a pour ancêtre le numéro $0$ qui ne correspond à aucune facette).
            
            \item \emph{n1, n2} : numéro des sommets la facette ancêtre représentant l'arête commune.
            
            \item \emph{angle} : angle en degré avec la facette ancêtre.
            
            \item \emph{vertices} : liste des sommets (points 3d) de la facette.
            \end{itemize}
        
        \item Le champ \emph{bounds} : qui contient sous la forme d'une liste, la bounding box des facettes (soit en 2d soit en 3d)
        \item Lorsque l'option \emph{tabs} a la valeur \emph{true}, alors il y a deux champs supplémentaires dans le résultat :
            \begin{itemize}
                \item Le champ \emph{tabs} : qui contient une ligne polygonale 2d (liste de listes de nombres complexes) représentant les languettes, ceci uniquement lorsque l'option \emph{tabs} a la valeur \emph{true}.
                \item Le champ \emph{twins} : qui contient une liste de la forme \emph{\{ \{\{a1,b1\},\{a2,b2\}\}, ... \}} représentant la liste des paires d'arêtes jumelles (les arêtes jumelles sont confondues lorsque le polyèdre est refermé), \emph{a1}, \emph{b1}, \emph{a2}, \emph{b2}, sont des nombres complexes représentant les extrémités des arêtes dans le patron du polyèdre version 2d. Cette liste est calculée uniquement lorsque l'option \emph{tabs} a la valeur \emph{true}.
            \end{itemize}
    \end{itemize}
    
\subsubsection{La méthode de dessin}

Celle-ci est la méthode \textbf{g:Dpolyhedron\_net(P, options)} où \emph{P} désigne un polyèdre convexe. Les options sont celles de la fonction précédentes, à celles-ci s'ajoutent :
    \begin{itemize}
        \item Dans le cas d'un patron 2d (lorsque l'option \emph{to2d}, ou l'option \emph{tabs}, a la valeur \emph{true}):
            \begin{itemize}
                \item \opt{facet\_name = false}, avec la valeur \emph{true} le numéro des facettes (précédé de la lettre F) sera affiché au centre de chaque facette.
                \item \opt{edge\_name = false},  avec la valeur \emph{true} le numéro des arêtes (précédé de la lettre e) sera affiché au centre de chaque arête, ce qui permet de repérer les arêtes jumelles et donc les facettes voisines.
                \item \opt{tabs\_options = ""}, chaîne représentant des options de dessin tikz pour les languettes si l'option \emph{tabs} a la valeur \emph{true}.
                \item \opt{facet\_options = ""}, chaîne représentant des options tikz de dessin pour la méthode \emph{g:Dpolyline()} qui dessinera les facettes.                
            \end{itemize}
        \item Dans le cas d'un patron 3D il y a uniquement en plus :
            \begin{itemize}
                \item \opt{facet\_options = \{\}}, liste d'options de dessin pour la méthode \emph{g:Dfacet()} qui dessinera les facettes. 
            \end{itemize}
    \end{itemize}

Le dessin est accompagné d'un affichage dans le terminal de la bounding box 2d de celui-ci.


\subsubsection{Exemples}

Dans cet exemple, on affiche le patron par défaut, version 2d,  d'un parallélépipède $P$ avec les languettes hachurées, le numéro des facettes (ce numéro est le rang dans la liste \emph{P.facets}) ainsi que le numéro des arêtes afin de voir celles qui doivent être collées ensemble:

\begin{demo}{Patron d'un parallélépipède}
\begin{luadraw}{name=parallelep_net}
local g = graph3d:new{viewdir={30,60},window={-8.5,8,-5,5},bbox=false, size={10,10}}
require 'luadraw_cvx_polyhedra_nets'
P = parallelep(Origin, 4*vecI,5*vecJ,3*vecK)
g:Dpolyhedron_net(P, {tabs=true, tabs_options="pattern=north west lines, pattern color=gray", facet_options="fill=Orange!30", facet_name=true, edge_name=true})
g:Show()
\end{luadraw}
\end{demo}

Le patron par défaut ici correspondrait à l'option \emph{model=\{\{1,3\},\{1,4\},\{1,5\},\{1,6\},\{3,2\}\}}\footnote{L'algorithme prend la première facette, puis cherche ses voisines, puis les voisines de la première voisine, etc.}, mais on peut vouloir imposer un autre modèle, par exemple, avec le même parallélépipède:

\begin{demo}{Patron imposé d'un parallélépipède}
\begin{luadraw}{name=parallelep_net2}
local g = graph3d:new{viewdir={30,60},window={-9,9,-5,5},bbox=false,size={10,10}}
require 'luadraw_cvx_polyhedra_nets'
P = parallelep(Origin, 4*vecI,5*vecJ,3*vecK)
g:Dpolyhedron_net(P, {model={{4,6,1,3,2,5}},tabs=true, tabs_options="pattern=north west lines, pattern color=gray", facet_options="fill=Orange!30", facet_name=true, edge_name=true, rotate=-90})
g:Show()
\end{luadraw}
\end{demo}

Voici un exemple avec un parallélépipède tronqué qui l'on déplie à moitié:

\begin{demo}{Parallélépipède tronqué à demi déplié}
\begin{luadraw}{name=parallelep_net3}
local g = graph3d:new{window={-9,15,-9,9,0.6,0.6},bg="lightgray", viewdir={30,60}, margin={0,0,0,0}} 
require 'luadraw_cvx_polyhedra_nets'
P = parallelep(Origin, 4*vecI,5*vecJ,3*vecK)
local A, B, C = M(4,2.5,3), M(2,5,3), M(4,5,1.5)
P = cutpoly(P, plane(A,B,C), true) -- P is truncated with a plane
g:Shift3d(M(0,-4,5))
g:Dpolynames(P,"facet") -- this function shows facet numbers of P
-- half unfolded P
g:Shift3d(M(0,0,-11))
g:Dpolyhedron_net(P,{opening=0.5, facet_options={color="Crimson", opacity=0.7, edgecolor="Gold", edgewidth=8}})
-- 2d net
g:Shift(10)
g:Dpolyhedron_net(P,{tabs=true, tabs_options="pattern=north west lines, pattern color=gray", facet_name=true, rotate=90})
g:Show()
\end{luadraw}
\end{demo}

\paragraph{NB :} Les fonctions \textbf{unfold\_polyhedron} et \textbf{g:Dpolyhedron\_net} s'appliquent à tout polyèdre convexe, mais elles ne donneront pas le résultat escompté avec un polyèdre non convexe.

\subsubsection{La fonction \emph{unfold\_tree()}}

Il peut être utile de récupérer l'arbre fabriqué par la fonction \textbf{unfold\_polyhedron} afin d'éviter de recalculer celui-ci plusieurs fois, lors d'une animation par exemple. La fonction \textbf{unfold\_tree(tree,opening,num)} permet aussi de déplier le polyèdre. L'argument\emph{tree} est l'arbre fourni par la fonction \emph{unfold\_polyhedron}, l'argument optionnel \emph{opening} est un nombre entre $0$ et $1$ qui représente le taux d'ouverture ($1$ par défaut), l'argument optionnel \emph{num} est le numéro de la facette que l'on souhaite ouvrir (et toute la descendance de la facette tournera de la même façon), lorsque cet argument est omis, toutes les facettes tournent.

\paragraph{Exemple d'animation :}

\begin{Luacode}
\begin{luacode*}
nbimages = 70 -- must be global
-- images creation
local g = graph3d:new{ viewdir=perspective("central",30,60), bg="gray", size={10,10}, margin={0,0,0,0} }
-- declarations
require 'luadraw_polyhedrons'
require 'luadraw_cvx_polyhedra_nets'
local p = linspace(0,1,36)
local T = linspace(0,360,nbimages+1)
local P = dodecahedron(Origin, -2*vecI)
local net = unfold_polyhedron(P)
local tree = net.tree
-- create the image number k, this function must be global
function makeframe(k) 
    local r = k
    if k > 36 then r = 72-k end
    local P1 = rotate3d( unfold_tree(tree,p[r]), T[k], {Origin,vecK})
    g:Dfacet(P1, {color="Crimson", edgecolor="Gold", edgewidth=8})
    -- send image number k
    g:Sendtotex()  -- send the tikzpicture to TeX
    g:Cleargraph()  
end
\end{luacode*}
\end{Luacode}

Le code \TeX\ (avec le paquet \emph{animate}) :

\begin{TeXcode}
\def\nb{\directlua{tex.print(nbimages)}}
\def\makeframe#1{\directlua{makeframe(#1)}}%

\begin{animateinline}[poster=first,controls,loop]{8}
\multiframe{\nb}{ik=1+1}{%
\makeframe{\ik}%
}%
\end{animateinline}
\end{TeXcode}

\begin{luacode*}
nbimages = 70
-- images creation
local g = graph3d:new{ viewdir=perspective("central",30,60), bg="gray", size={10,10}, margin={0,0,0,0} }
-- declarations
require 'luadraw_polyhedrons'
require 'luadraw_cvx_polyhedra_nets'
local p = linspace(0,1,36)
local T = linspace(0,360,nbimages+1)
local P = dodecahedron(Origin, -2*vecI)
local net = unfold_polyhedron(P)
local tree = net.tree
-- create the image number k, this function must be global
function makeframe(k) -- do not modify this line
    local r = k
    if k > 36 then r = 72-k end
    local P1 = rotate3d( unfold_tree(tree,p[r]), T[k],{Origin,vecK})
    g:Dfacet(P1, {color="Crimson", edgecolor="Gold", edgewidth=8})
    -- send image number k
    g:Sendtotex()  -- do not modify
    g:Cleargraph() -- do not modify
end
\end{luacode*}

\def\nb{\directlua{tex.print(nbimages)}}%
\def\makeframe#1{\directlua{makeframe(#1)}}%

Le résultat :

\begin{minipage}{0.9\textwidth}
\begin{center}
\captionof{figure}{Dépliage d'un dodécaèdre}
\begin{animateinline}[poster=first,controls,loop]{8} %palindrome
\multiframe{\nb}{ik=1+1}{%
\makeframe{\ik}%
}%
\end{animateinline}
\end{center}
\end{minipage}
