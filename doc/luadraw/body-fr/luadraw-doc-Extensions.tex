\section{Extensions}

\subsection{Le module \emph{luadraw\_polyhedrons}}

Ce module est encore à l'état d'ébauche et est appelé à s'étoffer par la suite. Comme son nom l'indique, il contient la définition de polyèdres. Toutes les données numériques sont issues du site \href{https://dmccooey.com/polyhedra/}{Visual Polyhedra}.

Toutes les fonctions sont sur le même modèle : \textbf{<nom>(C,S,all)} où $C$ est le centre du polyèdre (point 3d) et $S$ un sommet du polyèdre (point 3d), lorsque $C$ ou $S$ ont la valeur \emph{nil}, c'est le polyèdre non transformé (de centre l'origine) qui est renvoyé . L'argument facultatif \emph{all} est un booléen, lorsqu'il a la valeur \emph{true} la fonction renvoie quatre choses : \emph{P, V, E, F} où :
    \begin{itemize}
        \item $P$ est le solide en tant que polyèdre,
        \item $V$ la liste (table) des sommets,
        \item $E$ la liste (table) des arêtes (avec points 3d),
        \item $F$ la liste des facettes (avec points 3d). Certains polyèdres ont plusieurs types de facettes, dans ce cas la résultat renvoyé est de la forme : \emph{P, V, E, F1, F2, ...}, où $F1$, $F2$ ..., sont des listes de facettes.Cela peut permettre de les dessiner avec des couleurs différentes par exemple.
        \end{itemize}
L'argument \emph{all} la valeur \emph{false},qui est la valeur par défaut, la fonction ne renvoie que le polyèdre.

Voici les solides actuellement contenus dans ce module :

\begin{itemize}
    \item Les solides de Platon, ces solides n'ont qu'un type des faces :
        \begin{itemize}
            \item  la fonction \textbf{tetrahedron(C,S,all)} permet la construction d'un tétraèdre régulier de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d).
            \item La fonction \textbf{octahedron(C,S,all)} permet la construction d'un octaèdre de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d).
            \item La fonction \textbf{cube(C,S,all)} permet la construction d'un cube de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d).
            \item La fonction \textbf{icosahedron(C,S,all)} permet la construction d'un icosaèdre de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d).
            \item La fonction \textbf{dodecahedron(C,S,all)} permet la construction d'un dodécaèdre de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d).
        \end{itemize}

    \item Les solides d'Archimède :
        \begin{itemize}
            \item La fonction \textbf{cuboctahedron(C,S,all)} permet la construction d'un cuboctaèdre de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux types de faces.
            \item La fonction \textbf{icosidodecahedron(C,S,all)} permet la construction d'un icosidodécaèdre de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux types de faces.
            \item La fonction \textbf{lsnubcube(C,S,all)} permet la construction d'un cube adouci (forme 1) de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux types de faces.
            \item La fonction \textbf{lsnubdodecahedron(C,S,all)} permet la construction d'un dodécaèdre adouci (forme 1) de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux types de faces.
            \item La fonction \textbf{rhombicosidodecahedron(C,S,all)} permet la construction d'un rhombicosidodécaèdre de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a trois types de faces.
            \item La fonction \textbf{rhombicuboctahedron(C,S,all)} permet la construction d'un rhombicuboctaèdre de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux types de faces.
            \item La fonction \textbf{rsnubcube(C,S,all)} permet la construction d'un cube adouci (forme 2) de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux types de faces.
            \item La fonction \textbf{rsnubdodecahedron(C,S,all)} permet la construction d'un dodécaèdre adouci (forme 2) de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux types de faces.
            \item La fonction \textbf{truncatedcube(C,S,all)} permet la construction d'un cube tronqué de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux types de faces.
            \item La fonction \textbf{truncatedcuboctahedron(C,S,all)} permet la construction d'un cuboctaèdre tronqué de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a trois types de faces.
            \item La fonction \textbf{truncateddodecahedron(C,S,all)} permet la construction d'un dodécaèdre tronqué de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux types de faces.
            \item La fonction \textbf{truncatedicosahedron(C,S,all)} permet la construction d'un icosaèdre tronqué de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux types de faces.
             \item La fonction \textbf{truncatedicosidodecahedron(C,S,all)} permet la construction d'un icosidodécaèdre tronqué de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux trois de faces.
            \item La fonction \textbf{truncatedoctahedron(C,S,all)} permet la construction d'un octaèdre tronqué de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux types de faces.             
            \item La fonction \textbf{truncatedtetrahedron(C,S,all)} permet la construction d'un tétraèdre tronqué de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux types de faces.
        \end{itemize}

    \item Autres solides :
    \begin{itemize}
        \item La fonction \textbf{octahemioctahedron(C,S,all)} permet la construction d'un octahémioctaèdre de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a deux types de faces.
        \item La fonction \textbf{small\_stellated\_dodecahedron(C,S,all)} permet la construction d'un petit dodécaèdre étoilé de centre $C$ (point 3d) et dont un sommet est $S$ (point 3d). Ce solide a un seul type de faces.
    \end{itemize}
\end{itemize}

\begin{demo}{Polyèdres du module \emph{luadraw\_polyhedrons}}
\begin{luadraw}{name=polyhedrons}
local i = cpx.I
require 'luadraw_polyhedrons' -- chargement du module
local g = graph3d:new{bg="LightGray", size={10,10}}
g:Labelsize("small"); Hiddenlines = false
-- en haut à gauche 
g:Saveattr(); g:Viewport(-5,0,0,5); g:Coordsystem(-5,5,-5,5,true)
local T,S,A,F = icosahedron(Origin,M(0,2,4.5),true) 
g:Dscene3d(
    g:addFacet(F, {color="Crimson",opacity=0.8}),
    g:addPolyline(A, {color="Pink", width=8}),
    g:addDots(S) )
g:Dlabel("Icosaèdre",5*i,{})
g:Restoreattr()
-- en haut à droite
g:Saveattr()
g:Viewport(0,5,0,5); g:Coordsystem(-5,5,-5,5,true)
local T,S,A,F1,F2 = truncatedtetrahedron(Origin,M(0,0,5),true) -- sortie complète, affichage dans une scène 3d
g:Dscene3d(
    g:addFacet(F1, {color="Crimson",opacity=0.8}),
    g:addFacet(F2, {color="Gold"}),
    g:addPolyline(A, {color="Pink", width=8}),
    g:addDots(S) )
g:Dlabel("Tétraèdre tronqué",5*i,{})
g:Restoreattr()
-- en bas à gauche
g:Saveattr(); g:Viewport(-5,0,-5,0); g:Coordsystem(-5,5,-5,5,true)
local T,S,A,F1,F2,F3 = rhombicosidodecahedron(Origin,M(0,0,4.5),true)
g:Dscene3d(
    g:addFacet(F1, {color="Crimson",opacity=0.8}),
    g:addFacet(F2, {color="Gold",opacity=0.8}), g:addFacet(F3, {color="ForestGreen"}),
    g:addPolyline(A, {color="Pink", width=8}), g:addDots(S) )
g:Dlabel("Rhombicosidodécaèdre",-5*i,{})
g:Restoreattr()
-- en bas à droite
g:Saveattr(); g:Viewport(0,5,-5,0); g:Coordsystem(-5,5,-5,5,true)
local T,S,A,F1 = small_stellated_dodecahedron(Origin,M(0,0,5),true)
g:Dscene3d(
    g:addFacet(F1, {color="Crimson",opacity=0.8}),
    g:addPolyline(A, {color="Pink", width=8}),
    g:addDots(S) )
g:Dlabel("Petit dodécaèdre étoilé",-5*i,{})
g:Restoreattr()
g:Show()
\end{luadraw}

\end{demo}

\subsection{Le module \emph{luadraw\_spherical}}

Ce module permet de dessiner un certain nombre d'objets sur une sphère (comme par exemple des cercles, des triangles sphériques,...) sans avoir à gérer à la main les parties visibles ou non visibles. Le dessin se fait en trois temps:
\begin{enumerate}
    \item On définit les caractéristiques de la sphère (centre, rayon, couleur,...)
    \item On définit les objets à ajouter dans la scène, grâce à des méthodes dédiées.
    \item On affiche le tout avec la méthode \textbf{g:Dspherical()}.
\end{enumerate}
Bien sûr, toutes les méthodes de dessin 2d et 3d restent utilisables.

\subsubsection{Variables et fonctions globales du module}

\begin{itemize}
    \item Variables avec leur valeur par défaut:
        \begin{itemize}
            \item \textbf{Insidelabelcolor} = "DarkGray": définit la couleur des labels dont le point d'ancrage est intérieur à la sphère.
            \item \textbf{arrowBstyle} = "->" : type de flèche en fin de ligne
            \item \textbf{arrowAstyle} = "<-" : type de flèche en début de ligne
            \item \textbf{arrowABstyle} = "<->": très peu utilisée car la plupart du temps les lignes tracées sur la sphère doivent être découpées.
        \end{itemize}
    \item Fonctions :
        \begin{itemize}
            \item \textbf{sM(x,y,z)}: renvoie un point de la sphère, c'est le point $I$ de la sphère tel que la demi-droite $[O,I)$ ($O$ étant le centre de la sphère) passe par le point $A$ de coordonnées cartésiennes $(x,y,z)$. C'est le projeté du point $(Mx,y,z)$ sur la sphère partant du centre.
            \item \textbf{sM(theta,phi)}: où \emph{theta} et \emph{phi} sont des angles en degrés, renvoie un point de la sphère donc les coordonnées sphériques sont \emph{(R,theta,phi)} où $R$ est le rayon de la sphère.
            \item \textbf{toSphere(A)}: renvoie le projeté du point $A$ sur la sphère partant du centre.
            \item \textbf{clear\_spherical()}: supprime les objets qui ont été ajoutés à la scène, et remet les valeurs par défaut.
        \end{itemize}
\end{itemize}

Si la variable globale \textbf{Hiddenlines} a la valeur \emph{true}, alors les parties cachées seront dessinées dans le style défini par la variable globale \textbf{Hiddenlinestyle}, cependant on peut modifier ce comportement l'option locale \emph{hidden=true/false} .

\subsubsection{Définition de la sphère}
Par défaut, la sphère est centrée à l'origine, de rayon $3$ et de couleur orange, mais ceci peut être modifié avec la méthode \textbf{g:Define\_sphere( options )} où \emph{options} est une table permettant d'ajuster chaque paramètre. Ceux-ci sont les suivants (avec leur valeur par défaut entre parenthèses):
\begin{itemize}
    \item \opt{center =} (Origin),
    \item \opt{radius =} (3),
    \item \opt{color =} ("Orange"),
    \item \opt{opacity =} (1),
    \item \opt{mode =} (\emph{mBorder}), mode d'affichage de la sphère (\emph{mWireframe} ou \emph{mGrid} ou \emph{mBorder}, voir \textbf{Dsphere}),
    \item \opt{edgecolor =} ("LightGray"),
    \item \opt{edgestyle =} ("solid"),
    \item \opt{hiddenstyle =} (Hiddenlinestyle),
    \item \opt{hiddencolor =} ("gray"),
    \item \opt{edgewidth =} (4),
    \item \opt{show =} (true), pour montrer ou non la sphère.
\end{itemize}

\subsubsection{Ajouter un cercle : g:DScircle}

La méthode \textbf{g:DScircle(P,options)} permet d'ajouter un cercle sur la sphère, l'argument \emph{P} est une table de la forme $\{A,n\}$ qui représente un plan (passant par $A$ et normal à $n$, deux points 3d). Le cercle est alors défini comme l'intersection de ce plan avec la sphère. L'argument \emph{options} est une table à 5 champs, qui sont :
    \begin{itemize}
        \item \opt{style =} (style courant de ligne), 
        \item \opt{color =} (couleur courante des lignes),
        \item \opt{width =} (épaisseur courante des lignes en dixième de point),
        \item \opt{opacity =} (opacité courante des lignes),
        \item \opt{hidden =} (valeur de \emph{Hiddenlines}),
        \item \opt{out =} (nil), si on affecte une variable de type liste à ce paramètre \emph{out}, alors la fonction ajoute à cette liste les deux points correspondant aux extrémités de l'arc caché, s'il y en a un, ce qui permet de les récupérer sans avoir à les calculer.
    \end{itemize}
    
\subsubsection{Ajouter un grand cercle : g:DSbigcircle}

La méthode \textbf{g:DSbigcircle(AB,options)} permet d'ajouter un grand cercle sur la sphère, l'argument \emph{AB} est une table de la forme $\{A,B\}$ où $A$ et $B$ sont deux points distincts de la sphère. Le grand cercle est alors le cercle de centre le centre de la sphère, et passant par $A$ et $B$. L'argument \emph{options} est une table à 5 champs, qui sont :
    \begin{itemize}
        \item \opt{style =} (style courant de ligne), 
        \item \opt{color =} (couleur courante des lignes),
        \item \opt{width =} (épaisseur courante des lignes en dixième de point),
        \item \opt{opacity =} (opacité courante des lignes),
        \item \opt{hidden =} (valeur de \emph{Hiddenlines}),
        \item \opt{out =} (nil), si on affecte une variable de type table à ce paramètre \emph{out}, alors la fonction ajoute à cette liste les deux points correspondant aux extrémités de l'arc caché, s'il y en a un, ce qi permet de les récupérer sans avoir à les calculer.
    \end{itemize}

\subsubsection{Ajouter un arc de grand cercle : g:DSarc}

La méthode \textbf{g:DSarc(AB,sens,options)} permet d'ajouter un arc de grand cercle sur la sphère, l'argument \emph{AB} est une table de la forme $\{A,B\}$ où $A$ et $B$ sont deux points distincts de la sphère, on trace alors l'arc de grand cercle allant de $A$ vers $B$. L'argument \emph{sens} vaut 1 ou -1 pour indiquer le sens de l'arc. Lorsque $A$ et $B$ ne sont pas diamétralement opposés, le plan $OAB$ (où $O$ est le centre de la sphère) est orienté avec $\vec{OA}\wedge\vec{OB}$.  L'argument \emph{options} est une table à 6 champs, qui sont :
    \begin{itemize}
        \item \opt{style =} (style courant de ligne), 
        \item \opt{color =} (couleur courante des lignes),
        \item \opt{width =} (épaisseur courante des lignes en dixième de point),
        \item \opt{opacity =} (opacité courante des lignes),
        \item \opt{hidden =} (valeur de \emph{Hiddenlines}),
        \item \opt{arrows =} (0), trois valeurs possibles : 0 (pas de flèche), 1 (une flèche en $B$), 2 (flèche en $A$ et en $B$).
        \item \opt{normal =} (nil), permet de préciser un vecteur normal au plan $OAB$ lorsque ces trois points sont alignés.
    \end{itemize}

\subsubsection{Ajouter un angle : g:DSangle}

La méthode \textbf{g:DSangle(B,A,C,r,sens,options)} où $A$, $B$ et $C$ sont trois points de la sphère, permet de dessiner un arc de grand cercle sur la sphère pour représenter l'angle $(\vec{AB},\vec{AC})$ avec un rayon de \emph{r}. L'argument \emph{sens} vaut 1 ou -1 pour indiquer le sens de l'arc, le plan $ABC$ est orienté avec $\vec{AB}\wedge\vec{AC}$.  L'argument \emph{options} est une table à 6 champs, qui sont :
    \begin{itemize}
        \item \opt{style =} (style courant de ligne), 
        \item \opt{color =} (couleur courante des lignes),
        \item \opt{width =} (épaisseur courante des lignes en dixième de point),
        \item \opt{opacity =} (opacité courante des lignes),
        \item \opt{hidden =} (valeur de \emph{Hiddenlines}),
        \item \opt{arrows =} (0), trois valeurs possibles : 0 (pas de flèche), 1 (une flèche en $B$), 2 (flèche en $A$ et en $B$).
        \item \opt{normal =} (nil), permet de préciser un vecteur normal au plan $ABC$ lorsque ces trois points sont "alignés" sur un même grand cercle.
    \end{itemize}
    
\subsubsection{Ajouter une facette sphérique : g:DSfacet}

La méthode \textbf{g:DSfacet(F,options)} où \emph{F} est une liste de points de la sphère, permet de dessiner la facette représentée par $F$, les arêtes étant des arcs de grands cercles. L'argument \emph{options} est une table à 6 champs, qui sont :
    \begin{itemize}
        \item \opt{style =} (style courant de ligne), 
        \item \opt{color =} (couleur courante des lignes),
        \item \opt{width =} (épaisseur courante des lignes en dixième de point),
        \item \opt{opacity =} (opacité courante des lignes),
        \item \opt{hidden =} (valeur de \emph{Hiddenlines}),
        \item \opt{fill =} (""), chaîne représentant la couleur de remplissage (aucune par défaut),
        \item \opt{fillopacity =} (0.3), opacité de la couleur de remplissage.
    \end{itemize}
    
\subsubsection{Ajouter une courbe sphérique : g:DScurve}

La méthode \textbf{g:DScurve(L,options)} où \emph{L} est une liste de points de la sphère, permet de dessiner la courbe représentée par $L$. L'argument \emph{options} est une table à 6 champs, qui sont :
    \begin{itemize}
        \item \opt{style =} (style courant de ligne), 
        \item \opt{color =} (couleur courante des lignes),
        \item \opt{width =} (épaisseur courante des lignes en dixième de point),
        \item \opt{opacity =} (opacité courante des lignes),
        \item \opt{hidden =} (valeur de \emph{Hiddenlines}),
        \item \opt{out =} (nil), si on affecte une variable de type table à ce paramètre \emph{out}, alors la fonction ajoute à cette liste les points correspondant aux extrémités des parties cachées.
    \end{itemize}
    
Nous allons maintenant traiter d'objets qui ne sont pas forcément sur la sphère, mais qui peuvent la traverser, ou être à l'intérieur, ou à l'extérieur.

\subsubsection{ Ajouter un segment : g:DSseg}

La méthode \textbf{g:DSseg(AB,options)} permet d'ajouter un segment, l'argument \emph{AB} est une table de la forme $\{A,B\}$ où $A$ et $B$ sont deux points de l'espace. La fonction traite les interactions avec la sphère. L'argument \emph{options} est une table à 5 champs, qui sont :
    \begin{itemize}
        \item \opt{style =} (style courant de ligne), 
        \item \opt{color =} (couleur courante des lignes),
        \item \opt{width =} (épaisseur courante des lignes en dixième de point),
        \item \opt{opacity =} (opacité courante des lignes),
        \item \opt{hidden =} (valeur de \emph{Hiddenlines}),
        \item \opt{arrows =} (0), trois valeurs possibles : 0 (pas de flèche), 1 (une flèche en $B$), 2 (flèche en $A$ et en $B$).
    \end{itemize}
    
\subsubsection{Ajouter une droite : g:DSline}

La méthode \textbf{g:DSline(d,options)} permet d'ajouter une droite, l'argument \emph{d} est une table de la forme $\{A,u\}$ où $A$ et un point de la droite et $u$ un vecteur directeur (deux points 3d). La fonction traite les interactions avec la sphère.  Le segment tracé est obtenu en intersectant la droite avec la fenêtre 3d, il peut être vide si la fenêtre est trop étroite. L'argument \emph{options} est une table à 6 champs, qui sont :
    \begin{itemize}
        \item \opt{style =} (style courant de ligne), 
        \item \opt{color =} (couleur courante des lignes),
        \item \opt{width =} (épaisseur courante des lignes en dixième de point),
        \item \opt{opacity =} (opacité courante des lignes),
        \item \opt{hidden =} (valeur de \emph{Hiddenlines}),
        \item \opt{arrows =} (0), trois valeurs possibles : 0 (pas de flèche), 1 (une flèche en $B$), 2 (flèche en $A$ et en $B$),
        \item \opt{scale =} (1), permet de modifier la taille du segment tracé.
    \end{itemize}
    
\subsubsection{ Ajouter une ligne polygonale : g:DSpolyline}

La méthode \textbf{g:DSpolyline(L,options)} permet d'ajouter une ligne polygonale, l'argument \emph{L} est une liste de points de l'espace, ou une liste de listes de points de l'espace. La fonction traite les interactions avec la sphère. L'argument \emph{options} est une table à 6 champs, qui sont :
    \begin{itemize}
        \item \opt{style =} (style courant de ligne), 
        \item \opt{color =} (couleur courante des lignes),
        \item \opt{width =} (épaisseur courante des lignes en dixième de point),
        \item \opt{opacity =} (opacité courante des lignes),
        \item \opt{hidden =} (valeur de \emph{Hiddenlines}),
        \item \opt{arrows =} (0), trois valeurs possibles : 0 (pas de flèche), 1 (une flèche en $B$), 2 (flèche en $A$ et en $B$),
        \item \opt{close =} (false), indique si la ligne doit être refermée.
    \end{itemize}    

\subsubsection{Ajouter un plan : g:DSplane}

La méthode \textbf{g:DSplane(P,options)} permet d'ajouter le contour d'un plan, l'argument \emph{P} est une table de la forme \emph{\{A,n\}} où $A$ est un point du plan et $n$ un vecteur normal. La fonction dessine un parallélogramme représentant le plan $P$ en traitant les interactions avec la sphère. L'argument \emph{options} est une table à 7 champs, qui sont :
    \begin{itemize}
        \item \opt{style =} (style courant de ligne), 
        \item \opt{color =} (couleur courante des lignes),
        \item \opt{width =} (épaisseur courante des lignes en dixième de point),
        \item \opt{opacity =} (opacité courante des lignes),
        \item \opt{hidden =} (valeur de \emph{Hiddenlines}),
        \item \opt{scale =} (1), permet de changer la taille du parallélogramme,
        \item \opt{angle =} (0), angle en degrés, permet de faire pivoter le parallélogramme autour de la droite perpendiculaire passant par le centre de la sphère.
        \item \opt{trace =} (true), permet de dessiner ou non, l'intersection du plan avec la sphère lorsqu'elle n'est pas vide.
    \end{itemize}    

\subsubsection{Ajouter un label : g:DSlabel}

La méthode \textbf{g:DSlabel(text1,anchor1,options1, text2,anchor2,options2,...)} permet d'ajouter un ou plusieurs labels sur le même principe que la méthode \emph{g:Dlabel3d}, sauf qu'ici la fonction traite les cas où le point d'ancrage est à l'intérieur de la sphère, derrière la sphère ou devant la sphère. Dans le cas où il est à l'intérieur la couleur du label est donnée par la variable globale \textbf{Insidelabelcolor} qui vaut \emph{"DarkGray"} par défaut.

\subsubsection{Ajouter des points : g:DSdots et g:DSstars}

La méthode \textbf{g:DSdots(dots,options)} permet d'ajouter des points dans la scène, l'argument \emph{dots} est une liste de points 3d. La fonction dessine les points en gérant les interactions avec la sphère. L'argument \emph{options} est une table à 2 champs, qui sont :
    \begin{itemize}
        \item \opt{hidden =} (valeur de \emph{Hiddenlines}),
        \item \opt{mark\_options =} (""), chaîne qui sera passée directement à l'instruction \emph{\textbackslash draw}.
    \end{itemize}
Dans le cas où un point est à l'intérieur de la sphère, ou sur la face cachée, la couleur du point est donnée par la variable globale \textbf{Insidelabelcolor} qui vaut \emph{"DarkGray"} par défaut.

La méthode \textbf{g:DSstars(dots,options)} permet d'ajouter des points sur la sphère, l'argument \emph{dots} est une liste de points 3d qui seront projetés sur la sphère. La fonction dessine ces points en forme d'astérisque. L'argument \emph{options} est une table à 2 champs, qui sont :
   \begin{itemize}
        \item \opt{style =} (style courant de ligne), 
        \item \opt{color =} (couleur courante des lignes),
        \item \opt{width =} (épaisseur courante des lignes en dixième de point),
        \item \opt{opacity =} (opacité courante des lignes),
        \item \opt{hidden =} (valeur de \emph{Hiddenlines}),
        \item \opt{scale =} (1), permet de changer la taille du parallélogramme,
        \item \opt{circled =} (false), permet d'ajouter une cercle autour de l'étoile,
        \item \opt{fill =} (""), chaîne représentant une couleur, lorsqu'elle n'est pas vide, l'astérisque est remplacée par une facette hexagonale cerclée et remplie avec la couleur précise par cette option.
    \end{itemize}   
Les points qui sont sur la face cachée de la sphère ont la couleur donnée par la variable globale \textbf{Insidelabelcolor} qui vaut \emph{"DarkGray"} par défaut.

\subsubsection{Stéréographie inverse : g:DSinvstereo\_curve et g:DSinvstereo\_polyline}

La méthode \textbf{g:DSinvstereo\_curve(L,options)}, où \emph{L} est une ligne polygonale 3d représentant une courbe tracée sur un plan d'équation $z =$cte, dessine sur la sphère l'image de $L$ par stéréographie inverse, le pôle étant le point \emph{C+r*vecK}, où $C$ est le centre de la sphère et $r$ le rayon.

La méthode \textbf{g:DSinvstereo\_polyline(L,options)}, où \emph{L} est une ligne polygonale 3d tracée sur un plan d'équation $z =$cte, dessine sur la sphère l'image de $L$ par stéréographie inverse, le pôle étant le point \emph{C+r*vecK}, où $C$ est le centre de la sphère et $r$ le rayon.

Dans les deux cas, les \emph{options} sont les mêmes que pour la méthode \textbf{g:DScurve}.

\subsubsection{Exemples}

\begin{demo}{Cube dans une sphère}
\begin{luadraw}{name=cube_in_sphere}
local g = graph3d:new{window={-9,9,-4,5},viewdir={25,70},size={16,8}}
require 'luadraw_spherical'
arrowBstyle = "-stealth"
g:Linewidth(6); Hiddenlinestyle = "dashed"
local a = 4
local O = Origin
local cube = parallelep(O,a*vecI,a*vecJ,a*vecK)
local G = isobar3d(cube.vertices)
cube = shift3d(cube,-G) -- pour centrer le cube à l'origine
local R = pt3d.abs(cube.vertices[1])

local dessin = function()
    g:DSpolyline({{O,5*vecI},{O,5*vecJ},{O,5*vecK}},{arrows=1, width=8}) -- axes
    g:DSplane({a/2*vecK,vecK},{color="blue",scale=0.9,angle=20}); 
    g:DScircle({-a/2*vecK,vecK},{color="blue"})
    g:DSpolyline( facetedges(cube) ); g:DSlabel("$O$",O,{pos="W"})
    g:Dspherical()
end

g:Saveattr(); g:Viewport(-9,0,-4,5); g:Coordsystem(-5,5,-5,5)
Hiddenlines = true; g:Define_sphere({radius=R})
dessin()
g:Dlabel3d("$x$",5*vecI,{pos="SW"},"$y$",5*vecJ,{pos="E"},"$z$",5*vecK,{pos="N"})
g:Dlabel("Hiddenlines=true",0.5-4.5*cpx.I,{})
g:Restoreattr()

clear_spherical() -- supprime les objets précédemment créés

g:Saveattr(); g:Viewport(0,9,-4,5); g:Coordsystem(-5,5,-5,5)
Hiddenlines = false; g:Define_sphere({radius=R,opacity=0.7} )
dessin()
g:Dlabel3d("$x$",5*vecI,{pos="SW"},"$y$",5*vecJ,{pos="E"},"$z$",5*vecK,{pos="N"})
g:Dlabel("Hiddenlines=false, opacity=0.7",0.5-4.5*cpx.I,{})
g:Restoreattr()
g:Show()
\end{luadraw}
\end{demo}

\paragraph{Courbe sphérique}

\begin{demo}{Fenêtre de Viviani}
\begin{luadraw}{name=courbe_spherique}
local g = graph3d:new{window={-4.5,4.5,-4.5,4.5},viewdir={30,60},margin={0,0,0,0},size={10,10}}
require 'luadraw_spherical'
arrowBstyle = "-stealth"
g:Linewidth(6); Hiddenlinestyle = "dotted"
Hiddenlines = false; 
local C = cylinder(M(1.5,0,-3.5),1.5,M(1.5,0,3.5),35,true)
local L = parametric3d( function(t) return Ms(3,t-math.pi/2,t) end, -math.pi,math.pi) -- la courbe
g:Define_sphere()
g:DSpolyline(facetedges(C),{color="gray"}) -- affichage cylindre
g:DSpolyline({{-5*vecI,5*vecI},{-5*vecJ,5*vecJ},{-5*vecK,5*vecK}},{arrows=1}) --axes
Hiddenlines=true; g:DScurve(L,{width=12,color="blue"}) -- courbe avec partie cachée
g:Dspherical()
g:Show()
\end{luadraw}
\end{demo}

Pour ne pas nuire à la lisibilité du dessin, les parties cachées n'ont pas été affichées sauf celle de la courbe.

\paragraph{Un pavage sphérique}

\begin{demo}{Un pavage sphérique}
\begin{luadraw}{name=pavage_spherique}
local g = graph3d:new{window={-3,3,-3,3},viewdir={30,60},size={10,10}}
require 'luadraw_spherical'
require "luadraw_polyhedrons"
g:Linewidth(6); Hiddenlines = true; Hiddenlinestyle = "dotted"
local P = poly2facet( octahedron(Origin,sM(30,10)) )
local colors = {"Crimson","ForestGreen","Gold","SteelBlue","SlateGray","Brown","Orange","Navy"}
g:Define_sphere()
for k,F in ipairs(P) do
    g:DSfacet(F,{fill=colors[k],style="noline",fillopacity=0.7})  -- facettes sans les bords
end
for _, A in ipairs(facetedges(P)) do
    g:DSarc(A,1,{width=8}) -- chaque arête est un arc de grand cercle
end
g:Dspherical()
g:Show()
\end{luadraw}
\end{demo}

Pour ce pavage sphérique, on a choisi un octaèdre régulier de centre identique celui de la sphère et avec un sommet sur la sphère (et donc tous les sommets sont sur la sphère).

\paragraph{Tangentes à la sphère issues d'un point}

\begin{demo}{Tangentes à la sphère issues d'un point}
\begin{luadraw}{name=tangent_to_sphere}
local g = graph3d:new{window={-4,5.5,-4,4},viewdir={30,60},size={10,10}}
require 'luadraw_spherical'
Hiddenlines=true; g:Linewidth(6)
local O, I = Origin, M(0,6,0)
local S,S1 = {O, 3}, {(I+O)/2,pt3d.abs(I-O)/2}
-- the circle of tangency is the intersection between spheres S and S1
local C,r,n = interSS(S,S1) 
local L = circle3d(C,r,n)[1] -- list of 3d points on the circle
local dots, lines = {}, {}
-- draw
g:Define_sphere({opacity=1})
g:DScircle({C,n},{color="red"})
for k = 1, math.floor(#L/4) do
    local A = L[4*(k-1)+1]
    table.insert(dots,A)
    table.insert(lines,{I, 2*A-I})
end
g:DSpolyline(lines ,{color="gray"})
g:DSstars(dots) -- dessin de points sur la sphère
g:DSdots({O,I});  -- points dans la scène
g:DSlabel("$I$",I,{pos="S",node_options="red"},"$O$",O,{})
g:Dspherical()
g:Dseg3d({O,dots[1]},"gray,dashed"); g:Dangle3d(O,dots[1],I,0.2,"gray")
g:Show() 
\end{luadraw}
\end{demo}

\paragraph{Stéréographie inverse}

\begin{demo}{Méthodes \emph{DSinvstereo\_curve} et \emph{DSinvstereo\_polyline}}
\begin{luadraw}{name=stereographic_curve}
local g = graph3d:new{window3d={-5,5,-2,2,-2,2},window={-4.25,4.25,-2.5,2},size={10,10}, viewdir={40,70}}
Hiddenlines = true; Hiddenlinestyle="dashed"; g:Linewidth(6)
require 'luadraw_spherical'
local C, R = Origin, 1
local a = -R
local P = planeEq(0,0,1,-a)
local L = {M(2,0,a), M(2,2.5,a), M(-1,2,a)}
local L2 = circle3d(M(2.25,-1,a),0.5,vecK)[1]
local A, B = (L[2]+L[3])/2, L2[20]
local a,b = table.unpack( inv_projstereo({A,B},{C,R},C+R*vecK) )
g:Dplane(P,vecJ,6,6,15,"draw=none,fill=Beige")
g:Define_sphere( {center=C,radius=R, color="SlateGray!30", show=true} )
g:DSpolyline(L,{color="blue",close=true}); g:DSinvstereo_polyline(L,{color="red",width=8,close=true})
g:DSpolyline(L2,{color="Navy"}); g:DSinvstereo_curve(L2,{color="Brown",width=6})
g:DSplane(P,{scale=1.5})
g:DSpolyline({{C+R*vecK,A},{C+R*vecK,B}}, {color="ForestGreen",width=8})
g:DSpolyline({{-vecK,2*vecK}}, {arrows=1})
g:DSstars({C+R*vecK,a,b}, {scale=0.75})
g:Dspherical()
g:Dballdots3d({A,B},"ForestGreen",0.75)
g:Show()
\end{luadraw}
\end{demo}


\subsection{Le module \emph{luadraw\_palettes}}

Le module \emph{luadraw\_palettes}\footnote{Ce module est une contribution de \href{https://github.com/projetmbc/for-writing/tree/main/@prism}{Christphe BAL}.} définit $261$ palettes de couleurs portant chacune un nom. Une palette est une liste (table) de couleurs qui sont elles-mêmes des listes de trois valeurs numériques entre $0$ et $1$ (composantes rouge, verte et bleue). Toutes les palettes ont pour préfixe "pal", la liste de ces palettes ainsi que leur rendu, peuvent être visualisés dans ce \href{luadraw_palettes_list.pdf}{document}. L'extension fournit également la fonction \emph{getPal(name,options)} dont voici un exemple d'utilisation:
\begin{Luacode}
BlackbodyTransformed = getPal(
    "Blackbody", -- nom de la palette sans le préfixe pal
    {
    extract = {2, 5, 8, 9}, -- numéros des couleurs à extraire
    shift = 1, -- décalage parmi les couleurs extraites, ce qui donne ici: 5,8,9,2
    reverse = true -- inversion de l'ordre, ce qui donne ici: 2,9,8,5    
    }
)
\end{Luacode}


\subsection{Le module \emph{luadraw\_compile\_tex}}

\textbf{Attention} : ce module nécessite que soit installés les programmes \emph{pdf2ps} et \emph{pstoedit} sur votre système.

Ce module permet de :

\begin{enumerate}
    \item compiler un fragment de texte en \TeX,
    \item de convertir le fichier obtenu en un fichier \emph{eps} contenant du \og flattened postscript\fg,
    \item de lire le contenu du fichier \emph{eps} et renvoyer son contenu sous forme d'une liste de chemins, avec l'épaisseur de ligne en tête de chaque chemin, et l'instruction de remplissage à la fin.
    \item La liste ainsi obtenue peut être :
        \begin{enumerate}
            \item dessinée à l'écran,
            \item convertie en chemins 3d dans un plan donné et être dessinée,
            \item convertie en lignes polygonales 3d dans un plan donné (on perd alors l'épaisseur et la commande de remplissage) et être dessinée.
        \end{enumerate}
\end{enumerate}

\subsubsection{Première partie : compilation et lecture}

\paragraph{Attention} : cette étape nécessite une compilation du document avec l'option \emph{-shell-escape} ou \emph{-enable-write18}.
Sans cette option, le fragment ne sera pas compilé, ce qui n'est pas un problème si le fichier \emph{<filename>.eps} existe déjà et que l'on ne souhaitait pas le modifier.


La première étape est le rôle de la fonction \textbf{compile\_tex(text,filename)}, l'argument \emph{text} est une chaîne de caractères, c'est le fragment à compiler, l'argument optionnel \emph{filename} est aussi une chaîne de caractères, c'est le nom du fichier qui sera créé, ce nom ne doit contenir \textbf{ni chemin, ni extension}, par défaut ce nom est \emph{"tex2FlatPs"}, il est créé dans le dossier courant (mais sera ensuite effacé). Le processus se déroule en plusieurs étapes :
    \begin{enumerate}
        \item création du fichier tex. Celui-ci utilise deux variables globales qui sont :\par
            \verb|preamble = "\\documentclass[12pt]{article}\n"|\par
            \verb|usepackage = "\\usepackage{amsmath,amssymb}\n\\usepackage{fourier}\n"|\par
            La compilation se fait avec \emph{pdflatex}.
        \item Le fichier obtenu est transformé en postscript avec l'utilitaire \emph{pdf2ps}.
        \item Le fichier \emph{ps} obtenu est à son tour transformé avec l'utilitaire \emph{pstoedit} en un fichier \emph{eps} en \emph{ flattened postscript} (tout le contenu est sous forme de chemins).
        \item Le fichier  \emph{<filename>.eps} ainsi obtenu est copié dans le dossier de travail de \emph{luadraw} (le nom de ce dossier est dans la variable globale \emph{cachedir}), et tous les résidus de la compilation sont effacés.
        \item Le contenu du fichier ainsi créé est automatiquement lu par la fonction \emph{read\_compiled\_tex(filename)}, qui renvoie une liste de chemins, chaque chemin est une liste commençant par l'épaisseur de ligne, suivi de points et d'instructions comme un chemin ordinaire, et se terminant par la commande de remplissage (\emph{"fill"}, ou \emph{"eofill"} ou \emph{"stroke"}).
   \end{enumerate}
   
\subsubsection{Deuxième partie : exploitation du résultat}

\paragraph{En 2d} Le résultat peut être dessiné avec la méthode \textbf{g:Dcompiled\_tex(anchor,L,options)} où \emph{L} est le résultat renvoyé par la fonction \emph{compile\_tex()}. L'argument \emph{anchor} est un nombre complexe, il représente le centre de la boîte englobante du dessin contenu dans \emph{L}. L'argument \emph{options} est une table dont les champs sont :
\begin{itemize}
    \item \opt{scale =} (1), permet de jouer sur la taille du dessin, cette option peut être un nombre ou bien une table de deux nombres : \emph{\{scaleX, scaleY\}},
    \item \opt{color =} (couleur courante par défaut),
    \item \opt{dir =} (nil), table constituée de deux vecteurs \emph{\{v1, v2\}} indiquant le sens de l'écriture (nil signifie le sens habituel ce qui correspond à la table \emph{\{1,cpx.I\}}),
    \item \opt{hollow =} (false), permet d'activer ou désactiver le remplissage des formes. Avec la valeur \emph{true} seuls les contours sont dessinés.
    \item \opt{drawbox =} (false) : permet de dessiner ou non la boîte englobante,
    \item \opt{draw\_options =} ("") : chaîne contenant les options qui seront passées directement à la commande \emph{\backslash draw}.
\end{itemize}

Le résultat peut être transformé en ligne polygonale (liste de listes de complexes) avec la fonction \textbf{compiled\_tex2polyline(L,scale)} où \emph{L} est le résultat renvoyé par la fonction \emph{compile\_tex()}. L'argument optionnel \emph{scale} permet de jouer sur la taille, ce peut être un nombre ou bien une table de deux nombres : \emph{\{scaleX, scaleY\}}.


\begin{demo}{Exemple avec \emph{compile\_tex} en 2d}
\begin{luadraw}{name=compile_tex2d}
local g = graph:new{bbox=false}
require 'luadraw_compile_tex'
local i = cpx.I
local text = "\\[\\int_0^{+\\infty} e^{-\\frac{x^2}2}dx = \\frac{\\sqrt{2\\pi}}2\\]" -- text to compile
local L = compile_tex(text,"gauss_integral") -- compile with -shell-escape the first time to create the gauss_integral.eps file
g:Shift(2*i) -- a first drawing
g:Dcompiled_tex(0,L,{scale=2,hollow=true, drawbox=true, draw_options="fill=pink", dir={1-i/4,i}}) -- we draw L

g:Shift(-4*i) -- a second drawing
L = compiled_tex2polyline(L,{3,3}) -- L is converted to a polygonal line
local f = function(z) return Z(z.re,z.im+math.sin(z.re*1.5)) end  -- this function produces sinusoidal waves
L = ftransform(L,f) -- we apply f to L
g:Dpath( polyline2path(L), 'draw=none,fill=blue') -- we draw L as a path
g:Show()
\end{luadraw}
\end{demo}


\paragraph{En 3d} Le résultat peut être converti en 3d avec la méthode \textbf{g:Compiled\_tex2path3d(L,options)} où \emph{L} est le résultat renvoyé par la fonction \emph{compile\_tex()}. L'argument \emph{options} est une table dont les champs sont :
\begin{itemize}
    \item \opt{scale =} (1), permet de jouer sur la taille du dessin, cette option peut être un nombre ou bien une table de deux nombres : \emph{\{scaleX, scaleY\}},
    \item \opt{anchor =} (Origin), point 3d qui représente le centre de la boîte englobante du dessin,
    \item \opt{color =} (couleur courante par défaut),
    \item \opt{dir =} (\{vecJ,vecK\}), base du plan dans lequel sera le résultat (ce plan contiendra également le point \emph{anchor}), ces deux vecteurs indiquent le sens de l'écriture,
    \item \opt{polyline =} (false), avec la valeur \emph{true} le résultat renvoyé sera une liste de listes de points 3d et pourra donc être dessiné avec la méthode \emph{g:Dpolyline3d()}, par contre les informations : épaisseur de ligne et commande de remplissage, sont perdues. Avec la valeur \emph{false} le résultat est une liste de chemins, chaque chemin est une liste commençant par l'épaisseur de ligne, suivi de points 3d et d'instructions comme un chemin 3d ordinaire, et se terminant par la commande de remplissage (\emph{"fill"}, ou \emph{"eofill"} ou \emph{"stroke"}).
\end{itemize}

Avec l'option \opt{polyline=false} (valeur par défaut), le résultat envoyé peut être dessiné avec la méthode \textbf{g:Dcompiled\_tex3d(L, options)} où \emph{L} est le résultat de la méthode \emph{g:Compiled\_tex2path3d()}. L'argument \emph{options} est une table dont les champs sont :
\begin{itemize}
    \item \opt{color =} (couleur courante par défaut),
    \item \opt{hollow =} (false), permet d'activer ou désactiver le remplissages des formes. Avec la valeur \emph{true} seuls les contours sont dessinés,
    \item \opt{drawbox =} (false) : permet de dessiner ou non la boîte englobante,
    \item \opt{draw\_options =} ("") : chaîne contenant les options qui seront passées directement à la commande \emph{\backslash draw}.
\end{itemize}

\begin{demo}{Écrire sur un cylindre}
\begin{luadraw}{name=compile_tex3d}
local g = graph3d:new{ window={-3,3,-4,4}, margin={0,0,0,0}, size={10,10}, viewdir={-50,60}}
require 'luadraw_compile_tex'

function curve_on_cylinder(curve,cylinder,screenNormal) 
-- curve is a 3d polyline on a cylinder,
-- cylinder = {A,r,B}
-- this function separate the visible part from the hidden part of the curve
    local A,r,B = table.unpack(cylinder)
    local U = B-A
    local visibility_function = function(N)
        local I = dproj3d(N,{A,U})
        return (pt3d.dot(N-I,screenNormal) >= 0)
    end
    return split_points_by_visibility(curve,visibility_function)
end

local A, r, B = -3*vecK, 2, 2.5*vecK -- the cylinder
local text = "Euler theorem: \\par \\(e^{i\\pi}=-1\\)"
local L = compile_tex(text, "essai") -- compile with shell-escape the first time to create "essai.eps" file 
local C = g:Compiled_tex2path3d(L,{scale=3, anchor=M(r,0,0), dir={vecJ,vecK}, polyline=true})
-- C is the text converted into 3d polylines, in the plane passing through anchor and basic direction dir, with a scale of 3.

local f = function(A) return Mc(r,A.y/r,A.z) end -- returns the image of a point A on the cylinder by winding
C = ftransform3d(C,f) -- plane curve -> cylindrical curve transformation
local Cv, Ch = curve_on_cylinder(C, {A,r,B}, g.Normal) -- visible part and hidden part of C, this may take some time
Ch = polyline2path3d(Ch) -- hidden part, conversion to path
g:Dpath3d(Ch, "draw=none,fill=red!30") -- hidden part first
g:Dcylinder(A,r,B,{color="blue",opacity=0.5}) -- cylinder
Cv = polyline2path3d(Cv) -- visible part, conversion to path
g:Dpath3d(Cv, "draw=none,fill=red")
g:Show()
\end{luadraw}
\end{demo}

\subsection{Le module \emph{luadraw\_cvx\_polyhedra\_nets}}

\subsubsection{La fonction de base}

Le module \emph{luadraw\_cvx\_polyhedra\_nets} permet de \og déplier\fg\ un polyèdre \textbf{convexe} afin d'en obtenir un patron. La fonction réalisant le dépliage est :\par
\hfil \textbf{unfold\_polyhedron(P, options)}\hfil\par
L'argument \emph{P} doit être un polyèdre convexe. L'argument \emph{options} est une table permettant d'ajuster certains paramètres. Ceux-ci sont les suivants (avec leur valeur par défaut entre parenthèses):
\begin{itemize}
    \item \opt{opening = 1}, valeur comprise entre $0$ et $1$ représentant le "taux" d'ouverture. Avec la valeur $1$ le polyèdre est totalement déplié, les facettes renvoyées par la fonction seront donc toutes dans un même plan. Avec la valeur $0$, la fonction renvoie les facettes du polyèdre sans modification.
    
    \item \opt{root = 1}, numéro de la facette du polyèdre qui servira de racine, car la fonction met le polyèdre sous la forme d'un arbre en déterminant pour chaque facette quelles sont les voisines (facettes adjacentes) ainsi que les arêtes communes et les angles.
    Cette option permet de choisir la facette qui servira de point de départ.
    
    \item \opt{model = nil}, liste de listes de numéros de facettes pour imposer un modèle de patron, par exemple \emph{model=\{ \{1,6\},\{1,3\},\{1,4\},\{1,5,2\}\}}, la sous-liste  \emph{\{1,5,2\}} signifie que la facette $1$ est l'ancêtre de la facette $5$, et que la facette $5$ est l'ancêtre de la facette $2$, c'est à dire que les facettes $5$ et $1$  sont adjacentes, et la facette $5$ tournera autour de son arête commune avec la facette $1$ (même chose $5$ et $2$). Pour que le modèle soit cohérent, toutes les facettes du polyèdre SAUF une (qui sera la facette \emph{root}), doivent avoir un et un seul ancêtre; si dans le polyèdre les facettes $1$ et $5$ ne sont pas adjacentes, la fonction s'arrête et affiche une erreur dans le terminal. Lorsque l'option \emph{model} vaut \emph{nil} (valeur par défaut), l'algorithme calcule lui-même un modèle cohérent.
    
    \item \opt{to2d = false}, booléen qui permet d'obtenir une version 2d du patron dans le repère du plan de l'écran. Avec la valeur \emph{true}, l'option \emph{opening} prend automatiquement la valeur $1$ et les facettes renvoyées par la fonction auront des sommets exprimés en nombres complexes.
    
    \item \opt{tabs = false}, booléen qui permet d'ajouter ou non des languettes au patron dans la version 2d.  Avec la valeur \emph{true}, l'option \emph{to2d} prend automatiquement la valeur \emph{true} également, les facettes renvoyées par la fonction auront des sommets exprimés en nombres complexes dans le repère de l'écran, et la fonction renvoie en plus une ligne polygonale 2d représentant des languettes pour certaines arêtes (celles-ci sont déterminées automatiquement).
    
    \item \opt{tabs\_wd = 0.2}, valeur numérique représentant l'épaisseur des languettes lorsque l'option \emph{tabs} a la valeur \emph{true}.
    
    \item \opt{tabs\_lg = 0.5}, valeur numérique entre $0$ et $1$, permettant de déterminer la longueur du petit côté des languettes  celle-ci est égale à la longueur de l'arête (qui est le grand côté) multipliée par \emph{tabs\_lg} (lorsque l'option \emph{tabs} a la valeur \emph{true}).
    
    \item \opt{rotate = 0}, lorsque l'option \emph{to2d} a la valeur \emph{true}, le dessin est tourné d'un angle égal à \emph{rotate} (en degrés) autour de son centre. Dans la version 3d, le dessin est tourné le dessin est tourné d'un angle égal à \emph{rotate} (en degrés) autour de l'axe passant par le centre de gravité de la facette \emph{root} et orienté par un vecteur normal à cette facette dirigé vers l'extérieur du polyèdre.
\end{itemize}

La fonction renvoie en résultat une table constituée des champs suivants :
    \begin{itemize}
        \item Le champ \emph{facets} : qui contient la liste des facettes, avec les sommets en 2d (nombres complexes) si l'option \emph{to2d} vaut \emph{true}, ou sommets en 3d (points 3d) dans le cas contraire.
        
        \item Le champ \emph{tree} : qui est une liste de la forme : \par\hfil\emph{\{ \{ancestor,n1,n2,angle,vertices\}, ...\} }\hfil\par
    chaque élément de cette liste représente une facette avec pour chacune d'elles les informations suivantes :
            \begin{itemize}
            \item \emph{ancestor} : numéro de la facette ancêtre, c'est son rang dans la liste \emph{tree} (la facette qui a servi de racine a pour ancêtre le numéro $0$ qui ne correspond à aucune facette).
            
            \item \emph{n1, n2} : numéro des sommets la facette ancêtre représentant l'arête commune.
            
            \item \emph{angle} : angle en degré avec la facette ancêtre.
            
            \item \emph{vertices} : liste des sommets (points 3d) de la facette.
            \end{itemize}
        
        \item Le champ \emph{bounds} : qui contient sous la forme d'une liste, la bounding box des facettes (soit en 2d soit en 3d)
        \item Lorsque l'option \emph{tabs} a la valeur \emph{true}, alors il y a deux champs supplémentaires dans le résultat :
            \begin{itemize}
                \item Le champ \emph{tabs} : qui contient une ligne polygonale 2d (liste de listes de nombres complexes) représentant les languettes, ceci uniquement lorsque l'option \emph{tabs} a la valeur \emph{true}.
                \item Le champ \emph{twins} : qui contient une liste de la forme \emph{\{ \{\{a1,b1\},\{a2,b2\}\}, ... \}} représentant la liste des paires d'arêtes jumelles (les arêtes jumelles sont confondues lorsque le polyèdre est refermé), \emph{a1}, \emph{b1}, \emph{a2}, \emph{b2}, sont des nombres complexes représentant les extrémités des arêtes dans le patron du polyèdre version 2d. Cette liste est calculée uniquement lorsque l'option \emph{tabs} a la valeur \emph{true}.
            \end{itemize}
    \end{itemize}
    
\subsubsection{La méthode de dessin}

Celle-ci est la méthode \textbf{g:Dpolyhedron\_net(P, options)} où \emph{P} désigne un polyèdre convexe. Les options sont celles de la fonction précédentes, à celles-ci s'ajoutent :
    \begin{itemize}
        \item Dans le cas d'un patron 2d (lorsque l'option \emph{to2d}, ou l'option \emph{tabs}, a la valeur \emph{true}):
            \begin{itemize}
                \item \opt{facet\_name = false}, avec la valeur \emph{true} le numéro des facettes (précédé de la lettre F) sera affiché au centre de chaque facette.
                \item \opt{edge\_name = false},  avec la valeur \emph{true} le numéro des arêtes (précédé de la lettre e) sera affiché au centre de chaque arête, ce qui permet de repérer les arêtes jumelles et donc les facettes voisines.
                \item \opt{tabs\_options = ""}, chaîne représentant des options de dessin tikz pour les languettes si l'option \emph{tabs} a la valeur \emph{true}.
                \item \opt{facet\_options = ""}, chaîne représentant des options tikz de dessin pour la méthode \emph{g:Dpolyline()} qui dessinera les facettes.                
            \end{itemize}
        \item Dans le cas d'un patron 3D il y a uniquement en plus :
            \begin{itemize}
                \item \opt{facet\_options = \{\}}, liste d'options de dessin pour la méthode \emph{g:Dfacet()} qui dessinera les facettes. 
            \end{itemize}
    \end{itemize}

Le dessin est accompagné d'un affichage dans le terminal de la bounding box 2d de celui-ci.


\subsubsection{Exemples}

Dans cet exemple, on affiche le patron par défaut, version 2d,  d'un parallélépipède $P$ avec les languettes hachurées, le numéro des facettes (ce numéro est le rang dans la liste \emph{P.facets}) ainsi que le numéro des arêtes afin de voir celles qui doivent être collées ensemble:

\begin{demo}{Patron d'un parallélépipède}
\begin{luadraw}{name=parallelep_net}
local g = graph3d:new{viewdir={30,60},window={-8.5,8,-5,5},bbox=false, size={10,10}}
require 'luadraw_cvx_polyhedra_nets'
P = parallelep(Origin, 4*vecI,5*vecJ,3*vecK)
g:Dpolyhedron_net(P, {tabs=true, tabs_options="pattern=north west lines, pattern color=gray", facet_options="fill=Orange!30", facet_name=true, edge_name=true})
g:Show()
\end{luadraw}
\end{demo}

Le patron par défaut ici correspondrait à l'option \emph{model=\{\{1,3\},\{1,4\},\{1,5\},\{1,6\},\{3,2\}\}}\footnote{L'algorithme prend la première facette, puis cherche ses voisines, puis les voisines de la première voisine, etc.}, mais on peut vouloir imposer un autre modèle, par exemple, avec le même parallélépipède:

\begin{demo}{Patron imposé d'un parallélépipède}
\begin{luadraw}{name=parallelep_net2}
local g = graph3d:new{viewdir={30,60},window={-9,9,-5,5},bbox=false,size={10,10}}
require 'luadraw_cvx_polyhedra_nets'
P = parallelep(Origin, 4*vecI,5*vecJ,3*vecK)
g:Dpolyhedron_net(P, {model={{4,6,1,3,2,5}},tabs=true, tabs_options="pattern=north west lines, pattern color=gray", facet_options="fill=Orange!30", facet_name=true, edge_name=true, rotate=-90})
g:Show()
\end{luadraw}
\end{demo}

Voici un exemple avec un parallélépipède tronqué qui l'on déplie à moitié:

\begin{demo}{Parallélépipède tronqué à demi déplié}
\begin{luadraw}{name=parallelep_net3}
local g = graph3d:new{window={-9,15,-9,9,0.6,0.6},bg="lightgray", viewdir={30,60}, margin={0,0,0,0}} 
require 'luadraw_cvx_polyhedra_nets'
P = parallelep(Origin, 4*vecI,5*vecJ,3*vecK)
local A, B, C = M(4,2.5,3), M(2,5,3), M(4,5,1.5)
P = cutpoly(P, plane(A,B,C), true) -- P is truncated with a plane
g:Shift3d(M(0,-4,5))
g:Dpolynames(P,"facet") -- this function shows facet numbers of P
-- half unfolded P
g:Shift3d(M(0,0,-11))
g:Dpolyhedron_net(P,{opening=0.5, facet_options={color="Crimson", opacity=0.7, edgecolor="Gold", edgewidth=8}})
-- 2d net
g:Shift(10)
g:Dpolyhedron_net(P,{tabs=true, tabs_options="pattern=north west lines, pattern color=gray", facet_name=true, rotate=90})
g:Show()
\end{luadraw}
\end{demo}

\paragraph{NB :} Les fonctions \textbf{unfold\_polyhedron} et \textbf{g:Dpolyhedron\_net} s'appliquent à tout polyèdre convexe, mais elles ne donneront pas le résultat escompté avec un polyèdre non convexe.

\subsubsection{La fonction \emph{unfold\_tree()}}

Il peut être utile de récupérer l'arbre fabriqué par la fonction \textbf{unfold\_polyhedron} afin d'éviter de recalculer celui-ci plusieurs fois, lors d'une animation par exemple. La fonction \textbf{unfold\_tree(tree,opening,num)} permet aussi de déplier le polyèdre. L'argument\emph{tree} est l'arbre fourni par la fonction \emph{unfold\_polyhedron}, l'argument optionnel \emph{opening} est un nombre entre $0$ et $1$ qui représente le taux d'ouverture ($1$ par défaut), l'argument optionnel \emph{num} est le numéro de la facette que l'on souhaite ouvrir (et toute la descendance de la facette tournera de la même façon), lorsque cet argument est omis, toutes les facettes tournent.

\paragraph{Exemple d'animation :}

\begin{Luacode}
\begin{luacode*}
nbimages = 70 -- must be global
-- images creation
local g = graph3d:new{ viewdir=perspective("central",30,60), bg="gray", size={10,10}, margin={0,0,0,0} }
-- declarations
require 'luadraw_polyhedrons'
require 'luadraw_cvx_polyhedra_nets'
local p = linspace(0,1,36)
local T = linspace(0,360,nbimages+1)
local P = dodecahedron(Origin, -2*vecI)
local net = unfold_polyhedron(P)
local tree = net.tree
-- create the image number k, this function must be global
function makeframe(k) 
    local r = k
    if k > 36 then r = 72-k end
    local P1 = rotate3d( unfold_tree(tree,p[r]), T[k], {Origin,vecK})
    g:Dfacet(P1, {color="Crimson", edgecolor="Gold", edgewidth=8})
    -- send image number k
    g:Sendtotex()  -- send the tikzpicture to TeX
    g:Cleargraph()  
end
\end{luacode*}
\end{Luacode}

Le code \TeX\ (avec le paquet \emph{animate}) :

\begin{TeXcode}
\def\nb{\directlua{tex.print(nbimages)}}
\def\makeframe#1{\directlua{makeframe(#1)}}%

\begin{animateinline}[poster=first,controls,loop]{8}
\multiframe{\nb}{ik=1+1}{%
\makeframe{\ik}%
}%
\end{animateinline}
\end{TeXcode}

\begin{luacode*}
nbimages = 70
-- images creation
local g = graph3d:new{ viewdir=perspective("central",30,60), bg="gray", size={10,10}, margin={0,0,0,0} }
-- declarations
require 'luadraw_polyhedrons'
require 'luadraw_cvx_polyhedra_nets'
local p = linspace(0,1,36)
local T = linspace(0,360,nbimages+1)
local P = dodecahedron(Origin, -2*vecI)
local net = unfold_polyhedron(P)
local tree = net.tree
-- create the image number k, this function must be global
function makeframe(k) -- do not modify this line
    local r = k
    if k > 36 then r = 72-k end
    local P1 = rotate3d( unfold_tree(tree,p[r]), T[k],{Origin,vecK})
    g:Dfacet(P1, {color="Crimson", edgecolor="Gold", edgewidth=8})
    -- send image number k
    g:Sendtotex()  -- do not modify
    g:Cleargraph() -- do not modify
end
\end{luacode*}

\def\nb{\directlua{tex.print(nbimages)}}%
\def\makeframe#1{\directlua{makeframe(#1)}}%

Le résultat :

\begin{minipage}{0.9\textwidth}
\begin{center}
\captionof{figure}{Dépliage d'un dodécaèdre}
\begin{animateinline}[poster=first,controls,loop]{8} %palindrome
\multiframe{\nb}{ik=1+1}{%
\makeframe{\ik}%
}%
\end{animateinline}
\end{center}
\end{minipage}

\subsection{Le module \emph{luadraw\_fields}}

Ce module contient les fonctions et méthodes qui ont été données à la fin du chapitre $1$ pour le dessin des champs de vecteurs et des champs de gradient. On y trouve:

\begin{itemize}
    \item La fonction \textbf{field(f,x1,x2,y1,y2,grid,length)} qui renvoie le champ de vecteurs (liste de segments). L'argument \emph{f} est une fonction $f\colon(x,y)\mapsto f(x,y))\in\mathbf R^2$ ($f(x,y)$ est une liste de deux réels). Le champ est calculé sur le pave $[x_1;x_2]\times[y_1;y_2]$. L'argument \emph{grid} vaut par défaut \emph{\{25,25\}}, c'est le nombre de subdivisions de l'intervalle $[x_1;x_2]$ et celui de l'intervalle $[y_1;y_2]$. L'argument \emph{length} permet d'imposer la longueur des vecteurs (tous les vecteurs ont la même longueur), par défaut une longueur est calculée en fonction des pas sur chacun des deux axes.
    
    \item La méthode \textbf{g:Dvectorfield(f,options)} fait le dessin du champ de vecteurs associé à la fonction $f$. L'argument \emph{options} est une table dont les champs définissent les paramètres, qui sont (avec leur valeur par défaut):
        \begin{itemize}
            \item \opt{view = fenêtre par défaut}, liste de la forme \{x1,x2,y1,y2\} permettant de définir le pavé $[x_1;x_2]\times [y_1;y_2]$. Par défaut c'est la fenêtre choisie lors de la création du graphe.
            \item \opt{grid = \{25,25\}}, liste de deux entiers qui permet de définir les subdivisions suivant les deux axes.
            \item \opt{length = }, permet d'imposer la longueur des vecteurs, par défaut une longueur est calculée en fonction des pas sur chacun des deux axes.
            \item \opt{draw\_options = ""}, chaîne contenant les options de dessin qui seront passées à tikz.
        \end{itemize}
        
    \item La méthode \textbf{g:Dgradientfield(f,options)} fait le dessin du champ de gradient associé à la fonction \textbf{numérique} $f\colon(x,y)\mapsto f(x,y)\in \mathbf R$. L'argument \emph{options} est identique à celui de la méthode \emph{Dvectorfield}.
\end{itemize}

Un exemple de ces deux méthodes a déjà été donné page \pageref{fields}.


\subsection{Le module \emph{luadraw\_shadedforms}}

Ce module permet de dessiner des lignes polygonales ou de remplir une forme en utilisant un gradient de couleurs.
Ce module charge l'extension \emph{luadraw\_palette}.

\subsubsection{Dshadedpolyline}

La méthode \textbf{g:Dshadedpolyline(L, palette, options)} permet de dessiner une ligne polygonale 2d (\emph{L}) avec un dégradé de couleurs en fonction de la méthode de calcul et de la \emph{palette} choisies. \emph{L} est une liste de nombres complexes ou une liste de listes de nombres complexes, \emph{palette} est une liste de couleurs, chaque couleur est elle-même une liste de trois nombres entre $0$ et $1$ représentant les trois composantes: rouge, vert et bleu de la couleur. L'argument \emph{options} est une table dont les champs définissent les paramètres, qui sont (avec leur valeur par défaut):
\begin{itemize}
    \item \opt{values = "x"}, pour chaque point de \emph{L} on calcule une valeur numérique qui permettra de déterminer la couleur de ce point dans la palette choisie. C'est l'option \emph{values} qui détermine le mode de calcul, cette option peut être égale à : 
        \begin{itemize}
            \item "x" (valeur par défaut), dans ce cas pour chaque point de \emph{L} la valeur sera l'abscisse. 
            \item "y", dans ce cas pour chaque point de \emph{L} la valeur sera l'ordonnée. 
            \item une fonction $f\colon(x,y)\mapsto f(x,y)\in\mathbf R$, dans ce cas chaque point $(x,y)$ de \emph{L} la valeur sera donnée par $f(x,y)$.
        \end{itemize}
    \item \opt{width = current line width}, permet de définir l'épaisseur de ligne en dixième de point (épaisseur courante par défaut).
    \item \opt{close= false}, booléen indiquant si la ligne polygonale doit être refermée ou non.
    \item \opt{clip = nil}, cette option est soit \emph{nil} (valeur par défaut), soit une table \emph{\{x1,x2,y1,y2\}}, dans le premier cas la ligne est clippée par la fenêtre 2d courante \textbf{après} sa transformation par la matrice 2d du graphe, dans le second cas la ligne est clippée par la fenêtre $[x_1,x_2]\times[y_1,y_2]$ \textbf{avant} d'être transformée par la matrice du graphe.
\end{itemize}

Cette méthode convertit \emph{L} en une succession de trapèzes qui sont ensuite remplis avec un dégradé de couleur.

\begin{demo}{Shaded polyline}
\begin{luadraw}{name=shading_polyline}
local i = cpx.I
local g = graph:new{size={10,10},bg="lightgray", margin={0,0,0,0}}
require 'luadraw_shadedforms'
-- first example diff. equation y'= x^2+y^2-1 (=f(x,y))
local x1,x2,y1,y2 = -3,3,-3,3
local A = Z(0,1/2) -- initial condition
local f = function(x,y) 
    return x^2+y^2-1
end
local S = odesolve(f, A.re, A.im, x1, x2, 150) -- S is a matrix {X,Y}
local L = {} -- to convert {X,Y} into the complex numbers list L
for k = 1, #S[1] do table.insert(L, Z(S[1][k],S[2][k])) end 
L = clippolyline(L,-2.5,2.4,y1,y2)[1] -- L is the solution curve
g:Dshadedpolyline(L, palRainbow, {values=f, width=12}) -- solution drawn with rainbow color map using function f
-- second example
L = polar(function(t) return 2*math.cos(3*t) end, -math.pi, math.pi)
local f = function(x,y) return cpx.abs(Z(x,y)) end -- here the value will be the modulus
g:Shift(2-2.5*i)
g:Dshadedpolyline(L, palAutumn, {values=f, width=12})
-- third example
g:Shift(-4.5+5*i)
g:Dshadedpolyline( polyreg(0,2,8), palGasFlame, {values="y", width=24, close=true})
g:Show()
\end{luadraw}
\end{demo}

\subsubsection{Dcolorbar}

La méthode \textbf{g:Dcolorbar(A,pal,options)} permet de dessiner un rectangle avec un gradient de couleurs à partir d'une palette, avec éventuellement une graduation. L'argument \emph{A} est un nombre complexe, c'est le point de référence pour la construction du rectangle. L'argument \emph{pal} est une palette de couleurs (liste de listes de la forme \{r,g,b\} avec r, g et b entre $0$ et $1$). L'argument \emph{options} est une table dont les champs définissent les paramètres, qui sont (avec leur valeur par défaut):
\begin{itemize}
    \item \opt{minmax = \{0,1\}}, liste contenant la valeur minimale (qui sera affectée à la première couleur de la palette) et la valeur maximale (qui sera affectée à la dernière couleur de la palette), ainsi, à toute valeur numérique entre \emph{min} et \emph{max} correspond une couleur de la palette.
    \item \opt{dir = cpx.I}, direction du grand côté du rectangle (ce vecteur est automatiquement normalisé), par défaut le rectangle est donc vertical.
    \item \opt{length = 8}, longueur du rectangle.
    \item \opt{width = 0.5}, largeur du rectangle. Les sommets du rectangle sont :\par
    \hfil\verb|A, A+length*dir, A+length*dir+width*cpx.I*dir, A+width*cpx.I*dir|\hfil\par
    \item \opt{values = 0}, cette option permet de définir soit le nombre de valeurs numériques affichées équiréparties dans l'intervalle \emph{minmax} (aucune par défaut), soit la liste des valeurs numériques affichées (dans ce cas \emph{values} doit être une liste de valeurs numériques comprises dans l'intervalle \emph{minmax}).
    \item \opt{addvalues = nil}, cette option permet de définir une liste des valeurs numériques à afficher en plus des valeurs \emph{min} et \emph{max}. Cette option prime sur la précédente.
    \item \opt{digits = 2}, nombre de décimales pour les affichages numériques. 
    \item \opt{labelpos = "E"}, permet de positionner les labels par rapport aux points d'ancrage ("N", "NE", "E", "SE", "S", "SW", "W", "NW"). Les labels sont positionnés le long de l'axe \emph{(A, dir)}.
\end{itemize}

\begin{demo}{Color bars}
\begin{luadraw}{name=Dcolorbar}
local g = graph:new{size={10,10}, bbox=false}
g:Labelsize("small")
require 'luadraw_shadedforms'
g:Dcolorbar(Z(-4,-4), palRainbow)
g:Dcolorbar(Z(-2,-4), palGasFlame, {minmax={0,7},values=8})
g:Dcolorbar(Z(-1,1), palAutumn, {dir=1,length=6,width=1,addvalues={0.25,0.5,0.75},labelpos="S"})
g:Dcolorbar(Z(-1,-1), palViridis, {dir=1,length=6,width=-1,addvalues={0.25,0.5,0.75},labelpos="N"})
g:Dlabel("No value", Z(-4.25,-4),{pos="S"},
  "\\parbox{1.95cm}{minmax=\\{0,7\\}\\\\values=8}", Z(-2.25,-4), {},
  "dir=1, length=6, width=1", Z(2,2), {pos="N"},
  "dir=1, length=6, width=-1", Z(2,-2),{pos="S"})
g:Show()
\end{luadraw}
\end{demo}

\subsubsection{Dshadedrectangle}

\noindent\textbf{NB}: l'utilisation de cette méthode nécessite la librairie \emph{shadings}.

La méthode \textbf{g:Dshadedrectangle(x1,x2,y1,y2,pal,options)} permet de remplir le rectangle [x1;x2]x[y1;y2] avec un gradient de couleurs extraites de la palette \emph{pal}. Chaque point $(x,y)$ du rectangle a une couleur issue de la palette, calculée à partir d'une valeur $f(x,y)$ où $f$ est une fonction à valeurs numériques définie sur le rectangle. L'argument \emph{options} est une table dont les champs définissent les paramètres, qui sont (avec leur valeur par défaut):
\begin{itemize}
    \item \opt{values = function(x,y) return cpx.abs(Z(x,y)) end}, cette option définit la fonction $f$ utilisée pour calculer la couleur de chaque point. La valeur maximale de $f$ sur le rectangle correspondra à la dernière couleur de la palette, et la valeur minimale de $f$ correspondra à la première couleur de la palette.
    \item \opt{grid = \{15,15\}}, cette option définit le nombre de subdivisions pour l'intervalle [x1;x2] et pour l'intervalle [y1;y2]. Plus la subdivision est fine plus l'affichage sera long...
    \item \opt{bar = "none"}, permet d'ajouter ou non une légende en faisant appel à la méthode \emph{Dcolorbar}, cette option peut valoir : "none", ou "right", ou "bottom", ou "left" ou "top".
    \item \opt{bardist = 1}, distance entre le rectangle et la légende s'il y en a une.
    \item \opt{baroptions = \{\}}, liste d'options pour la méthode \emph{Dcolorbar} s'il y a une légende.
    \item \opt{out = nil}, si on affecte une variable de type liste à ce paramètre \emph{out}, alors la méthode ajoute à cette liste les deux valeurs \emph{min} et \emph{max} de la fonction $f$ (ce qui permet de récupérer éventuellement ces deux valeurs).
\end{itemize}

\begin{demo}{Shaded rectangle}
\begin{luadraw}{name=Dshadedrectangle}
local g = graph:new{window={-4,6,-5.5,5.5}, size={10,10}, bbox=false}
require 'luadraw_shadedforms'
require 'luadraw_fields'
g:Labelsize("small")
local f = function(x,y) return {math.cos(x+y), x} end -- vector field
local Nf = function(x,y) local A = f(x,y); return cpx.abs(Z(A[1],A[2])) end -- modulus of f(x,y)
g:Dshadedrectangle(-4,4,-5,5, palPicnic, {values=Nf, bar="right", baroptions={addvalues={0.5,1.5,2.5,3.5}}})
g:Dvectorfield(f,{view={-4,4,-5,5},draw_options="-stealth"})
g:Dgradbox({Z(-4,-5),Z(4,5),1,1}, {title="vector field $f(x,y)=(\\cos(x+y),x)$"})
g:Show()
\end{luadraw}
\end{demo}

\subsubsection{Dshadedregion}

La méthode \textbf{g:Dshadedregion(apath,pal,options)} permet de remplir la région définie par le chemin \emph{apath} avec un gradient de couleurs extraites de la palette \emph{pal}. Cette méthode utilise la précédente (\emph{Dshadedrectangle}) sur le rectangle définie par la boîte englobante du chemin. Chaque point $(x,y)$ de ce rectangle a une couleur issue de la palette, calculée à partir d'une valeur $f(x,y)$ où $f$ est une fonction à valeurs numériques définie sur ce rectangle. Le dessin est clippé par le chemin. L'argument \emph{options} est identique à celui de la méthode précédente \emph{Dshadedrectangle}.

\begin{demo}{Shaded region}
\begin{luadraw}{name=Dshadedregion}
local g = graph:new{window={-4.5,6,-4.5,5}, size={10,10},bg="lightgray", bbox=false}
g:Labelsize("small")
require 'luadraw_shadedforms'
local L1, L2 = -2, 2
local f = function(x,y) 
    local z = Z(x,y)
    return (cpx.abs(z-L1)-cpx.abs(z-L2))^2
end
g:Dshadedregion({4,0,4,3,"e"}, getPal("Grays",{reverse=true}), {values=f, grid={20,20}})
g:Show()
\end{luadraw}
\end{demo}


\subsection{Le module \emph{luadraw\_povray}}

Ce module permet de créer des fichiers sources (relativement basiques) pour le logiciel \emph{Pov-Ray} et de les compiler à la volée si ce logiciel est bien installé sur votre système et que son chemin d'accès est connu. Une fois créée, l'image (format \emph{png}) peut être incluse automatiquement dans le graphique en cours, ce qui permet de dessiner dessous et dessus. L'image s'insérera parfaitement, c'est à dire que les repères 3D du graphique et de l'image seront parfaitement identiques, à condition d'être en mode de \textbf{projection orthographique}. Les fichiers sources et images sont créés dans le dossier de travail de \emph{luadraw}. Les fichiers sources peuvent être évidemment compilés à part par l'utilisateur, les options à transmettre à Pov-Ray sont écrites en commentaires au début du source.
Le source est en trois parties : un préambule, la déclaration des objets, et le rendu des objets.

\subsubsection{Avant la création des objets}

Il faut \textbf{obligatoirement initialiser} le dessin Pov-Ray avec la méthode : \par \hfil\textbf{g:Pov\_new(options)}.\hfil\par
 L'argument \emph{options} est une table dont les champs sont (avec leur valeur par défaut):
\begin{itemize}
    \item \opt{bg = ""}, cette option permet de définir le fond, soit c'est une chaîne vide (valeur par défaut) alors le fond sera transparent (indispensable si on doit dessiner sous l'image), soit c'est une chaîne non vide et alors ce doit un nom de couleur connu de Pov-Ray, soit c'est une table de la forme \{r,g,b\} représentant une couleur au avec les valeurs $r$, $g$ et $b$ entre $0$ et $1$.
    \item \opt{shadow = true}, ce booléen indique si les objets doivent créer une ombre ou pas (ce booléen peut être modifié localement pour chaque objet).
    \item \opt{imagescale = 1}, cette option permet de modifier la taille de l'image \emph{png} produite, pour des valeurs supérieures à $1$ cela augmente évidemment son poids.
    \item \opt{param = "-V +A +FN"}, ce sont les paramètres de base transmis à Pov-Ray, à ceux-ci s'ajouteront la largeur et la hauteur de l'image, ainsi que l'option "+UA" si le fond doit être transparent.
    \item \opt{pov\_cmd =}, nom de la commande pour exécuter Pov-Ray, sous unix la valeur par défaut est \emph{"povray"}, sous windows la valeur par défaut est \emph{"pvengine64.exe"}.
    \item \opt{win\_param\_ext = "/RENDER /EXIT"}, paramètres supplémentaires qui ne concernent que windows.
\end{itemize}

On peut ensuite demander à Pov-Ray d'inclure certains fichiers \emph{*.inc} avec la méthode : \par
\hfil\textbf{g:Pov\_include("file1.inc,"file2.inc",...)},\hfil\par par exemple : \verb|g:Pov_include("textures.inc", "colors.inc")|, ces deux fichiers sont normalement distribués avec Pov-Ray, le premier définit des textures, le second des couleurs. Par défaut, aucune inclusion n'est faite.


\subsubsection{Création des objets}

Les objets sont créés à partir de méthodes sur le format \textbf{g:Pov\_<command>(<data>,options)}. Chaque objet est d'abord déclaré dans le source Pov-Ray en portant un nom (comme une variable), puis cet objet est ensuite "rendu" dans la troisième partie du source avec une texture définie à partir des options.

L'argument \emph{options} est une table dont les champs définissent les paramètres de l'objet, voici les \textbf{paramètres communs à tous les objets} avec leur valeur par défaut:
\begin{itemize}
    \item \opt{name = "object<num>"}, chaîne de caractères représentant le nom de l'objet créé, par défaut c'est le mot "object" suivi d'un numéro (ordre d'apparition). Donner un nom est utile lorsqu'on a besoin de réutiliser l'objet par la suite.
    \item \opt{shadow = true}, booléen indiquant si l'objet crée une ombre.
    \item \opt{render = true}, booléen indiquant si l'objet doit être affiché. On peut ne pas vouloir afficher un objet lorsque celui-ci intervient dans la construction d'un autre objet par exemple.
    \item Options définissant la texture de base, celle-ci est composée d'un \emph{pigment} (couleur + opacité) et d'un \emph{finish} (ambient + diffuse + phong):
        \begin{itemize}
            \item \opt{color = White}, cette option peut être soit une table au format \{r,g,b\} (avec $r$, $g$ et $b$ entre $0$ et $1$), soit une chaîne de caractères, auquel cas celle-ci doit représenter une couleur connue de Pov-Ray, ou bien une texture définie uniquement avec un \emph{pigment} (par exemple \verb|color="Blue_Sky3"|, ce nom est défini dans le fichier \emph{textures.inc}).
            \item \opt{opacity = 1}, nombre entre $0$ et $1$ définissant l'opacité de l'objet.
            \item \opt{ambient = 0.35}, \opt{diffuse = 0.8} et \opt{phong = 0.5} : paramètres définissant le \emph{finish}.
            \item \opt{mytexture = nil}, ce paramètre permet définir sous forme d'une chaîne sa propre texture, ou bien de donner le nom d'une texture déjà connue de Pov-Ray, dans ce cas les paramètres précédents ne sont pas pris en compte.
        \end{itemize}
    \item \opt{matrix = nil}, matrice de transformation 3d qui s'appliquera localement à l'objet. La matrice 3d de transformation globale du graphique est également prise en compte.
    \item \opt{clipbox = nil}, cette option permet de définir une liste (table) d'objets pour clipper celui qui est en cours de construction, ces objets peuvent être : soit un objet déjà créé, dans ce cas on donne son nom sous forme d'une chaîne, soit une boite, dans ce cas on donne une table de la forme \emph{\{M(xinf,yinf,zinf), M(xsup,ysup,zsup)\}} (cela représente une diagonale de la boîte), soit une sphère, dans ce cas on donne une table de la forme \emph{\{center,radius\}}, où \emph{center} est un point 3d et \emph{radius} un nombre positif.
    \item \opt{clipplane = nil}, cette option permet de définir une liste (table) de plans pour clipper l'objet en cours de construction, chaque plan doit être de la forme \emph{\{A,n\}} où \emph{A} est un point du plan (point 3d) et \emph{n} un vecteur normal au plan. Seule la partie de l'objet se situant dans le demi-espace contenant \emph{n} est conservée.
\end{itemize}

\subsubsection{Liste des objets prédéfinis}

Voici la liste des objets que l'on peut dessiner avec les méthodes correspondantes :
\begin{itemize}
    \item \textbf{Surfaces implicites} d'équation $f(x,y,z)=0$. C'est la méthode :\par
    \hfil \textbf{g:Pov\_implicit( povfunction, luafunction, options)}\hfil
    
    L'argument \emph{povfunction} est une chaîne contenant l'expression de $f(x,y,z)$, Pov-ray connaît les fonctions mathématiques, il faut cependant savoir que la fonction puissance est la fonction \emph{pow}: $x\mapsto \mathrm{pow}(x,n)$, et que Pov-Ray ne gère pas les erreurs de calculs comme la division par zéro par exemple.
    
    Les options sont celles qui ont déjà été données, plus l'option spécifique : \opt{containedby = }, celle-ci indique dans quelle boîte (ou sphère) seront faits les calculs, par défaut cette boîte est la fenêtre 3d du graphique en cours. Une boîte est une table de la forme \emph{\{M(xinf,yinf,zinf), M(xsup,ysup,zsup)\}} (cela représente une diagonale de la boîte), une sphère est une table de la forme \emph{\{C,r\}}, où \emph{C} est le centre (point 3d) et \emph{r} le rayon. Exemple :
    \begin{Luacode}
    local f = function(x,y,z) return x^2+y^2+z^2 - 1 end
    local r = 1.1
    g:Pov_implicit("x*x+y*y+z*z-1", f, {color=SteelBlue, containedby={M(-r,-r,-r), M(r,r,r)}})
    \end{Luacode}

    \item \textbf{Surfaces paramétrées} par $(u,v)\mapsto (x(u,v), y(u,v), z(u,v))$. C'est la méthode :\par
    \hfil \textbf{g:Pov\_surface( xfunc, yfunc, zfunc, u1, u2, v1, v2, options)}\hfil
    
    Les arguments \emph{xfunc}, \emph{yfunc} et \emph{zfunc} sont trois chaînes contenant respectivement les expressions $x(u,v)$, de $y(u,v)$ et de $z(u,v)$.
    Les arguments \emph{u1} et \emph{u2}, respectivement \emph{v1} et \emph{v2},  définissent les bornes de l'intervalle pour le paramètre $u$, respectivement pour le paramètre $v$.
    Les options sont celles qui ont déjà été données, plus deux options spécifiques : 
    \begin{itemize}
        \item \opt{containedby = }, celle-ci indique dans quelle boîte (ou sphère) seront faits les calculs, par défaut cette boîte est la fenêtre 3d du graphique en cours. Une boîte est une table de la forme \emph{\{M(xinf,yinf,zinf), M(xsup,ysup,zsup)\}} (cela représente une diagonale de la boîte), une sphère est une table de la forme \emph{\{C,r\}}, où \emph{C} est le centre (point 3d) et \emph{r} le rayon.
        \item \opt{max\_grad = nil}, valeur numérique (optionnelle) permettant d'optimiser les calculs, voici ce que dit l'aide de Pov-ray sur ce nombre :
        \begin{small}
        \begin{verbatim}
The max_gradient is the maximum magnitude of all six partial derivatives 
over the specified ranges of u and v.
Take dx/du, dx/dv, dy/du, dy/dv, dz/du, and dz/dv and calculate them over 
the entire range.
The max_gradient should be at least the maximum (absolute value) of all of those values.
Choosing a too small of a value will create holes or artifacts in the object.
        \end{verbatim}
        \end{small}
    \end{itemize}
     Exemple :
    \begin{Luacode}
    local pi = math.pi
    local r = 1.1
    g:Pov_surface("cos(u)*sin(v)", "sin(u)*sin(v)", "cos(v)",-pi,pi,0,pi, {color=SteelBlue, containedby={M(-r,-r,-r), M(r,r,r)}})
    \end{Luacode}
    Remarque : on peut mettre \emph{"pi"} à la place de \emph{pi} car cette constante est définie dans Pov-Ray. D'autre part, sur cet exemple, on aurait pu ajouter l'option \emph{grad\_max=1} compte tenu du paramétrage.    

    \item \textbf{Polyèdre ou liste de facettes}. C'est la méthode: \par
    \hfil\textbf{g:Pov\_facet(F,options)}\hfil\par
    L'argument \emph{F} est soit un polyèdre, soit une liste de facettes. Les options sont les options communes, plus les options spécifiques suivantes (avec les valeurs par défaut): 
    \begin{itemize}
        \item \opt{edge = false}, booléen indiquant si les arêtes doivent être dessinées.
        \item \opt{edgestyle = current line style}, style des arêtes.
        \item \opt{edgecolor = Black}, couleur des arêtes.
        \item \opt{edgewidth = current line width}, épaisseur des arêtes.
        \item \opt{hidden = false}, booléen indiquant si les arêtes cachées doivent être dessinées.
        \item \opt{hiddenstyle = Hiddenlinestyle}, style des arêtes cachées.
    \end{itemize}
    Exemple:
    \begin{Luacode}
    local T1 = tetra(M(-1,-1,-1), 3*vecI, 3*vecJ, M(1,1,3))
    g:Pov_facet(T1, {color=SteelBlue, edge=true, hidden=true})
    \end{Luacode}
    Remarque: le dessin des arêtes cachées n'est pas toujours optimal, il peut être parfois plus intéressant de les dessiner avec tikz par dessus l'image.
    
    
    \item \textbf{Ligne polygonale}. C'est la méthode:\par
    \hfil\textbf{g:Pov\_polyline(L,options)}\hfil\par
    L'argument \emph{L} est soit une liste de points 3d, soit une liste de listes de points 3d. Les options sont les options communes, plus les options spécifiques suivantes (avec les valeurs par défaut): 
        \begin{itemize}
        \item \opt{style = current line style}, style de la ligne.
        \item \opt{width = current line width}, épaisseur de la ligne.
        \item \opt{close = false}, booléen indiquant si la ligne doit être refermée.
        \item \opt{arrows = 0}, trois valeurs possibles: soit $0$ (pas de flèche),  soit $1$ (une flèche à la fin), soit $2$ (une flèche au début et à la fin).
        \item \opt{arrowscale = 1}, permet de jouer sur la taille des flèches.
        \item \opt{hidden = false}, booléen indiquant si les parties cachées doivent être dessinées.
        \item \opt{hiddenstyle = Hiddenlinestyle}, style des parties cachées.
    \end{itemize}
    Exemple: dessin des axes
    \begin{Luacode}
    g:Pov_polyline({{-5*vecI,5*vecI},{-5*vecJ,5*vecJ},{-5*vecK,5*vecK}}, {arrows=1,width=8})
    \end{Luacode}
    
    \item \textbf{Points 3d}. C'est la méthode:\par
    \hfil\textbf{g:Pov\_dots(L,options)}\hfil\par
    L'argument \emph{L} est une liste de points 3d. Les options sont les options communes, plus les options spécifiques suivantes (avec les valeurs par défaut): 
        \begin{itemize}
        \item \opt{style = "ball"}, deux styles possibles: "ball" (sphère) ou bien "box" (boite aux faces parallèles à la fenêtre 3d).
        \item \opt{dotscale = 1}, permet de jouer sur la taille des points.
    \end{itemize} 
    
% à traduire    
    \item \textbf{Un plan}. C'est la méthode:\par
        \hfil\textbf{g:Pov\_plane(P,options)}\hfil\par
    L'argument \emph{P} est une table de la forme \emph{\{A,n\}} où \emph{A} est un point du plan $P$ (point 3d) et \emph{n} un vecteur normal au plan. Le plan est automatiquement clippé par la fenêtre 3d. Les options sont les options de \emph{Pov\_facet}, plus l'option spécifique \opt{scale = 1}.
    
    \item \textbf{Un cercle}. C'est la méthode:\par
        \hfil\textbf{g:Pov\_circle(A,R,N,options)}\hfil\par
    Elle dessine le cercle de centre \emph{A}, de rayon \emph{R}, l'argument \emph{N} désigne un vecteur normal au plan du cercle. Ce sont les options communes.
    
     \item \textbf{Les axes}. C'est la méthode:\par
        \hfil\textbf{g:Pov\_axes(O,options)}\hfil\par
    Elle trace les axes en prenant le point $O$ comme point d'intersection. Les options sont les mêmes que pour \emph{Pov\_polyline}. Il n'y a ni graduations, ni légende.
    
    \item \textbf{Les solides de base}. Ce sont les méthodes:
        \begin{itemize}
            \item \textbf{g:Pov\_sphere(center, radius, options)}, qui dessine la sphère de centre  \emph{center} (point3d) et de rayon \emph{radius}. Ce sont les options communes.

            \item \textbf{g:Pov\_torus(center, R, r, N, options)}, qui dessine le tore de centre \emph{center} (point3d) et de grand rayon \emph{R}, de petit rayon \emph{r}, dans le plan normal au vecteur \emph{N}. Ce sont les options communes.
            
            \item \textbf{g:Pov\_cylinder(A, R, B, options)}, qui dessine le cylindre d'axe \emph{(AB)} allant de \emph{A} jusqu'à \emph{B} (points 3d), et de rayon \emph{R}. Ce sont les options communes plus l'option spécifique \opt{hollow = false} qui indique si le cylindre est creux ou non.

            \item \textbf{g:Pov\_cone(A,R,B,r,options)}, qui dessine le cône d'axe \emph{(AB)} allant de \emph{A} jusqu'à \emph{B} (points 3d), et de rayon \emph{R} à l'extrémité \emph{A}, et de rayon \emph{r} à l'extrémité \emph{B}. Le rayon \emph{r} est optionnel et vaut $0$ par défaut, dans ce cas, \emph{B} est le sommet du cône. Ce sont les options communes plus l'option spécifique \opt{hollow = false} qui indique si le cône est creux ou non.
            \item \textbf{g:Pov\_box(A,B,options)}, qui dessine une boîte dont les faces sont parallèles à celles de la fenêtre 3d du graphique, les points 3D \emph{A} et \emph{B} représente une diagonale de cette boîte, plus précisément \emph{A=M(xinf, yinf, zinf)} et \emph{B=M(xsup, ysup, zsup)}. Ce sont les options communes.
        \end{itemize}

    \item \textbf{CSG géométrie}. Ce sont les méthodes suivantes (pour chacune d'elles les options sont les options communes):
        \begin{itemize}
            \item \textbf{g:Pov\_union(list, options)}, où \emph{list} est une liste d'objets Pov-Ray, ces objets peuvent être, soit le nom d'un objet déjà créé, soit une commande Pov-Ray sous forme de chaîne. Le résultat sera considéré comme un seul objet.
            
            \item \textbf{g:Pov\_intersection(list, options)}, où \emph{list} est une liste d'objets Pov-Ray, ces objets peuvent être, soit le nom d'un objet déjà créé, soit une commande Pov-Ray sous forme de chaîne. Le résultat est la partie commune à ces objets.
            
            \item \textbf{g:Pov\_merge(list, options)}, où \emph{list} est une liste d'objets Pov-Ray, ces objets peuvent être, soit le nom d'un objet déjà créé, soit une commande Pov-Ray sous forme de chaîne. Cette commande fonctionne comme l'union, mais supprime les surfaces internes (contrairement à l'union), ceci est utile en cas de transparence.
            
            \item \textbf{g:Pov\_difference(list, options)}, où \emph{list} est une liste \textbf{deux} objets Pov-Ray, ces objets peuvent être, soit le nom d'un objet déjà créé, soit une commande Pov-Ray sous forme de chaîne. Le résultat la différence : objet1 moins objet2.
        \end{itemize}
        
    \item \textbf{Écrire directement dans le source}, avec les méthodes suivantes:
        \begin{itemize}
            \item \textbf{g:Pov\_comment(comment)}, qui écrit la chaîne \emph{comment} dans le source sous forme de commentaire.
            \item \textbf{g:Pov\_special(code)}, qui écrit telle quelle la chaîne \emph{code} dans le source, ce doit donc être du code Pov-Ray. Il faut savoir que le point 3d qui se note \emph{M(x,y,z)} dans \emph{luadraw}, s'écrit dans le code Pov-Ray: \emph{<-x,y,z>}, le repère Pov-Ray n'est donc pas notre repère usuel et il est indirect...
        \end{itemize}
\end{itemize}

\subsubsection{Sauvegarde, exécution, inclusion}

\begin{itemize}
    \item \textbf{Sauvegarde et exécution}. Lorsque tous les objets ont été créés, la sauvegarde et l'exécution du fichier par Pov-Ray se font avec la méthode: \par
    \hfil \textbf{g:Pov\_exec(filename)} \hfil\par
    L'argument \emph{filename} doit être un nom de fichier sans chemin ni extension, mais il est optionnel, par défaut c'est le nom du graphique en cours qui est utilisé. Le fichier créé portera l'extension \emph{pov} et sera enregistré dans le dossier de travail de \emph{luadraw} (celui-ci est contenu dans la variable \emph{cachedir}). La commande utilisée pour l'exécution s'affiche dans le terminal, ainsi que les retours du logiciel Pov-Ray, ce qui permet de voir s'il a rencontré une erreur. La construction de l'image apparaît à l'écran, mais la fenêtre se ferme dès la fin du rendu. L'image porte le même nom que le source, sauf bien sûr l'extension qui est \emph{png} au lieu de \emph{pov}.
    
    \textbf{NB} : l'exécution de Pov-Ray nécessite une compilation du document avec l'option \emph{-shell-escape} ou \emph{-enable-write18}. Une fois l'image obtenue, l'option n'est plus nécessaire s'il n'y a pas eu de modification de celle-ci.
    
    \item \textbf{Enregistrement seul}.  Celui-ci se fait avec la méthode :\par
\hfil \textbf{g:Pov\_save(filename)} \hfil\par
Avec les mêmes remarques que précédemment pour l'argument \emph{filename}.

    \item \textbf{Inclusion de l'image}. Une fois celle-ci obtenue, l'image peut être incluse dans le graphique avec la méthode : \par
    \hfil \textbf{g:Pov\_show(filename)} \hfil\par
    Si l'argument \emph{filename} n'est pas précisé alors il s'agit du nom du graphique en cours, sinon \emph{filename} doit être un nom complet de fichier image (avec extension). L'inclusion se fait avec \verb|\includegraphics[]{filename}|.
\end{itemize}

\subsubsection{Exemples}

\paragraph{Intersection de deux surfaces implicites}

\begin{demo}{Intersection de deux surfaces implicites}
\begin{luadraw}{name=intersection_surf}
local g = graph3d:new{window3d={0,1,0,1,0,2}, window={-0.25,1.5,-0.5,2.25}, size={10,10,0}, viewdir={-50,60}}
local sqrt = math.sqrt
require "luadraw_povray"
local f = function(x,y,z) return x^3+y^3-z end
local h = function(x,y,z) return (x*sqrt(1-y^2)+y*sqrt(1-x^2))^3-z end
local L = implicit(function(x,y) return f(x,y,0)-h(x,y,0) end,0.01,1,0.01,1,{25,25})
L = map(function(z) return M(z.re,z.im,z.re^3+z.im^3) end, L[1])  -- intersection curve
-- using povray
g:Pov_new()
g:Pov_implicit("pow(x,3)+pow(y,3)-z", f, {color=SteelBlue})
g:Pov_implicit("z-pow(x*sqrt(1-y*y)+y*sqrt(1-x*x),3)", h, {color=Crimson, containedby={M(0,0,0),M(0.999,0.999,2)}})
g:Pov_exec()
-- drawing
g:Dboxaxes3d({grid=true, gridcolor="gray",fillcolor="lightgray",xyzstep=0.5, drawbox=true})
g:Pov_show() --Pov-Ray image
g:Dpolyline3d(L, "line width=1.2pt,dotted,Navy") --we draw the curve over the image
local d = 0.1
g:Dsquare(Z(-0.25,2.25), Z(-0.25,2.25-d),1,"draw=none,fill=Crimson")
g:Dsquare(Z(-0.25,2.25-2*d), Z(-0.25,2.25-3*d),1,"draw=none,fill=SteelBlue")
g:Dlabel("$z=(x\\sqrt{1-y^2}+y\\sqrt{1-x^2})^3$", Z(-0.25+d,2.25-d/2) , {pos="E"},
    "$z=x^3+y^3$", Z(-0.25+d,2.25-5*d/2),{})
g:Show()
\end{luadraw}
\end{demo}


\paragraph{Cercles de Villarceau}

\begin{demo}{Cercles de Villarceau}
\begin{luadraw}{name=Villarceau_circles, exec=true}
local g = graph3d:new{window={-6.5,6.5,-5,5},margin={0,0,0,0}, size={10,10}, viewdir={20,65}}
require "luadraw_povray"
local R, r = 3, 1
local N = rotate3d(vecK, math.asin(r/R)*rad, {Origin, vecJ})
local P = {Origin, -N}
-- using povray
g:Pov_new({bg=LightGray})
g:Pov_torus(Origin, R, r, vecK, {color=SteelBlue, clipplane=P})
g:Pov_plane(P,{color=SeaGreen, opacity=0.4, edge=true, scale=0.9})
g:Pov_axes(Origin,{color=Gold,arrows=1})
g:Pov_dots(Origin, {dotscale=1.5})
g:Pov_circle( M(0,r,0),R,N,{color=Crimson, width=12})
g:Pov_circle( M(0,-r,0),R,N,{color=Crimson, width=12})
g:Pov_exec()
-- drawing
g:Pov_show()
local F = g:Plane2facet(P,0.9)
g:Dpolyline3d({{-r*vecJ,-r*vecJ+vecK},{-(R+r)*vecJ,-(R+r)*vecJ+vecK}})
g:Dpolyline3d({{r*vecJ,r*vecJ+vecK},{(R+r)*vecJ,(R+r)*vecJ+vecK}})
g:Dpolyline3d({{-r*vecJ+vecK,-(R+r)*vecJ+vecK}, {r*vecJ+vecK,(R+r)*vecJ+vecK}}, "stealth-stealth")
g:Ddots3d({-r*vecJ, r*vecJ})
g:Dlabel3d("$x$",5*vecI,{pos="SW"},"$y$", 5*vecJ,{pos="SE"}, "$z$",5*vecK,{pos="N"},
"$R$", -(R/2+r)*vecJ+vecK, {}, "$R$", (R/2+r)*vecJ+vecK, {},
"bitangent plane to the torus", F[1], {pos="NW", dir={vecJ,pt3d.prod(N,vecJ)}},
"$-r$",-r*vecJ,{pos="S"}, "$r$", r*vecJ,{} )
g:Show()
\end{luadraw}
\end{demo}

\paragraph{Trous dans une demi-sphère}

\begin{demo}{Trous dans une demi-sphère}
\begin{luadraw}{name=holes_in_hemisphere, exec=true}
local g = graph3d:new{window={-5,5,-4,5}, size={10,10}, bg="lightgray"}
require "luadraw_povray"
local O, R = Origin, 4
local A, r = 2*R/3*vecJ, R/3
local P = {Origin, vecK}
local base = circle3d(A,r,vecK)[1] --circular base of the cylinder (list of 3d points)
local Cylborder = {}
for _, C in ipairs(base) do -- we project each point C of the base onto the half-sphere
    table.insert(Cylborder,C + math.sqrt(R^2-pt3d.abs2(C))*vecK)
end -- Cylborder is now the intersection between the half-sphere and the cylinder
-- using povray 
g:Pov_new()
g:Pov_sphere(Origin, R, {name="sph", clipplane=P, render=false}) -- only declaration
g:Pov_cylinder(A-vecK, r, A+R*vecK, {name="cyl1", render=false })
g:Pov_union({"cyl1", "cyl1 rotate 90*z"}, {name="cylext", render=false})
g:Pov_cylinder(A-vecK, r-0.001, A+R*vecK, {name="cyl2", render=false }) 
-- renderings
g:Pov_difference({"sph","cylext"}, {color=Blue, opacity=0.7})
g:Pov_union( {"cyl2", "cyl2 rotate 90*z"}, {color=LightBlue,opacity=0.8,clipbox="sph"})
g:Pov_axes(Origin,{color=Gold,arrows=1})
g:Pov_exec()
-- drawing
g:Dcircle3d(O,R,vecK,"line width=1.2pt"); g:Dcircle3d(A,r,vecK,"line width=1.2pt")
g:Dcircle3d(rotate3d(A,-90,{Origin,vecK}), r,vecK,"line width=1.2pt")
g:Pov_show()
g:Dpolyline3d( {Cylborder, rotate3d(Cylborder,-90,{Origin,vecK})}, "red, line width=1.2pt")
g:Dlabel3d("$x$",5*vecI,{pos="S"}, "$y$", 5*vecJ, {pos="SE"}, "$z$", 5*vecK, {pos="N"})
g:Show()
\end{luadraw}
\end{demo}
