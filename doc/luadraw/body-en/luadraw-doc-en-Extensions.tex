\section{Extensions}

\subsection{The \emph{luadraw\_polyhedrons} module}

This module is still in draft form and is expected to be expanded in the future. As its name suggests, it contains the definition of polyhedra. All numerical data comes from the \href{https://dmccooey.com/polyhedra/}{Visual Polyhedra} website.

All functions follow the same model: \textbf{<name>(C,S,all)} where $C$ is the center of the polyhedron (3D point) and $S$ is a vertex of the polyhedron (3D point). When $C$ or $S$ have the value \emph{nil}, the untransformed polyhedron (centered at the origin) is returned. The optional argument \emph{all} is a boolean. When it has the value \emph{true}, the function returns four things: \emph{P, V, E, F} where:
\begin{itemize}
    \item $P$ is the solid as a polyhedron,
    \item $V$ the list (table) of vertices,
    \item $E$ the list (table) of edges (with 3D points),
    \item $F$ the list of facets (with 3D points). Some polyhedra have multiple facet types; in this case, the returned result is of the form: \emph{P, V, E, F1, F2, ...}, where $F1$, $F2$, ... are lists of facets. This can allow them to be drawn with different colors, for example. \end{itemize}
The argument \emph{all} is set to \emph{false}, which is the default value; the function only returns the polyhedron.

Here are the solids currently contained in this module:

\begin{itemize}
    \item The Platonic solids, these solids have only one face type:
\begin{itemize}
    \item The function \textbf{tetrahedron(C,S,all)} allows the construction of a regular tetrahedron with center $C$ (3d point) and one vertex at $S$ (3d point).
    \item The function \textbf{octahedron(C,S,all)} allows the construction of an octahedron with center $C$ (3d point) and one vertex at $S$ (3d point).
    \item The function \textbf{cube(C,S,all)} allows the construction of a cube with center $C$ (3d point) and one vertex at $S$ (3d point).
    \item The function \textbf{icosahedron(C,S,all)} allows the construction of an icosahedron with center $C$ (3d point) and one vertex at $S$ (3d point).
    \item The function \textbf{dodecahedron(C,S,all)} allows the construction of a dodecahedron with center $C$ (3d point) and one vertex at $S$ (3d point).
\end{itemize}

    \item The Archimedean Solids:
\begin{itemize}
    \item The function \textbf{cuboctahedron(C,S,all)} allows the construction of a cuboctahedron with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two types of faces.
    \item The function \textbf{icosidodecahedron(C,S,all)} allows the construction of an icosidodecahedron with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two types of faces.
    \item The function \textbf{lsnubcube(C,S,all)} allows the construction of a snub cube (form 1) with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two types of faces.
    \item The function \textbf{lsnubdodecahedron(C,S,all)} allows the construction of a snub dodecahedron (form 1) with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two types of faces.
    \item The function \textbf{rhombicosidodecahedron(C,S,all)} allows the construction of a rhombicosidodecahedron with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has three types of faces.
    \item The function \textbf{rhombicuboctahedron(C,S,all)} allows the construction of a rhombicuboctahedron with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two types of faces.
    \item The function \textbf{rsnubcube(C,S,all)} allows the construction of a snub cube (shape 2) with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two types of faces.
    \item The function \textbf{rsnubdodecahedron(C,S,all)} allows the construction of a snub dodecahedron (shape 2) with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two types of faces.
    \item The function \textbf{truncatedcube(C,S,all)} allows the construction of a truncated cube with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two types of faces.
    \item The function \textbf{truncatedcuboctahedron(C,S,all)} allows the construction of a truncated cuboctahedron with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has three types of faces.
    \item The function \textbf{truncateddodecahedron(C,S,all)} allows the construction of a truncated dodecahedron with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two types of faces.
    \item The function \textbf{truncatedicosahedron(C,S,all)} allows the construction of a truncated icosahedron with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two types of faces.
    \item The function \textbf{truncatedicosidodecahedron(C,S,all)} allows the construction of a truncated icosidodecahedron with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two threes of faces.
    \item The function \textbf{truncatedoctahedron(C,S,all)} allows the construction of a truncated octahedron with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two types of faces.
    \item The function \textbf{truncatedtetrahedron(C,S,all)} allows the construction of a truncated tetrahedron with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two types of faces.
\end{itemize}

    \item Other solids:
\begin{itemize}
    \item The function \textbf{octahemioctahedron(C,S,all)} allows the construction of an octahemioctahedron with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two types of faces.
    \item The function \textbf{small\_stellated\_dodecahedron(C,S,all)} allows the construction of a small stellated dodecahedron with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has only one type of face.

\end{itemize}
\end{itemize}

\begin{demo}{Polyhedra from the \emph{luadraw\_polyhedrons} module}
\begin{luadraw}{name=polyhedrons}
local i = cpx.I
require 'luadraw_polyhedrons' -- chargement du module
local g = graph3d:new{bg="LightGray", size={10,10}}
g:Labelsize("small"); Hiddenlines = false
-- en haut à gauche 
g:Saveattr(); g:Viewport(-5,0,0,5); g:Coordsystem(-5,5,-5,5,true)
local T,S,A,F = icosahedron(Origin,M(0,2,4.5),true) 
g:Dscene3d(
    g:addFacet(F, {color="Crimson",opacity=0.8}),
    g:addPolyline(A, {color="Pink", width=8}),
    g:addDots(S) )
g:Dlabel("Icosaèdre",5*i,{})
g:Restoreattr()
-- en haut à droite
g:Saveattr()
g:Viewport(0,5,0,5); g:Coordsystem(-5,5,-5,5,true)
local T,S,A,F1,F2 = truncatedtetrahedron(Origin,M(0,0,5),true) -- sortie complète, affichage dans une scène 3d
g:Dscene3d(
    g:addFacet(F1, {color="Crimson",opacity=0.8}),
    g:addFacet(F2, {color="Gold"}),
    g:addPolyline(A, {color="Pink", width=8}),
    g:addDots(S) )
g:Dlabel("Tétraèdre tronqué",5*i,{})
g:Restoreattr()
-- en bas à gauche
g:Saveattr(); g:Viewport(-5,0,-5,0); g:Coordsystem(-5,5,-5,5,true)
local T,S,A,F1,F2,F3 = rhombicosidodecahedron(Origin,M(0,0,4.5),true)
g:Dscene3d(
    g:addFacet(F1, {color="Crimson",opacity=0.8}),
    g:addFacet(F2, {color="Gold",opacity=0.8}), g:addFacet(F3, {color="ForestGreen"}),
    g:addPolyline(A, {color="Pink", width=8}), g:addDots(S) )
g:Dlabel("Rhombicosidodécaèdre",-5*i,{})
g:Restoreattr()
-- en bas à droite
g:Saveattr(); g:Viewport(0,5,-5,0); g:Coordsystem(-5,5,-5,5,true)
local T,S,A,F1 = small_stellated_dodecahedron(Origin,M(0,0,5),true)
g:Dscene3d(
    g:addFacet(F1, {color="Crimson",opacity=0.8}),
    g:addPolyline(A, {color="Pink", width=8}),
    g:addDots(S) )
g:Dlabel("Petit dodécaèdre étoilé",-5*i,{})
g:Restoreattr()
g:Show()
\end{luadraw}
\end{demo}

\subsection{The \emph{luadraw\_spherical}} Module

This module allows you to draw a number of objects on a sphere (such as circles, spherical triangles, etc.) without having to manually manage the visible or invisible parts. Drawing is done in three steps:
\begin{enumerate}
    \item We define the characteristics of the sphere (center, radius, color, etc.)
    \item We define the objects to be added to the scene using dedicated methods.
    \item We display everything with the \textbf{g:Dspherical()} method.
\end{enumerate}
Of course, all 2D and 3D drawing methods remain usable.

\subsubsection{Global Module Variables and Functions}

\begin{itemize}
    \item Variables with their default values:
\begin{itemize}
    \item \textbf{Insidelabelcolor} = "DarkGray": Defines the color of labels whose anchor point is inside the sphere.
    \item \textbf{arrowBstyle} = "->": Type of arrow at the end of the line
    \item \textbf{arrowAstyle} = "<-": Type of arrow at the beginning of the line
    \item \textbf{arrowABstyle} = "<->": Very rarely used because most of the time the lines drawn on the sphere must be cut. \end{itemize}
    \item Functions:
\begin{itemize}
    \item \textbf{sM(x,y,z)}: returns a point on the sphere; this is the point $I$ on the sphere such that the half-line $[O,I)$ ($O$ being the center of the sphere) passes through the point $A$ with Cartesian coordinates $(x,y,z)$. It is the projection of the point $(Mx,y,z)$ onto the sphere from the center.
    \item \textbf{sM(theta,phi)}: where \emph{theta} and \emph{phi} are angles in degrees, returns a point on the sphere, whose spherical coordinates are \emph{(R,theta,phi)} where $R$ is the radius of the sphere.     \item \textbf{toSphere(A)}: returns the projection of point $A$ onto the sphere from the center.
    \item \textbf{clear\_spherical()}: removes objects that have been added to the scene, and resets the values ​​to their default values.
\end{itemize}
\end{itemize}

If the global variable \textbf{Hiddenlines} is set to \emph{true}, then the hidden parts will be drawn in the style defined by the global variable \textbf{Hiddenlinestyle}. However, this behavior can be modified using the local option \emph{hidden=true/false}.

\subsubsection{Sphere Definition}
By default, the sphere is centered at the origin, has a radius of $3$, and is orange, but this can be modified with the \textbf{g:Define\_sphere( options )} method, where \emph{options} is a table allowing you to adjust each parameter. These are as follows (with their default values ​​in parentheses):
\begin{itemize}
    \item \opt{center =} (Origin),
    \item \opt{radius =} (3),
    \item \opt{color =} ("Orange"),
    \item \opt{opacity =} (1),
    \item \opt{mode =} (\emph{mBorder}), sphere display mode (\emph{mWireframe} or \emph{mGrid} or \emph{mBorder}, see \textbf{Dsphere}),
    \item \opt{edgecolor =} ("LightGray"),
    \item \opt{edgestyle =} ("solid"),
    \item \opt{hiddenstyle =} (Hiddenlinestyle),
    \item \opt{hiddencolor =} ("gray"),
    \item \opt{edgewidth =} (4),
    \item \opt{show =} (true), to show or hide the sphere.
\end{itemize}

\subsubsection{Add a circle: g:DScircle}

The \textbf{g:DScircle(P,options)} method allows you to add a circle to the sphere. The argument \emph{P} is a table of the form $\{A,n\}$ that represents a plane (passing through $A$ and normal to $n$, two 3D points). The circle is then defined as the intersection of this plane with the sphere. The \emph{options} argument is a table with 5 fields, which are:
\begin{itemize}
    \item \opt{style =} (current line style),
    \item \opt{color =} (current line color),
    \item \opt{width =} (current line thickness in tenths of a point),
    \item \opt{opacity =} (current line opacity),
    \item \opt{hidden =} (value of \emph{Hiddenlines}),
    \item \opt{out =} (nil), if we assign a list variable to this \emph{out} parameter, then the function adds to this list the two points corresponding to the ends of the hidden arc, if any, which allows us to retrieve them without having to calculate them. \end{itemize}

\subsubsection{Add a great circle: g:DSbigcircle}

The method \textbf{g:DSbigcircle(AB,options)} adds a great circle to the sphere. The argument \emph{AB} is a table of the form $\{A,B\}$ where $A$ and $B$ are two distinct points on the sphere. The great circle is then the circle centered at the center of the sphere, and passing through $A$ and $B$. The \emph{options} argument is a table with 5 fields, which are:
\begin{itemize}
    \item \opt{style =} (current line style),
    \item \opt{color =} (current line color),
    \item \opt{width =} (current line thickness in tenths of a point),
    \item \opt{opacity =} (current line opacity),
    \item \opt{hidden =} (value of \emph{Hiddenlines}),
    \item \opt{out =} (nil), if we assign a table-type variable to this \emph{out} parameter, then the function adds to this list the two points corresponding to the endpoints of the hidden arc, if any, which allows us to retrieve them without having to calculate them. \end{itemize}

\subsubsection{Add a great circle arc: g:DSarc}

The method \textbf{g:DSarc(AB,sens,options)} allows you to add a great circle arc to the sphere. The argument \emph{AB} is a table of the form $\{A,B\}$ where $A$ and $B$ are two distinct points on the sphere. The great circle arc is then drawn from $A$ to $B$. The argument \emph{sens} is equal to 1 or -1 to indicate the direction of the arc. When $A$ and $B$ are not diametrically opposed, the plane $OAB$ (where $O$ is the center of the sphere) is oriented with $\vec{OA}\wedge\vec{OB}$. The \emph{options} argument is a table with 6 fields, which are:
\begin{itemize}
    \item \opt{style =} (current line style),
    \item \opt{color =} (current line color),
    \item \opt{width =} (current line thickness in tenths of a point),
    \item \opt{opacity =} (current line opacity),
    \item \opt{hidden =} (value of \emph{Hiddenlines}),
    \item \opt{arrows =} (0), three possible values: 0 (no arrow), 1 (one arrow at $B$), 2 (arrow at $A$ and $B$).
    \item \opt{normal =} (nil), allows you to specify a normal vector to the $OAB$ plane when these three points are aligned.
\end{itemize}

\subsubsection{Add an angle: g:DSangle}

The method \textbf{g:DSangle(B,A,C,r,sens,options)}, where $A$, $B$, and $C$ are three points on the sphere, allows you to draw a great circle arc on the sphere to represent the angle $(\vec{AB},\vec{AC})$ with a radius of \emph{r}. The argument \emph{sens} is 1 or -1 to indicate the direction of the arc; the plane $ABC$ is oriented with $\vec{AB}\wedge\vec{AC}$. The \emph{options} argument is a table with 6 fields, which are:
\begin{itemize}
    \item \opt{style =} (current line style),
    \item \opt{color =} (current line color),
    \item \opt{width =} (current line thickness in tenths of a point),
    \item \opt{opacity =} (current line opacity),
    \item \opt{hidden =} (value of \emph{Hiddenlines}),
    \item \opt{arrows =} (0), three possible values: 0 (no arrow), 1 (one arrow at $B$), 2 (arrow at $A$ and $B$).
    \item \opt{normal =} (nil), allows you to specify a normal vector to the $ABC$ plane when these three points are "aligned" on the same great circle. \end{itemize}

\subsubsection{Add a spherical facet: g:DSfacet}

The method \textbf{g:DSfacet(F,options)}, where \emph{F} is a list of points on the sphere, allows you to draw the facet represented by $F$, the edges being great circle arcs. The \emph{options} argument is a table with 6 fields, which are:
\begin{itemize}
    \item \opt{style =} (current line style),
    \item \opt{color =} (current line color),
    \item \opt{width =} (current line thickness in tenths of a point),
    \item \opt{opacity =} (current line opacity),
    \item \opt{hidden =} (value of \emph{Hiddenlines}),
    \item \opt{fill =} (""), string representing the fill color (none by default),
    \item \opt{fillopacity =} (0.3), opacity of the fill color. \end{itemize}

\subsubsection{Add a spherical curve: g:DScurve}

The method \textbf{g:DScurve(L,options)}, where \emph{L} is a list of points on the sphere, allows you to draw the curve represented by $L$. The \emph{options} argument is a table with six fields, which are:
\begin{itemize}
    \item \opt{style =} (current line style),
    \item \opt{color =} (current line color),
    \item \opt{width =} (current line thickness in tenths of a point),
    \item \opt{opacity =} (current line opacity),
    \item \opt{hidden =} (value of \emph{Hiddenlines}),
    \item \opt{out =} (nil). If we assign a table-type variable to this \emph{out} parameter, then the function adds the points corresponding to the ends of the hidden parts to this list.
\end{itemize}

We will now deal with objects that are not necessarily on the sphere, but that may pass through it, or be inside it, or outside it.

\subsubsection{ Add a segment: g:DSseg}

The \textbf{g:DSseg(AB,options)} method allows you to add a segment. The argument \emph{AB} is a table of the form $\{A,B\}$ where $A$ and $B$ are two points in space. The function handles interactions with the sphere. The \emph{options} argument is a table with 5 fields, which are:
\begin{itemize}
    \item \opt{style =} (current line style),
    \item \opt{color =} (current line color),
    \item \opt{width =} (current line thickness in tenths of a point),
    \item \opt{opacity =} (current line opacity),
    \item \opt{hidden =} (value of \emph{Hiddenlines}),
    \item \opt{arrows =} (0), three possible values: 0 (no arrow), 1 (one arrow in $B$), 2 (arrow in $A$ and $B$).
\end{itemize}

\subsubsection{Add a line: g:DSline}

The \textbf{g:DSline(d,options)} method allows you to add a line. The argument \emph{d} is a table of the form $\{A,u\}$ where $A$ is a point on the line and $u$ is a direction vector (two 3D points). The function handles interactions with the sphere. The drawn segment is obtained by intersecting the line with the 3D window; it may be empty if the window is too narrow. The \emph{options} argument is a table with 6 fields, which are:
\begin{itemize}
    \item \opt{style =} (current line style),
    \item \opt{color =} (current line color),
    \item \opt{width =} (current line thickness in tenths of a point),
    \item \opt{opacity =} (current line opacity),
    \item \opt{hidden =} (value of \emph{Hiddenlines}),
    \item \opt{arrows =} (0), three possible values: 0 (no arrow), 1 (one arrow at $B$), 2 (arrow at $A$ and $B$),
    \item \opt{scale =} (1), allows you to change the size of the plotted segment.
\end{itemize}

    
\subsubsection{ Add a polygonal line: g:DSpolyline}

The \textbf{g:DSpolyline(L,options)} method allows you to add a polygonal line. The argument \emph{L} is a list of points in space, or a list of lists of points in space. The function handles interactions with the sphere. The \emph{options} argument is a table with 6 fields, which are:
\begin{itemize}
    \item \opt{style =} (current line style),
    \item \opt{color =} (current line color),
    \item \opt{width =} (current line thickness in tenths of a point),
    \item \opt{opacity =} (current line opacity),
    \item \opt{hidden =} (value of \emph{Hiddenlines}),
    \item \opt{arrows =} (0), three possible values: 0 (no arrow), 1 (one arrow at $B$), 2 (arrow at $A$ and $B$),
    \item \opt{close =} (false), indicates whether the line should be closed. \end{itemize}

\subsubsection{Add a plane: g:DSplane}

The \textbf{g:DSplane(P,options)} method allows you to add the contour of a plane. The argument \emph{P} is a table of the form \emph{\{A,n\}}, where $A$ is a point on the plane and $n$ is a normal vector. The function draws a parallelogram representing the plane $P$, processing the interactions with the sphere. The \emph{options} argument is a table with 7 fields, which are:
\begin{itemize}
    \item \opt{style =} (current line style),
    \item \opt{color =} (current line color),
    \item \opt{width =} (current line thickness in tenths of a point),
    \item \opt{opacity =} (current line opacity),
    \item \opt{hidden =} (value of \emph{Hiddenlines}),
    \item \opt{scale =} (1), allows you to change the size of the parallelogram,
    \item \opt{angle =} (0), angle in degrees, allows you to rotate the parallelogram around the perpendicular line passing through the center of the sphere.
    \item \opt{trace =} (true), allows you to draw, or not, the intersection of the plane with the sphere when it is not empty. \end{itemize}

\subsubsection{Add a label: g:DSlabel}

The \textbf{g:DSlabel(text1,anchor1,options1,text2,anchor2,options2,...)} method allows you to add one or more labels using the same principle as the \emph{g:Dlabel3d} method, except that here the function handles cases where the anchor point is inside the sphere, behind the sphere, or in front of the sphere. When it is inside, the label color is given by the global variable \textbf{Insidelabelcolor}, which defaults to \emph{"DarkGray"}.

\subsubsection{Add points: g:DSdots and g:DSstars}

The \textbf{g:DSdots(dots,options)} method allows you to add points to the scene. The \emph{dots} argument is a list of 3D points. The function draws points by managing interactions with the sphere. The \emph{options} argument is a two-field table, which are:
\begin{itemize}
    \item \opt{hidden =} (value of \emph{Hiddenlines}),
    \item \opt{mark\_options =} (""), a string that will be passed directly to the \emph{\textbackslash draw} instruction.
\end{itemize}
If a point is inside the sphere, or on the hidden face, the point's color is given by the global variable \textbf{Insidelabelcolor}, which defaults to \emph{"DarkGray"}.

The \textbf{g:DSstars(dots,options)} method allows you to add points to the sphere. The \emph{dots} argument is a list of 3D points that will be projected onto the sphere. The function draws these points as an asterisk. The \emph{options} argument is a two-field table, which are:
\begin{itemize}
    \item \opt{style =} (current line style),
    \item \opt{color =} (current line color),
    \item \opt{width =} (current line thickness in tenths of a point),
    \item \opt{opacity =} (current line opacity),
    \item \opt{hidden =} (value of \emph{Hiddenlines}),
    \item \opt{scale =} (1), allows you to change the size of the parallelogram,
    \item \opt{circled =} (false), allows you to add a circle around the star,
    \item \opt{fill =} (""), string representing a color. When not empty, the asterisk is replaced by a circled hexagonal facet and filled with the color specified by this option. \end{itemize}
The points on the hidden face of the sphere have the color given by the global variable \textbf{Insidelabelcolor}, which defaults to \emph{"DarkGray"}.

\subsubsection{Inverse Stereography: g:DSinvstereo\_curve and g:DSinvstereo\_polyline}

The method \textbf{g:DSinvstereo\_curve(L,options)}, where \emph{L} is a 3D polygonal line representing a curve drawn on a plane with equation $z =$cte, draws the image of $L$ on the sphere by inverse stereography, the pole being the point \emph{C+r*vecK}, where $C$ is the center of the sphere and $r$ is the radius.

The method \textbf{g:DSinvstereo\_polyline(L,options)}, where \emph{L} is a 3D polygonal line drawn on a plane with equation $z =$cte, draws the image of $L$ on the sphere by inverse stereography, the pole being the point \emph{C+r*vecK}, where $C$ is the center of the sphere and $r$ is the radius.

In both cases, the \emph{options} are the same as for the \textbf{g:DScurve} method.

\subsubsection{Examples}

\begin{demo}{Cube in a Sphere}
\begin{luadraw}{name=cube_in_sphere}
local g = graph3d:new{window={-9,9,-4,5},viewdir={25,70},size={16,8}}
require 'luadraw_spherical'
arrowBstyle = "-stealth"
g:Linewidth(6); Hiddenlinestyle = "dashed"
local a = 4
local O = Origin
local cube = parallelep(O,a*vecI,a*vecJ,a*vecK)
local G = isobar3d(cube.vertices)
cube = shift3d(cube,-G) -- to center the cube at the origin
local R = pt3d.abs(cube.vertices[1])

local dessin = function()
    g:DSpolyline({{O,5*vecI},{O,5*vecJ},{O,5*vecK}},{arrows=1, width=8}) -- axes
    g:DSplane({a/2*vecK,vecK},{color="blue",scale=0.9,angle=20}); 
    g:DScircle({-a/2*vecK,vecK},{color="blue"})
    g:DSpolyline( facetedges(cube) ); g:DSlabel("$O$",O,{pos="W"})
    g:Dspherical()
end

g:Saveattr(); g:Viewport(-9,0,-4,5); g:Coordsystem(-5,5,-5,5)
Hiddenlines = true; g:Define_sphere({radius=R})
dessin()
g:Dlabel3d("$x$",5*vecI,{pos="SW"},"$y$",5*vecJ,{pos="E"},"$z$",5*vecK,{pos="N"})
g:Dlabel("Hiddenlines=true",0.5-4.5*cpx.I,{})
g:Restoreattr()

clear_spherical() -- deletes previously created objects

g:Saveattr(); g:Viewport(0,9,-4,5); g:Coordsystem(-5,5,-5,5)
Hiddenlines = false; g:Define_sphere({radius=R,opacity=0.7} )
dessin()
g:Dlabel3d("$x$",5*vecI,{pos="SW"},"$y$",5*vecJ,{pos="E"},"$z$",5*vecK,{pos="N"})
g:Dlabel("Hiddenlines=false, opacity=0.7",0.5-4.5*cpx.I,{})
g:Restoreattr()
g:Show()
\end{luadraw}
\end{demo}

\paragraph{Spherical curve}

\begin{demo}{Viviani window}
\begin{luadraw}{name=courbe_spherique}
local g = graph3d:new{window={-4.5,4.5,-4.5,4.5},viewdir={30,60},margin={0,0,0,0},size={10,10}}
require 'luadraw_spherical'
arrowBstyle = "-stealth"
g:Linewidth(6); Hiddenlinestyle = "dotted"
Hiddenlines = false; 
local C = cylinder(M(1.5,0,-3.5),1.5,M(1.5,0,3.5),35,true)
local L = parametric3d( function(t) return Ms(3,t-math.pi/2,t) end, -math.pi,math.pi) -- la courbe
g:Define_sphere()
g:DSpolyline(facetedges(C),{color="gray"}) -- affichage cylindre
g:DSpolyline({{-5*vecI,5*vecI},{-5*vecJ,5*vecJ},{-5*vecK,5*vecK}},{arrows=1}) --axes
Hiddenlines=true; g:DScurve(L,{width=12,color="blue"}) -- courbe avec partie cachée
g:Dspherical()
g:Show()
\end{luadraw}
\end{demo}

To avoid compromising the readability of the drawing, the hidden parts have not been displayed except for the curve.

\paragraph{A spherical tiling}

\begin{demo}{A spherical tiling}
\begin{luadraw}{name=pavage_spherique}
local g = graph3d:new{window={-3,3,-3,3},viewdir={30,60},size={10,10}}
require 'luadraw_spherical'
require "luadraw_polyhedrons"
g:Linewidth(6); Hiddenlines = true; Hiddenlinestyle = "dotted"
local P = poly2facet( octahedron(Origin,sM(30,10)) )
local colors = {"Crimson","ForestGreen","Gold","SteelBlue","SlateGray","Brown","Orange","Navy"}
g:Define_sphere()
for k,F in ipairs(P) do
    g:DSfacet(F,{fill=colors[k],style="noline",fillopacity=0.7})  -- facettes sans les bords
end
for _, A in ipairs(facetedges(P)) do
    g:DSarc(A,1,{width=8}) -- each edge is an arc of a great circle
end
g:Dspherical()
g:Show()
\end{luadraw}
\end{demo}

For this spherical tiling, we chose a regular octahedron with a center identical to that of the sphere and with one vertex on the sphere (and therefore all vertices are on the sphere).

\paragraph{Tangents to the sphere from a point}

\begin{demo}{Tangents to the sphere from a point}
\begin{luadraw}{name=tangent_to_sphere}
local g = graph3d:new{window={-4,5.5,-4,4},viewdir={30,60},size={10,10}}
require 'luadraw_spherical'
Hiddenlines=true; g:Linewidth(6)
local O, I = Origin, M(0,6,0)
local S,S1 = {O, 3}, {(I+O)/2,pt3d.abs(I-O)/2}
-- the circle of tangency is the intersection between spheres S and S1
local C,r,n = interSS(S,S1) 
local L = circle3d(C,r,n)[1] -- list of 3d points on the circle
local dots, lines = {}, {}
-- draw
g:Define_sphere({opacity=1})
g:DScircle({C,n},{color="red"})
for k = 1, math.floor(#L/4) do
    local A = L[4*(k-1)+1]
    table.insert(dots,A)
    table.insert(lines,{I, 2*A-I})
end
g:DSpolyline(lines ,{color="gray"})
g:DSstars(dots) -- drawing points on the sphere
g:DSdots({O,I});  -- points in the scene
g:DSlabel("$I$",I,{pos="S",node_options="red"},"$O$",O,{})
g:Dspherical()
g:Dseg3d({O,dots[1]},"gray,dashed"); g:Dangle3d(O,dots[1],I,0.2,"gray")
g:Show() 
\end{luadraw}
\end{demo}

\paragraph{Inverse Stereography}

\begin{demo}{\emph{DSinvstereo\_curve} and \emph{DSinvstereo\_polyline} methods}
\begin{luadraw}{name=stereographic_curve}
local g = graph3d:new{window3d={-5,5,-2,2,-2,2},window={-4.25,4.25,-2.5,2},size={10,10}, viewdir={40,70}}
Hiddenlines = true; Hiddenlinestyle="dashed"; g:Linewidth(6)
require 'luadraw_spherical'
local C, R = Origin, 1
local a = -R
local P = planeEq(0,0,1,-a)
local L = {M(2,0,a), M(2,2.5,a), M(-1,2,a)}
local L2 = circle3d(M(2.25,-1,a),0.5,vecK)[1]
local A, B = (L[2]+L[3])/2, L2[20]
local a,b = table.unpack( inv_projstereo({A,B},{C,R},C+R*vecK) )
g:Dplane(P,vecJ,6,6,15,"draw=none,fill=Beige")
g:Define_sphere( {center=C,radius=R, color="SlateGray!30", show=true} )
g:DSpolyline(L,{color="blue",close=true}); g:DSinvstereo_polyline(L,{color="red",width=8,close=true})
g:DSpolyline(L2,{color="Navy"}); g:DSinvstereo_curve(L2,{color="Brown",width=6})
g:DSplane(P,{scale=1.5})
g:DSpolyline({{C+R*vecK,A},{C+R*vecK,B}}, {color="ForestGreen",width=8})
g:DSpolyline({{-vecK,2*vecK}}, {arrows=1})
g:DSstars({C+R*vecK,a,b}, {scale=0.75})
g:Dspherical()
g:Dballdots3d({A,B},"ForestGreen",0.75)
g:Show()
\end{luadraw}
\end{demo}


\subsection{The \emph{luadraw\_palettes} Module}

The \emph{luadraw\_palettes} Module\footnote{This module is a contribution of \href{https://github.com/projetmbc/for-writing/tree/main/@prism}{Christphe BAL}.} defines $261$ color palettes, each with a name. A palette is a list (table) of colors, which are themselves lists of three numerical values ​​between $0$ and $1$ (red, green, and blue components). All pallets have the prefix "pal", the list of these palettes, as well as their rendering, can be viewed in this \href{luadraw_palettes_more.pdf}{document}. The extension also provides the \emph{getPal(name,options)} function, an example of which is shown below:
\begin{Luacode}
BlackbodyTransformed = getPal(
    "Blackbody", -- palette name without the prefix pal
    {
    extract = {2, 5, 8, 9}, -- color numbers to extract
    shift = 1, -- offset among the extracted colors, which gives here: 5,8,9,2
    reverse = true -- reversing the order, which gives here: 2,9,8,5
    }
)
\end{Luacode}



\subsection{The \emph{luadraw\_compile\_tex} module}

\textbf{Warning}: This module requires that the programs \emph{pdf2ps} and \emph{pstoedit} be installed on your system.

This module allows you to:

\begin{enumerate}
\item compile a text fragment in TeX,
\item convert the resulting file into an \emph{eps} file containing "flattened PostScript",
\item read the content of the \emph{eps} file and return its content as a list of paths, with the line thickness at the beginning of each path, and the fill instruction at the end.
\item The list thus obtained can be:
    \begin{enumerate}
    \item drawn on the screen,
    \item converted into 3D paths in a given plane and drawn,
    \item converted into 3D polygonal lines in a given plane (the thickness and fill command are then lost) and drawn.
    \end{enumerate}
\end{enumerate}

\subsubsection{Part One: Compilation and Reading}

\paragraph{Warning}: This step requires compiling the document with the \emph{-shell-escape} or \emph{-enable-write18} option.
Without this option, the fragment will not be compiled, which is not a problem if the \emph{<filename>.eps} file already exists and you did not intend to modify it.

The first step is handled by the \textbf{compile\_tex(text,filename)} function. The \emph{text} argument is a string; this is the fragment to be compiled. The optional \emph{filename} argument is also a string; this is the name of the file that will be created. This name must not contain \textbf{a path or an extension}. By default, this name is \emph{"tex2FlatPs"}. It is created in the current directory (but will then be deleted). The process unfolds in several steps:

\begin{enumerate}
    \item Creation of the TeX file. This uses two global variables:\par
    \verb|preamble = "\\documentclass[12pt]{article}\n"|\par
    \verb|usepackage = "\\usepackage{amsmath,amssymb}\n\\usepackage{fourier}\n"|\par
    Compilation is performed with \emph{pdflatex}.
    \item The resulting file is converted to PostScript using the \emph{pdf2ps} utility.
    \item The resulting PS file is then converted using the \emph{pstoedit} utility into an EPS file in flattened PostScript (all content is in the form of paths).
    \item The resulting file \emph{<filename>.eps} is copied to the working directory of \emph{luadraw} (the name of this directory is in the global variable \emph{cachedir}), and all compilation remnants are erased.
    \item The contents of the file thus created are automatically read by the function \emph{read\_compiled\_tex(filename)}, which returns a list of paths. Each path is a list starting with the line thickness, followed by dots and instructions like a regular path, and ending with the fill command (\emph{"fill"}, \emph{"eofill"}, or \emph{"stroke"}).
\end{enumerate}

\subsubsection{Part Two: Using the Result}

\paragraph{In 2D} The result can be drawn using the method \textbf{g:Dcompiled\_tex(anchor, L, options)} where \emph{L} is the result returned by the function \emph{compile\_tex()}. The \emph{anchor} argument is a complex number; it represents the center of the bounding box of the drawing contained in \emph{L}. The \emph{options} argument is a table whose fields are:
\begin{itemize}
    \item \opt{scale =} (1), allows you to adjust the size of the drawing, this option can be a number or a table of two numbers: \emph{\{scaleX, scaleY\}},
    \item \opt{color =} (current default color),
    \item \opt{dir =} (nil), a table consisting of two vectors \emph{\{v1, v2\}} indicating the writing direction (nil means the usual direction, which corresponds to the table \emph{\{1, cpx.I\}}),
    \item \opt{hollow =} (false), enables or disables the filling of shapes. With the value \emph{true}, only the outlines are drawn. 
    \item \opt{drawbox =} (false): allows you to draw or not draw the bounding box,
    \item \opt{draw\_options =} (""): string containing the options that will be be passed directly to the \emph{\backslash draw} command.
\end{itemize}


The result can also be transformed into a polygonal line using the function \textbf{compiled\_tex2polyline(L,scale)} where \emph{L} is the result returned by the \emph{compile\_tex()} function. The optional argument \emph{scale} allows you to adjust the size; it can be a number or a table of two numbers: \emph{\{scaleX, scaleY\}}.

\begin{demo}{Example with \emph{compile\_tex} in 2d}
\begin{luadraw}{name=compile_tex2d}
local g = graph:new{bbox=false}
require 'luadraw_compile_tex'
local i = cpx.I
local text = "\\[\\int_0^{+\\infty} e^{-\\frac{x^2}2}dx = \\frac{\\sqrt{2\\pi}}2\\]" -- text to compile
local L = compile_tex(text,"gauss_integral") -- compile with -shell-escape the first time to create the file
g:Shift(2*i) -- a first drawing
g:Dcompiled_tex(0,L,{scale=2,hollow=true, drawbox=true, draw_options="fill=pink", dir={1-i/4,i}}) -- we draw L

g:Shift(-4*i) -- a second drawing
L = compiled_tex2polyline(L,{3,3}) -- L is converted to a polygonal line
local f = function(z) return Z(z.re,z.im+math.sin(z.re*1.5)) end  -- this function produces sinusoidal waves
L = ftransform(L,f) -- we apply f to L
g:Dpath( polyline2path(L), 'draw=none,fill=blue') -- we draw L as a path
g:Show()
\end{luadraw}
\end{demo}


\paragraph{In 3D} The result can be converted to 3D using the method \textbf{g:Compiled\_tex2path3d(L,options)} where \emph{L} is the result returned by the function \emph{compile\_tex()}. The \emph{options} argument is a table whose fields are:
\begin{itemize}
    \item \opt{scale =} (1), allows you to adjust the size of the drawing, this option can be a number or a table of two numbers: \emph{\{scaleX, scaleY\}},
    \item \opt{anchor =} (Origin), 3D point which represents the center of the bounding box of the drawing,
    \item \opt{color =} (current default color),
    \item \opt{dir =} (\{vecJ,vecK\}), basis of the plane in which the result will be located (this plane will also contain the \emph{anchor} point), these two vectors indicate the direction of writing,
    \item \opt{polyline =} (false), with the value \emph{true} the returned result will be a list of lists of 3D points and can therefore be drawn with the method \emph{g:Dpolyline3d()}, however, the information: line thickness and fill command, are lost. With the value \emph{false} the result is a list of paths, each path is a list starting with the line thickness, followed by 3D points and instructions like an ordinary 3D path, and ending with the fill command (\emph{"fill"}, or \emph{"eofill"} or \emph{"stroke"}).
\end{itemize}

With the option \opt{polyline=false} (default value), the output can be drawn using the method \textbf{g:Dcompiled\_tex3d(L, options)} where \emph{L} is the result of the method \emph{g:Compiled\_tex2path3d()}. The argument \emph{options} is an array whose fields are:

\begin{itemize}
    \item \opt{color =} (default current color),
    \item \opt{hollow =} (false), enables or disables shape fills. With the value \emph{true}, only outlines are drawn,
    \item \opt{drawbox =} (false): allows you to draw or not draw the bounding box,
    \item \opt{draw\_options =} (""): string containing the options that will be passed directly to the \emph{\backslash draw} command. 
\end{itemize}

\begin{demo}{Write on a cylinder}
\begin{luadraw}{name=compile_tex3d}
local g = graph3d:new{ window={-3,3,-4,4}, margin={0,0,0,0}, size={10,10}, viewdir={-50,60}}
require 'luadraw_compile_tex'

function curve_on_cylinder(curve,cylinder,screenNormal) 
-- curve is a 3d polyline on a cylinder,
-- cylinder = {A,r,B}
-- this function separate the visible part from the hidden part of the curve
    local A,r,B = table.unpack(cylinder)
    local U = B-A
    local visible_function = function(N)
        local I = dproj3d(N,{A,U})
        return (pt3d.dot(N-I,screenNormal) >= 0)
    end
    return split_points_by_visibility(curve,visible_function)
end

local A, r, B = -3*vecK, 2, 2.5*vecK -- the cylinder
local text = "Euler theorem: \\par \\(e^{i\\pi}=-1\\)"
local L = compile_tex(text, "essai") -- compile with shell-escape the first time to create "essai.eps" file 
local C = g:Compiled_tex2path3d(L,{scale=3, anchor=M(r,0,0), dir={vecJ,vecK}, polyline=true})
-- C is the text converted into 3d polylines, in the plane passing through anchor and basic direction dir, with a scale of 3.

local f = function(A) return Mc(r,A.y/r,A.z) end -- returns the image of a point A on the cylinder by winding
C = ftransform3d(C,f) -- plane curve -> cylindrical curve transformation
local Cv, Ch = curve_on_cylinder(C, {A,r,B}, g.Normal) -- visible part and hidden part of C, this may take some time
Ch = polyline2path(Ch) -- hidden part, conversion to path
g:Dpath3d(Ch, "draw=none,fill=red!30") -- hidden part first
g:Dcylinder(A,r,B,{color="blue",opacity=0.5}) -- cylinder
Cv = polyline2path(Cv) -- visible part, conversion to path
g:Dpath3d(Cv, "draw=none,fill=red")
g:Show()
\end{luadraw}
\end{demo}

\subsection{The \emph{luadraw\_cvx\_polyhedra\_nets} module}

\subsubsection{Basic Function}

The module \emph{luadraw\_cvx\_polyhedra\_nets} allows you to \og unfold\fg\ a \textbf{convex} polyhedron to obtain a net. The function that performs the unfolding is:\par
\hfil \textbf{unfold\_polyhedron(P, options)}\hfil\par
The argument \emph{P} must be a convex polyhedron. The argument \emph{options} is a table allowing you to adjust certain parameters. These are as follows (with their default values ​​in parentheses):

\begin{itemize}
    \item \opt{opening = 1}, a value between $0$ and $1$ representing the "opening rate". With the value $1$, the polyhedron is fully unfolded; the facets returned by the function will therefore all be in the same plane. With the value $0$, the function returns the polyhedron's faces without modification.

    \item \opt{root = 1}, the number of the polyhedron face that will serve as the root, because the function represents the polyhedron as a tree by determining, for each face, its neighbors (adjacent facets), as well as any shared edges and angles. This option allows you to choose the face that will serve as the starting point.

    \item \opt{model = nil}, a list of facet number lists to impose a pattern model, for example \emph{model=\{ \{1,6\},\{1,3\},\{1,4\},\{1,5,2\}\}}, the sublist \emph{\{1,5,2\}} means that facet $1$ is the ancestor of facet $5$, and that facet $5$ is the ancestor of facet $2$, that is to say that facets $5$ and $1$ are adjacent, and facet $5$ will rotate around its common edge with facet $1$ (same for $5$ and $2$). For the model to be consistent, all facets of the polyhedron EXCEPT one (which will be the facet \emph{root}), must have one and only one ancestor; If facets $1$ and $5$ are not adjacent in the polyhedron, the function stops and displays an error in the terminal. When the \emph{model} option is set to \emph{nil} (the default value), the algorithm calculates a consistent model itself.

    \item \opt{to2d = false}, is a boolean value that returns a 2D version of the pattern in the screen plane coordinate system. With the value \emph{true}, the \emph{opening} option automatically takes the value $1$, and the facets returned by the function will have vertices expressed as complex numbers.

    \item \opt{tabs = false}, is a boolean value that allows adding or excluding tabs from the pattern in the 2D version. With the value \emph{true}, the \emph{to2d} option automatically takes the value \emph{true} as well. The facets returned by the function will have vertices expressed as complex numbers in the screen coordinate system, and the function also returns a 2D polygonal line representing tabs for certain edges (these are determined automatically).

    \item \opt{tabs\_wd = 0.2}, a numeric value representing the thickness of the tabs when the \emph{tabs} option is set to \emph{true}.

    \item \opt{tabs\_lg = 0.5}, a numerical value between $0$ and $1$, determines the length of the shorter side of the tabs. This length is equal to the length of the edge (which is the longer side) multiplied by \emph{tabs\_lg} (when the \emph{tabs} option is set to \emph{true}).

    \item \opt{rotate = 0}, when the \emph{to2d} option is set to \emph{true}, rotates the drawing by an angle equal to \emph{rotate} (in degrees) around its center. In the 3D version, the drawing is rotated by an angle equal to \emph{rotate} (in degrees) around the axis passing through the centroid of the facet \emph{root} and oriented by a normal vector to this facet pointing outwards from the polyhedron.
\end{itemize}



The function returns a table containing the following fields:

\begin{itemize}
    \item The field \emph{facets}: which contains the list of facets, with vertices in 2D (complex numbers) if the \emph{to2d} option is \emph{true}, or vertices in 3D (3D points) otherwise.

    \item The field \emph{tree}: which is a list of the form: \par\hfil\emph{\{ \{ancestor,n1,n2,angle,vertices\}, ...\} }\hfil\par
    Each element of this list represents a facet, with the following information for each facet:
    \begin{itemize}
        \item \emph{ancestor}: the number of the ancestor facet, its position in the list \emph{tree} (the facet that served as the root has the number $0$ as its ancestor, which does not correspond to any facet).
        \item \emph{n1, n2}: the number of the vertices of the ancestor facet representing the common edge.

        \item  \emph{angle}: the angle in degrees with the ancestor facet.

        \item  \emph{vertices}: the list of vertices (3D points) of the facet.
    \end{itemize}

    \item The \emph{bounds} field: which contains, as a list, the bounding box of the facets (either 2D or 3D)
    
    \item When the \emph{tabs} option is set to \emph{true}, there are two additional fields in the result:
    \begin{itemize}
        \item The \emph{tabs} field: which contains a 2D polygonal line (a list of lists of complex numbers) representing the tabs, only when the \emph{tabs} option is set to \emph{true}.

        \item The \emph{twins} field: which contains a list of the form \emph{\{ \{\{a1,b1\},\{a2,b2\}\}, ... \}} representing the list of twin edge pairs (twin edges coincide when the polyhedron is closed). \emph{a1}, \emph{b1}, \emph{a2}, \emph{b2} are complex numbers representing the endpoints of the edges in the 2D version of the polyhedron net. This list is calculated only when the \emph{tabs} option is set to \emph{true}. 
    \end{itemize} 
\end{itemize}

\subsubsection{The Drawing Method}

This is the method \textbf{g:Dpolyhedron\_net(P, options)} where \emph{P} denotes a convex polyhedron. The options are those of the previous function, plus the following:

\begin{itemize}
    \item In the case of a 2D pattern (when the \emph{to2d} option, or the \emph{tabs} option, has the value \emph{true}):
    \begin{itemize}
        \item \opt{facet\_name = false}, with the value \emph{true} the facet number (preceded by the letter F) will be displayed in the center of each facet.

        \item \opt{edge\_name = false}, with the value \emph{true}, the edge number (preceded by the letter 'e') will be displayed in the center of each edge, allowing you to identify twin edges and therefore neighboring facets.

        \item \opt{tabs\_options = ""}, string representing TikZ drawing options for the tabs if the \emph{tabs} option has the value \emph{true}.

        \item \opt{facet\_options = ""}, string representing TikZ drawing options for the \emph{g:Dpolyline()} method that will draw the facets. 
    \end{itemize}

    \item In the case of a 3D pattern, there is only the following additional information:
    \begin{itemize}
        \item \opt{facet\_options = \{\}}, a list of drawing options for the \emph{g:Dfacet()} method that will draw the facets.
    \end{itemize}
\end{itemize}

The drawing is accompanied by a display in the terminal of its 2D bounding box.

    
\subsubsection{Examples}

In this example, we display the default 2D net of a parallelepiped $P$ with hatched tabs, the facet numbers (this number is the position in the \emph{P.facets} list), and the edge numbers to see which ones need to be glued together:

\begin{demo}{Net of a parallelepiped}
\begin{luadraw}{name=parallelep_net}
local g = graph3d:new{viewdir={30,60},window={-8.5,8,-5,5},bbox=false, size={10,10}}
require 'luadraw_cvx_polyhedra_nets'
P = parallelep(Origin, 4*vecI,5*vecJ,3*vecK)
g:Dpolyhedron_net(P, {tabs=true, tabs_options="pattern=north west lines, pattern color=gray", facet_options="fill=Orange!30", facet_name=true, edge_name=true})
g:Show()
\end{luadraw}
\end{demo}

The default pattern here would correspond to the option \emph{model=\{\{1,3\},\{1,4\},\{1,5\},\{1,6\},\{3,2\}\}}\footnote{The algorithm takes the first face, then looks for its neighbors, then the neighbors of the first neighbor, etc.}, but we might want to impose a different model, for example, with the same parallelepiped:

\begin{demo}{Imposed pattern of a parallelepiped}
\begin{luadraw}{name=parallelep_net2}
local g = graph3d:new{viewdir={30,60},window={-9,9,-5,5},bbox=false,size={10,10}}
require 'luadraw_cvx_polyhedra_nets'
P = parallelep(Origin, 4*vecI,5*vecJ,3*vecK)
g:Dpolyhedron_net(P, {model={{4,6,1,3,2,5}},tabs=true, tabs_options="pattern=north west lines, pattern color=gray", facet_options="fill=Orange!30", facet_name=true, edge_name=true, rotate=-90})
g:Show()
\end{luadraw}
\end{demo}

Here is an example with a truncated parallelepiped that is half-unfolded:

\begin{demo}{Half unfolded truncated parallelepiped}
\begin{luadraw}{name=parallelep_net3}
local g = graph3d:new{window={-9,15,-9,9,0.6,0.6},bg="lightgray", viewdir={30,60}, margin={0,0,0,0}} 
require 'luadraw_cvx_polyhedra_nets'
P = parallelep(Origin, 4*vecI,5*vecJ,3*vecK)
local A, B, C = M(4,2.5,3), M(2,5,3), M(4,5,1.5)
P = cutpoly(P, plane(A,B,C), true) -- P is truncated with a plane
g:Shift3d(M(0,-4,5))
g:Dpolynames(P,"facet") -- this function shows facet numbers of P
-- half unfolded P
g:Shift3d(M(0,0,-11))
g:Dpolyhedron_net(P,{opening=0.5, facet_options={color="Crimson", opacity=0.7, edgecolor="Gold", edgewidth=8}})
-- 2d net
g:Shift(10)
g:Dpolyhedron_net(P,{tabs=true, tabs_options="pattern=north west lines, pattern color=gray", facet_name=true, rotate=90})
g:Show()
\end{luadraw}
\end{demo}

\paragraph{NB:} The functions \textbf{unfold\_polyhedron} and \textbf{g:Dpolyhedron\_net} apply to any convex polyhedron, but they will not give the expected result with a non-convex polyhedron.

\subsubsection{The \emph{unfold\_tree()} function}

It can be useful to retrieve the tree generated by the \textbf{unfold\_polyhedron} function to avoid recalculating it multiple times, for example, during an animation. The \textbf{unfold\_tree(tree,opening,num)} function also allows you to unfold the polyhedron. The argument \emph{tree} is the tree provided by the \emph{unfold\_polyhedron} function, the optional argument \emph{opening} is a number between $0$ and $1$ that represents the opening rate ($1$ by default), the optional argument \emph{num} is the number of the facet you want to open (and all descendants of that facet will rotate in the same way), when this argument is omitted, all facets rotate.


\paragraph{Example of animation:}

\begin{Luacode}
\begin{luacode*}
nbimages = 70 -- must be global
-- images creation
local g = graph3d:new{ viewdir=perspective("central",30,60), bg="gray", size={10,10}, margin={0,0,0,0} }
-- declarations
require 'luadraw_polyhedrons'
require 'luadraw_cvx_polyhedra_nets'
local p = linspace(0,1,36)
local T = linspace(0,360,nbimages+1)
local P = dodecahedron(Origin, -2*vecI)
local net = unfold_polyhedron(P)
local tree = net.tree
-- create the image number k, this function must be global
function makeframe(k) 
    local r = k
    if k > 36 then r = 72-k end
    local P1 = rotate3d( unfold_tree(tree,p[r]), T[k], {Origin,vecK})
    g:Dfacet(P1, {color="Crimson", edgecolor="Gold", edgewidth=8})
    -- send image number k
    g:Sendtotex()  -- send the tikzpicture to TeX
    g:Cleargraph()  
end
\end{luacode*}
\end{Luacode}

The \TeX\ code (with the \emph{animate} package):

\begin{TeXcode}
\def\nb{\directlua{tex.print(nbimages)}}
\def\makeframe#1{\directlua{makeframe(#1)}}%

\begin{animateinline}[poster=first,controls,loop]{8}
\multiframe{\nb}{ik=1+1}{%
\makeframe{\ik}%
}%
\end{animateinline}
\end{TeXcode}

\begin{luacode*}
nbimages = 70
-- images creation
local g = graph3d:new{ viewdir=perspective("central",30,60), bg="gray", size={10,10}, margin={0,0,0,0} }
-- declarations
require 'luadraw_polyhedrons'
require 'luadraw_cvx_polyhedra_nets'
local p = linspace(0,1,36)
local T = linspace(0,360,nbimages+1)
local P = dodecahedron(Origin, -2*vecI)
local net = unfold_polyhedron(P)
local tree = net.tree
-- create the image number k, this function must be global
function makeframe(k) -- do not modify this line
    local r = k
    if k > 36 then r = 72-k end
    local P1 = rotate3d( unfold_tree(tree,p[r]), T[k],{Origin,vecK})
    g:Dfacet(P1, {color="Crimson", edgecolor="Gold", edgewidth=8})
    -- send image number k
    g:Sendtotex()  -- do not modify
    g:Cleargraph() -- do not modify
end
\end{luacode*}

\def\nb{\directlua{tex.print(nbimages)}}%
\def\makeframe#1{\directlua{makeframe(#1)}}%

The result :

\begin{minipage}{0.9\textwidth}
\begin{center}
\captionof{figure}{Unfolding a dodecahedron}
\begin{animateinline}[poster=first,controls,loop]{8} %palindrome
\multiframe{\nb}{ik=1+1}{%
\makeframe{\ik}%
}%
\end{animateinline}
\end{center}
\end{minipage}
