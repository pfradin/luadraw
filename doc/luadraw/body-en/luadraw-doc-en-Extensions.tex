\section{Extensions}

\subsection{The \emph{luadraw\_polyhedrons} module}

This module is still in draft form and is expected to be expanded in the future. As its name suggests, it contains the definition of polyhedra. All numerical data comes from the \href{https://dmccooey.com/polyhedra/}{Visual Polyhedra} website.

All functions follow the same model: \textbf{<name>(C,S,all)} where $C$ is the center of the polyhedron (3D point) and $S$ is a vertex of the polyhedron (3D point). When $C$ or $S$ have the value \emph{nil}, the untransformed polyhedron (centered at the origin) is returned. The optional argument \emph{all} is a boolean. When it has the value \emph{true}, the function returns four things: \emph{P, V, E, F} where:
\begin{itemize}
    \item $P$ is the solid as a polyhedron,
    \item $V$ the list (table) of vertices,
    \item $E$ the list (table) of edges (with 3D points),
    \item $F$ the list of facets (with 3D points). Some polyhedra have multiple facet types; in this case, the returned result is of the form: \emph{P, V, E, F1, F2, ...}, where $F1$, $F2$, ... are lists of facets. This can allow them to be drawn with different colors, for example. \end{itemize}
The argument \emph{all} is set to \emph{false}, which is the default value; the function only returns the polyhedron.

Here are the solids currently contained in this module:

\begin{itemize}
    \item The Platonic solids, these solids have only one face type:
\begin{itemize}
    \item The function \textbf{tetrahedron(C,S,all)} allows the construction of a regular tetrahedron with center $C$ (3d point) and one vertex at $S$ (3d point).
    \item The function \textbf{octahedron(C,S,all)} allows the construction of an octahedron with center $C$ (3d point) and one vertex at $S$ (3d point).
    \item The function \textbf{cube(C,S,all)} allows the construction of a cube with center $C$ (3d point) and one vertex at $S$ (3d point).
    \item The function \textbf{icosahedron(C,S,all)} allows the construction of an icosahedron with center $C$ (3d point) and one vertex at $S$ (3d point).
    \item The function \textbf{dodecahedron(C,S,all)} allows the construction of a dodecahedron with center $C$ (3d point) and one vertex at $S$ (3d point).
\end{itemize}

    \item The Archimedean Solids:
\begin{itemize}
    \item The function \textbf{cuboctahedron(C,S,all)} allows the construction of a cuboctahedron with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two types of faces.
    \item The function \textbf{icosidodecahedron(C,S,all)} allows the construction of an icosidodecahedron with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two types of faces.
    \item The function \textbf{lsnubcube(C,S,all)} allows the construction of a snub cube (form 1) with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two types of faces.
    \item The function \textbf{lsnubdodecahedron(C,S,all)} allows the construction of a snub dodecahedron (form 1) with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two types of faces.
    \item The function \textbf{rhombicosidodecahedron(C,S,all)} allows the construction of a rhombicosidodecahedron with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has three types of faces.
    \item The function \textbf{rhombicuboctahedron(C,S,all)} allows the construction of a rhombicuboctahedron with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two types of faces.
    \item The function \textbf{rsnubcube(C,S,all)} allows the construction of a snub cube (shape 2) with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two types of faces.
    \item The function \textbf{rsnubdodecahedron(C,S,all)} allows the construction of a snub dodecahedron (shape 2) with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two types of faces.
    \item The function \textbf{truncatedcube(C,S,all)} allows the construction of a truncated cube with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two types of faces.
    \item The function \textbf{truncatedcuboctahedron(C,S,all)} allows the construction of a truncated cuboctahedron with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has three types of faces.
    \item The function \textbf{truncateddodecahedron(C,S,all)} allows the construction of a truncated dodecahedron with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two types of faces.
    \item The function \textbf{truncatedicosahedron(C,S,all)} allows the construction of a truncated icosahedron with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two types of faces.
    \item The function \textbf{truncatedicosidodecahedron(C,S,all)} allows the construction of a truncated icosidodecahedron with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two threes of faces.
    \item The function \textbf{truncatedoctahedron(C,S,all)} allows the construction of a truncated octahedron with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two types of faces.
    \item The function \textbf{truncatedtetrahedron(C,S,all)} allows the construction of a truncated tetrahedron with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two types of faces.
\end{itemize}

    \item Other solids:
\begin{itemize}
    \item The function \textbf{octahemioctahedron(C,S,all)} allows the construction of an octahemioctahedron with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has two types of faces.
    \item The function \textbf{small\_stellated\_dodecahedron(C,S,all)} allows the construction of a small stellated dodecahedron with center $C$ (3d point) and one vertex at $S$ (3d point). This solid has only one type of face.

\end{itemize}
\end{itemize}

\begin{demo}{Polyhedra from the \emph{luadraw\_polyhedrons} module}
\begin{luadraw}{name=polyhedrons}
local i = cpx.I
require 'luadraw_polyhedrons' -- chargement du module
local g = graph3d:new{bg="LightGray", size={10,10}}
g:Labelsize("small"); Hiddenlines = false
-- en haut à gauche 
g:Saveattr(); g:Viewport(-5,0,0,5); g:Coordsystem(-5,5,-5,5,true)
local T,S,A,F = icosahedron(Origin,M(0,2,4.5),true) 
g:Dscene3d(
    g:addFacet(F, {color="Crimson",opacity=0.8}),
    g:addPolyline(A, {color="Pink", width=8}),
    g:addDots(S) )
g:Dlabel("Icosaèdre",5*i,{})
g:Restoreattr()
-- en haut à droite
g:Saveattr()
g:Viewport(0,5,0,5); g:Coordsystem(-5,5,-5,5,true)
local T,S,A,F1,F2 = truncatedtetrahedron(Origin,M(0,0,5),true) -- sortie complète, affichage dans une scène 3d
g:Dscene3d(
    g:addFacet(F1, {color="Crimson",opacity=0.8}),
    g:addFacet(F2, {color="Gold"}),
    g:addPolyline(A, {color="Pink", width=8}),
    g:addDots(S) )
g:Dlabel("Tétraèdre tronqué",5*i,{})
g:Restoreattr()
-- en bas à gauche
g:Saveattr(); g:Viewport(-5,0,-5,0); g:Coordsystem(-5,5,-5,5,true)
local T,S,A,F1,F2,F3 = rhombicosidodecahedron(Origin,M(0,0,4.5),true)
g:Dscene3d(
    g:addFacet(F1, {color="Crimson",opacity=0.8}),
    g:addFacet(F2, {color="Gold",opacity=0.8}), g:addFacet(F3, {color="ForestGreen"}),
    g:addPolyline(A, {color="Pink", width=8}), g:addDots(S) )
g:Dlabel("Rhombicosidodécaèdre",-5*i,{})
g:Restoreattr()
-- en bas à droite
g:Saveattr(); g:Viewport(0,5,-5,0); g:Coordsystem(-5,5,-5,5,true)
local T,S,A,F1 = small_stellated_dodecahedron(Origin,M(0,0,5),true)
g:Dscene3d(
    g:addFacet(F1, {color="Crimson",opacity=0.8}),
    g:addPolyline(A, {color="Pink", width=8}),
    g:addDots(S) )
g:Dlabel("Petit dodécaèdre étoilé",-5*i,{})
g:Restoreattr()
g:Show()
\end{luadraw}
\end{demo}

\subsection{The \emph{luadraw\_spherical}} Module

This module allows you to draw a number of objects on a sphere (such as circles, spherical triangles, etc.) without having to manually manage the visible or invisible parts. Drawing is done in three steps:
\begin{enumerate}
    \item We define the characteristics of the sphere (center, radius, color, etc.)
    \item We define the objects to be added to the scene using dedicated methods.
    \item We display everything with the \textbf{g:Dspherical()} method.
\end{enumerate}
Of course, all 2D and 3D drawing methods remain usable.

\subsubsection{Global Module Variables and Functions}

\begin{itemize}
    \item Variables with their default values:
\begin{itemize}
    \item \textbf{Insidelabelcolor} = "DarkGray": Defines the color of labels whose anchor point is inside the sphere.
    \item \textbf{arrowBstyle} = "->": Type of arrow at the end of the line
    \item \textbf{arrowAstyle} = "<-": Type of arrow at the beginning of the line
    \item \textbf{arrowABstyle} = "<->": Very rarely used because most of the time the lines drawn on the sphere must be cut. \end{itemize}
    \item Functions:
\begin{itemize}
    \item \textbf{sM(x,y,z)}: returns a point on the sphere; this is the point $I$ on the sphere such that the half-line $[O,I)$ ($O$ being the center of the sphere) passes through the point $A$ with Cartesian coordinates $(x,y,z)$. It is the projection of the point $(Mx,y,z)$ onto the sphere from the center.
    \item \textbf{sM(theta,phi)}: where \emph{theta} and \emph{phi} are angles in degrees, returns a point on the sphere, whose spherical coordinates are \emph{(R,theta,phi)} where $R$ is the radius of the sphere.     \item \textbf{toSphere(A)}: returns the projection of point $A$ onto the sphere from the center.
    \item \textbf{clear\_spherical()}: removes objects that have been added to the scene, and resets the values ​​to their default values.
\end{itemize}
\end{itemize}

If the global variable \textbf{Hiddenlines} is set to \emph{true}, then the hidden parts will be drawn in the style defined by the global variable \textbf{Hiddenlinestyle}. However, this behavior can be modified using the local option \emph{hidden=true/false}.

\subsubsection{Sphere Definition}
By default, the sphere is centered at the origin, has a radius of $3$, and is orange, but this can be modified with the \textbf{g:Define\_sphere( options )} method, where \emph{options} is a table allowing you to adjust each parameter. These are as follows (with their default values ​​in parentheses):
\begin{itemize}
    \item \opt{center =} (Origin),
    \item \opt{radius =} (3),
    \item \opt{color =} ("Orange"),
    \item \opt{opacity =} (1),
    \item \opt{mode =} (\emph{mBorder}), sphere display mode (\emph{mWireframe} or \emph{mGrid} or \emph{mBorder}, see \textbf{Dsphere}),
    \item \opt{edgecolor =} ("LightGray"),
    \item \opt{edgestyle =} ("solid"),
    \item \opt{hiddenstyle =} (Hiddenlinestyle),
    \item \opt{hiddencolor =} ("gray"),
    \item \opt{edgewidth =} (4),
    \item \opt{show =} (true), to show or hide the sphere.
\end{itemize}

\subsubsection{Add a circle: g:DScircle}

The \textbf{g:DScircle(P,options)} method allows you to add a circle to the sphere. The argument \emph{P} is a table of the form $\{A,n\}$ that represents a plane (passing through $A$ and normal to $n$, two 3D points). The circle is then defined as the intersection of this plane with the sphere. The \emph{options} argument is a table with 5 fields, which are:
\begin{itemize}
    \item \opt{style =} (current line style),
    \item \opt{color =} (current line color),
    \item \opt{width =} (current line thickness in tenths of a point),
    \item \opt{opacity =} (current line opacity),
    \item \opt{hidden =} (value of \emph{Hiddenlines}),
    \item \opt{out =} (nil), if we assign a list variable to this \emph{out} parameter, then the function adds to this list the two points corresponding to the ends of the hidden arc, if any, which allows us to retrieve them without having to calculate them. \end{itemize}

\subsubsection{Add a great circle: g:DSbigcircle}

The method \textbf{g:DSbigcircle(AB,options)} adds a great circle to the sphere. The argument \emph{AB} is a table of the form $\{A,B\}$ where $A$ and $B$ are two distinct points on the sphere. The great circle is then the circle centered at the center of the sphere, and passing through $A$ and $B$. The \emph{options} argument is a table with 5 fields, which are:
\begin{itemize}
    \item \opt{style =} (current line style),
    \item \opt{color =} (current line color),
    \item \opt{width =} (current line thickness in tenths of a point),
    \item \opt{opacity =} (current line opacity),
    \item \opt{hidden =} (value of \emph{Hiddenlines}),
    \item \opt{out =} (nil), if we assign a table-type variable to this \emph{out} parameter, then the function adds to this list the two points corresponding to the endpoints of the hidden arc, if any, which allows us to retrieve them without having to calculate them. \end{itemize}

\subsubsection{Add a great circle arc: g:DSarc}

The method \textbf{g:DSarc(AB,sens,options)} allows you to add a great circle arc to the sphere. The argument \emph{AB} is a table of the form $\{A,B\}$ where $A$ and $B$ are two distinct points on the sphere. The great circle arc is then drawn from $A$ to $B$. The argument \emph{sens} is equal to 1 or -1 to indicate the direction of the arc. When $A$ and $B$ are not diametrically opposed, the plane $OAB$ (where $O$ is the center of the sphere) is oriented with $\vec{OA}\wedge\vec{OB}$. The \emph{options} argument is a table with 6 fields, which are:
\begin{itemize}
    \item \opt{style =} (current line style),
    \item \opt{color =} (current line color),
    \item \opt{width =} (current line thickness in tenths of a point),
    \item \opt{opacity =} (current line opacity),
    \item \opt{hidden =} (value of \emph{Hiddenlines}),
    \item \opt{arrows =} (0), three possible values: 0 (no arrow), 1 (one arrow at $B$), 2 (arrow at $A$ and $B$).
    \item \opt{normal =} (nil), allows you to specify a normal vector to the $OAB$ plane when these three points are aligned.
\end{itemize}

\subsubsection{Add an angle: g:DSangle}

The method \textbf{g:DSangle(B,A,C,r,sens,options)}, where $A$, $B$, and $C$ are three points on the sphere, allows you to draw a great circle arc on the sphere to represent the angle $(\vec{AB},\vec{AC})$ with a radius of \emph{r}. The argument \emph{sens} is 1 or -1 to indicate the direction of the arc; the plane $ABC$ is oriented with $\vec{AB}\wedge\vec{AC}$. The \emph{options} argument is a table with 6 fields, which are:
\begin{itemize}
    \item \opt{style =} (current line style),
    \item \opt{color =} (current line color),
    \item \opt{width =} (current line thickness in tenths of a point),
    \item \opt{opacity =} (current line opacity),
    \item \opt{hidden =} (value of \emph{Hiddenlines}),
    \item \opt{arrows =} (0), three possible values: 0 (no arrow), 1 (one arrow at $B$), 2 (arrow at $A$ and $B$).
    \item \opt{normal =} (nil), allows you to specify a normal vector to the $ABC$ plane when these three points are "aligned" on the same great circle. \end{itemize}

\subsubsection{Add a spherical facet: g:DSfacet}

The method \textbf{g:DSfacet(F,options)}, where \emph{F} is a list of points on the sphere, allows you to draw the facet represented by $F$, the edges being great circle arcs. The \emph{options} argument is a table with 6 fields, which are:
\begin{itemize}
    \item \opt{style =} (current line style),
    \item \opt{color =} (current line color),
    \item \opt{width =} (current line thickness in tenths of a point),
    \item \opt{opacity =} (current line opacity),
    \item \opt{hidden =} (value of \emph{Hiddenlines}),
    \item \opt{fill =} (""), string representing the fill color (none by default),
    \item \opt{fillopacity =} (0.3), opacity of the fill color. \end{itemize}

\subsubsection{Add a spherical curve: g:DScurve}

The method \textbf{g:DScurve(L,options)}, where \emph{L} is a list of points on the sphere, allows you to draw the curve represented by $L$. The \emph{options} argument is a table with six fields, which are:
\begin{itemize}
    \item \opt{style =} (current line style),
    \item \opt{color =} (current line color),
    \item \opt{width =} (current line thickness in tenths of a point),
    \item \opt{opacity =} (current line opacity),
    \item \opt{hidden =} (value of \emph{Hiddenlines}),
    \item \opt{out =} (nil). If we assign a table-type variable to this \emph{out} parameter, then the function adds the points corresponding to the ends of the hidden parts to this list.
\end{itemize}

We will now deal with objects that are not necessarily on the sphere, but that may pass through it, or be inside it, or outside it.

\subsubsection{ Add a segment: g:DSseg}

The \textbf{g:DSseg(AB,options)} method allows you to add a segment. The argument \emph{AB} is a table of the form $\{A,B\}$ where $A$ and $B$ are two points in space. The function handles interactions with the sphere. The \emph{options} argument is a table with 5 fields, which are:
\begin{itemize}
    \item \opt{style =} (current line style),
    \item \opt{color =} (current line color),
    \item \opt{width =} (current line thickness in tenths of a point),
    \item \opt{opacity =} (current line opacity),
    \item \opt{hidden =} (value of \emph{Hiddenlines}),
    \item \opt{arrows =} (0), three possible values: 0 (no arrow), 1 (one arrow in $B$), 2 (arrow in $A$ and $B$).
\end{itemize}

\subsubsection{Add a line: g:DSline}

The \textbf{g:DSline(d,options)} method allows you to add a line. The argument \emph{d} is a table of the form $\{A,u\}$ where $A$ is a point on the line and $u$ is a direction vector (two 3D points). The function handles interactions with the sphere. The drawn segment is obtained by intersecting the line with the 3D window; it may be empty if the window is too narrow. The \emph{options} argument is a table with 6 fields, which are:
\begin{itemize}
    \item \opt{style =} (current line style),
    \item \opt{color =} (current line color),
    \item \opt{width =} (current line thickness in tenths of a point),
    \item \opt{opacity =} (current line opacity),
    \item \opt{hidden =} (value of \emph{Hiddenlines}),
    \item \opt{arrows =} (0), three possible values: 0 (no arrow), 1 (one arrow at $B$), 2 (arrow at $A$ and $B$),
    \item \opt{scale =} (1), allows you to change the size of the plotted segment.
\end{itemize}

    
\subsubsection{ Add a polygonal line: g:DSpolyline}

The \textbf{g:DSpolyline(L,options)} method allows you to add a polygonal line. The argument \emph{L} is a list of points in space, or a list of lists of points in space. The function handles interactions with the sphere. The \emph{options} argument is a table with 6 fields, which are:
\begin{itemize}
    \item \opt{style =} (current line style),
    \item \opt{color =} (current line color),
    \item \opt{width =} (current line thickness in tenths of a point),
    \item \opt{opacity =} (current line opacity),
    \item \opt{hidden =} (value of \emph{Hiddenlines}),
    \item \opt{arrows =} (0), three possible values: 0 (no arrow), 1 (one arrow at $B$), 2 (arrow at $A$ and $B$),
    \item \opt{close =} (false), indicates whether the line should be closed. \end{itemize}

\subsubsection{Add a plane: g:DSplane}

The \textbf{g:DSplane(P,options)} method allows you to add the contour of a plane. The argument \emph{P} is a table of the form \emph{\{A,n\}}, where $A$ is a point on the plane and $n$ is a normal vector. The function draws a parallelogram representing the plane $P$, processing the interactions with the sphere. The \emph{options} argument is a table with 7 fields, which are:
\begin{itemize}
    \item \opt{style =} (current line style),
    \item \opt{color =} (current line color),
    \item \opt{width =} (current line thickness in tenths of a point),
    \item \opt{opacity =} (current line opacity),
    \item \opt{hidden =} (value of \emph{Hiddenlines}),
    \item \opt{scale =} (1), allows you to change the size of the parallelogram,
    \item \opt{angle =} (0), angle in degrees, allows you to rotate the parallelogram around the perpendicular line passing through the center of the sphere.
    \item \opt{trace =} (true), allows you to draw, or not, the intersection of the plane with the sphere when it is not empty. \end{itemize}

\subsubsection{Add a label: g:DSlabel}

The \textbf{g:DSlabel(text1,anchor1,options1,text2,anchor2,options2,...)} method allows you to add one or more labels using the same principle as the \emph{g:Dlabel3d} method, except that here the function handles cases where the anchor point is inside the sphere, behind the sphere, or in front of the sphere. When it is inside, the label color is given by the global variable \textbf{Insidelabelcolor}, which defaults to \emph{"DarkGray"}.

\subsubsection{Add points: g:DSdots and g:DSstars}

The \textbf{g:DSdots(dots,options)} method allows you to add points to the scene. The \emph{dots} argument is a list of 3D points. The function draws points by managing interactions with the sphere. The \emph{options} argument is a two-field table, which are:
\begin{itemize}
    \item \opt{hidden =} (value of \emph{Hiddenlines}),
    \item \opt{mark\_options =} (""), a string that will be passed directly to the \emph{\textbackslash draw} instruction.
\end{itemize}
If a point is inside the sphere, or on the hidden face, the point's color is given by the global variable \textbf{Insidelabelcolor}, which defaults to \emph{"DarkGray"}.

The \textbf{g:DSstars(dots,options)} method allows you to add points to the sphere. The \emph{dots} argument is a list of 3D points that will be projected onto the sphere. The function draws these points as an asterisk. The \emph{options} argument is a two-field table, which are:
\begin{itemize}
    \item \opt{style =} (current line style),
    \item \opt{color =} (current line color),
    \item \opt{width =} (current line thickness in tenths of a point),
    \item \opt{opacity =} (current line opacity),
    \item \opt{hidden =} (value of \emph{Hiddenlines}),
    \item \opt{scale =} (1), allows you to change the size of the parallelogram,
    \item \opt{circled =} (false), allows you to add a circle around the star,
    \item \opt{fill =} (""), string representing a color. When not empty, the asterisk is replaced by a circled hexagonal facet and filled with the color specified by this option. \end{itemize}
The points on the hidden face of the sphere have the color given by the global variable \textbf{Insidelabelcolor}, which defaults to \emph{"DarkGray"}.

\subsubsection{Inverse Stereography: g:DSinvstereo\_curve and g:DSinvstereo\_polyline}

The method \textbf{g:DSinvstereo\_curve(L,options)}, where \emph{L} is a 3D polygonal line representing a curve drawn on a plane with equation $z =$cte, draws the image of $L$ on the sphere by inverse stereography, the pole being the point \emph{C+r*vecK}, where $C$ is the center of the sphere and $r$ is the radius.

The method \textbf{g:DSinvstereo\_polyline(L,options)}, where \emph{L} is a 3D polygonal line drawn on a plane with equation $z =$cte, draws the image of $L$ on the sphere by inverse stereography, the pole being the point \emph{C+r*vecK}, where $C$ is the center of the sphere and $r$ is the radius.

In both cases, the \emph{options} are the same as for the \textbf{g:DScurve} method.

\subsubsection{Examples}

\begin{demo}{Cube in a Sphere}
\begin{luadraw}{name=cube_in_sphere}
local g = graph3d:new{window={-9,9,-4,5},viewdir={25,70},size={16,8}}
require 'luadraw_spherical'
arrowBstyle = "-stealth"
g:Linewidth(6); Hiddenlinestyle = "dashed"
local a = 4
local O = Origin
local cube = parallelep(O,a*vecI,a*vecJ,a*vecK)
local G = isobar3d(cube.vertices)
cube = shift3d(cube,-G) -- to center the cube at the origin
local R = pt3d.abs(cube.vertices[1])

local dessin = function()
    g:DSpolyline({{O,5*vecI},{O,5*vecJ},{O,5*vecK}},{arrows=1, width=8}) -- axes
    g:DSplane({a/2*vecK,vecK},{color="blue",scale=0.9,angle=20}); 
    g:DScircle({-a/2*vecK,vecK},{color="blue"})
    g:DSpolyline( facetedges(cube) ); g:DSlabel("$O$",O,{pos="W"})
    g:Dspherical()
end

g:Saveattr(); g:Viewport(-9,0,-4,5); g:Coordsystem(-5,5,-5,5)
Hiddenlines = true; g:Define_sphere({radius=R})
dessin()
g:Dlabel3d("$x$",5*vecI,{pos="SW"},"$y$",5*vecJ,{pos="E"},"$z$",5*vecK,{pos="N"})
g:Dlabel("Hiddenlines=true",0.5-4.5*cpx.I,{})
g:Restoreattr()

clear_spherical() -- deletes previously created objects

g:Saveattr(); g:Viewport(0,9,-4,5); g:Coordsystem(-5,5,-5,5)
Hiddenlines = false; g:Define_sphere({radius=R,opacity=0.7} )
dessin()
g:Dlabel3d("$x$",5*vecI,{pos="SW"},"$y$",5*vecJ,{pos="E"},"$z$",5*vecK,{pos="N"})
g:Dlabel("Hiddenlines=false, opacity=0.7",0.5-4.5*cpx.I,{})
g:Restoreattr()
g:Show()
\end{luadraw}
\end{demo}

\paragraph{Spherical curve}

\begin{demo}{Viviani window}
\begin{luadraw}{name=courbe_spherique}
local g = graph3d:new{window={-4.5,4.5,-4.5,4.5},viewdir={30,60},margin={0,0,0,0},size={10,10}}
require 'luadraw_spherical'
arrowBstyle = "-stealth"
g:Linewidth(6); Hiddenlinestyle = "dotted"
Hiddenlines = false; 
local C = cylinder(M(1.5,0,-3.5),1.5,M(1.5,0,3.5),35,true)
local L = parametric3d( function(t) return Ms(3,t-math.pi/2,t) end, -math.pi,math.pi) -- la courbe
g:Define_sphere()
g:DSpolyline(facetedges(C),{color="gray"}) -- affichage cylindre
g:DSpolyline({{-5*vecI,5*vecI},{-5*vecJ,5*vecJ},{-5*vecK,5*vecK}},{arrows=1}) --axes
Hiddenlines=true; g:DScurve(L,{width=12,color="blue"}) -- courbe avec partie cachée
g:Dspherical()
g:Show()
\end{luadraw}
\end{demo}

To avoid compromising the readability of the drawing, the hidden parts have not been displayed except for the curve.

\paragraph{A spherical tiling}

\begin{demo}{A spherical tiling}
\begin{luadraw}{name=pavage_spherique}
local g = graph3d:new{window={-3,3,-3,3},viewdir={30,60},size={10,10}}
require 'luadraw_spherical'
require "luadraw_polyhedrons"
g:Linewidth(6); Hiddenlines = true; Hiddenlinestyle = "dotted"
local P = poly2facet( octahedron(Origin,sM(30,10)) )
local colors = {"Crimson","ForestGreen","Gold","SteelBlue","SlateGray","Brown","Orange","Navy"}
g:Define_sphere()
for k,F in ipairs(P) do
    g:DSfacet(F,{fill=colors[k],style="noline",fillopacity=0.7})  -- facettes sans les bords
end
for _, A in ipairs(facetedges(P)) do
    g:DSarc(A,1,{width=8}) -- each edge is an arc of a great circle
end
g:Dspherical()
g:Show()
\end{luadraw}
\end{demo}

For this spherical tiling, we chose a regular octahedron with a center identical to that of the sphere and with one vertex on the sphere (and therefore all vertices are on the sphere).

\paragraph{Tangents to the sphere from a point}

\begin{demo}{Tangents to the sphere from a point}
\begin{luadraw}{name=tangent_to_sphere}
local g = graph3d:new{window={-4,5.5,-4,4},viewdir={30,60},size={10,10}}
require 'luadraw_spherical'
Hiddenlines=true; g:Linewidth(6)
local O, I = Origin, M(0,6,0)
local S,S1 = {O, 3}, {(I+O)/2,pt3d.abs(I-O)/2}
-- the circle of tangency is the intersection between spheres S and S1
local C,r,n = interSS(S,S1) 
local L = circle3d(C,r,n)[1] -- list of 3d points on the circle
local dots, lines = {}, {}
-- draw
g:Define_sphere({opacity=1})
g:DScircle({C,n},{color="red"})
for k = 1, math.floor(#L/4) do
    local A = L[4*(k-1)+1]
    table.insert(dots,A)
    table.insert(lines,{I, 2*A-I})
end
g:DSpolyline(lines ,{color="gray"})
g:DSstars(dots) -- drawing points on the sphere
g:DSdots({O,I});  -- points in the scene
g:DSlabel("$I$",I,{pos="S",node_options="red"},"$O$",O,{})
g:Dspherical()
g:Dseg3d({O,dots[1]},"gray,dashed"); g:Dangle3d(O,dots[1],I,0.2,"gray")
g:Show() 
\end{luadraw}
\end{demo}

\paragraph{Inverse Stereography}

\begin{demo}{\emph{DSinvstereo\_curve} and \emph{DSinvstereo\_polyline} methods}
\begin{luadraw}{name=stereographic_curve}
local g = graph3d:new{window3d={-5,5,-2,2,-2,2},window={-4.25,4.25,-2.5,2},size={10,10}, viewdir={40,70}}
Hiddenlines = true; Hiddenlinestyle="dashed"; g:Linewidth(6)
require 'luadraw_spherical'
local C, R = Origin, 1
local a = -R
local P = planeEq(0,0,1,-a)
local L = {M(2,0,a), M(2,2.5,a), M(-1,2,a)}
local L2 = circle3d(M(2.25,-1,a),0.5,vecK)[1]
local A, B = (L[2]+L[3])/2, L2[20]
local a,b = table.unpack( inv_projstereo({A,B},{C,R},C+R*vecK) )
g:Dplane(P,vecJ,6,6,15,"draw=none,fill=Beige")
g:Define_sphere( {center=C,radius=R, color="SlateGray!30", show=true} )
g:DSpolyline(L,{color="blue",close=true}); g:DSinvstereo_polyline(L,{color="red",width=8,close=true})
g:DSpolyline(L2,{color="Navy"}); g:DSinvstereo_curve(L2,{color="Brown",width=6})
g:DSplane(P,{scale=1.5})
g:DSpolyline({{C+R*vecK,A},{C+R*vecK,B}}, {color="ForestGreen",width=8})
g:DSpolyline({{-vecK,2*vecK}}, {arrows=1})
g:DSstars({C+R*vecK,a,b}, {scale=0.75})
g:Dspherical()
g:Dballdots3d({A,B},"ForestGreen",0.75)
g:Show()
\end{luadraw}
\end{demo}


\subsection{The \emph{luadraw\_palettes} Module}

The \emph{luadraw\_palettes} Module\footnote{This module is a contribution of \href{https://github.com/projetmbc/for-writing/tree/main/@prism}{Christphe BAL}.} defines $261$ color palettes, each with a name. A palette is a list (table) of colors, which are themselves lists of three numerical values ​​between $0$ and $1$ (red, green, and blue components). All pallets have the prefix "pal", the list of these palettes, as well as their rendering, can be viewed in this \href{luadraw_palettes_more.pdf}{document}. The extension also provides the \emph{getPal(name,options)} function, an example of which is shown below:
\begin{Luacode}
BlackbodyTransformed = getPal(
    "Blackbody", -- palette name without the prefix pal
    {
    extract = {2, 5, 8, 9}, -- color numbers to extract
    shift = 1, -- offset among the extracted colors, which gives here: 5,8,9,2
    reverse = true -- reversing the order, which gives here: 2,9,8,5
    }
)
\end{Luacode}



\subsection{The \emph{luadraw\_compile\_tex} module}

\textbf{Warning}: This module requires that the programs \emph{pdf2ps} and \emph{pstoedit} be installed on your system.

This module allows you to:

\begin{enumerate}
\item compile a text fragment in TeX,
\item convert the resulting file into an \emph{eps} file containing "flattened PostScript",
\item read the content of the \emph{eps} file and return its content as a list of paths, with the line thickness at the beginning of each path, and the fill instruction at the end.
\item The list thus obtained can be:
    \begin{enumerate}
    \item drawn on the screen,
    \item converted into 3D paths in a given plane and drawn,
    \item converted into 3D polygonal lines in a given plane (the thickness and fill command are then lost) and drawn.
    \end{enumerate}
\end{enumerate}

\subsubsection{Part One: Compilation and Reading}

\paragraph{Warning}: This step requires compiling the document with the \emph{-shell-escape} or \emph{-enable-write18} option.
Without this option, the fragment will not be compiled, which is not a problem if the \emph{<filename>.eps} file already exists and you did not intend to modify it.

The first step is handled by the \textbf{compile\_tex(text,filename)} function. The \emph{text} argument is a string; this is the fragment to be compiled. The optional \emph{filename} argument is also a string; this is the name of the file that will be created. This name must not contain \textbf{a path or an extension}. By default, this name is \emph{"tex2FlatPs"}. It is created in the current directory (but will then be deleted). The process unfolds in several steps:

\begin{enumerate}
    \item Creation of the TeX file. This uses two global variables:\par
    \verb|preamble = "\\documentclass[12pt]{article}\n"|\par
    \verb|usepackage = "\\usepackage{amsmath,amssymb}\n\\usepackage{fourier}\n"|\par
    Compilation is performed with \emph{pdflatex}.
    \item The resulting file is converted to PostScript using the \emph{pdf2ps} utility.
    \item The resulting PS file is then converted using the \emph{pstoedit} utility into an EPS file in flattened PostScript (all content is in the form of paths).
    \item The resulting file \emph{<filename>.eps} is copied to the working directory of \emph{luadraw} (the name of this directory is in the global variable \emph{cachedir}), and all compilation remnants are erased.
    \item The contents of the file thus created are automatically read by the function \emph{read\_compiled\_tex(filename)}, which returns a list of paths. Each path is a list starting with the line thickness, followed by dots and instructions like a regular path, and ending with the fill command (\emph{"fill"}, \emph{"eofill"}, or \emph{"stroke"}).
\end{enumerate}

\subsubsection{Part Two: Using the Result}

\paragraph{In 2D} The result can be drawn using the method \textbf{g:Dcompiled\_tex(anchor, L, options)} where \emph{L} is the result returned by the function \emph{compile\_tex()}. The \emph{anchor} argument is a complex number; it represents the center of the bounding box of the drawing contained in \emph{L}. The \emph{options} argument is a table whose fields are:
\begin{itemize}
    \item \opt{scale =} (1), allows you to adjust the size of the drawing, this option can be a number or a table of two numbers: \emph{\{scaleX, scaleY\}},
    \item \opt{color =} (current default color),
    \item \opt{dir =} (nil), a table consisting of two vectors \emph{\{v1, v2\}} indicating the writing direction (nil means the usual direction, which corresponds to the table \emph{\{1, cpx.I\}}),
    \item \opt{hollow =} (false), enables or disables the filling of shapes. With the value \emph{true}, only the outlines are drawn. 
    \item \opt{drawbox =} (false): allows you to draw or not draw the bounding box,
    \item \opt{draw\_options =} (""): string containing the options that will be be passed directly to the \emph{\backslash draw} command.
\end{itemize}


The result can also be transformed into a polygonal line using the function \textbf{compiled\_tex2polyline(L,scale)} where \emph{L} is the result returned by the \emph{compile\_tex()} function. The optional argument \emph{scale} allows you to adjust the size; it can be a number or a table of two numbers: \emph{\{scaleX, scaleY\}}.

\begin{demo}{Example with \emph{compile\_tex} in 2d}
\begin{luadraw}{name=compile_tex2d}
local g = graph:new{bbox=false}
require 'luadraw_compile_tex'
local i = cpx.I
local text = "\\[\\int_0^{+\\infty} e^{-\\frac{x^2}2}dx = \\frac{\\sqrt{2\\pi}}2\\]" -- text to compile
local L = compile_tex(text,"gauss_integral") -- compile with -shell-escape the first time to create the file
g:Shift(2*i) -- a first drawing
g:Dcompiled_tex(0,L,{scale=2,hollow=true, drawbox=true, draw_options="fill=pink", dir={1-i/4,i}}) -- we draw L

g:Shift(-4*i) -- a second drawing
L = compiled_tex2polyline(L,{3,3}) -- L is converted to a polygonal line
local f = function(z) return Z(z.re,z.im+math.sin(z.re*1.5)) end  -- this function produces sinusoidal waves
L = ftransform(L,f) -- we apply f to L
g:Dpath( polyline2path(L), 'draw=none,fill=blue') -- we draw L as a path
g:Show()
\end{luadraw}
\end{demo}


\paragraph{In 3D} The result can be converted to 3D using the method \textbf{g:Compiled\_tex2path3d(L,options)} where \emph{L} is the result returned by the function \emph{compile\_tex()}. The \emph{options} argument is a table whose fields are:
\begin{itemize}
    \item \opt{scale =} (1), allows you to adjust the size of the drawing, this option can be a number or a table of two numbers: \emph{\{scaleX, scaleY\}},
    \item \opt{anchor =} (Origin), 3D point which represents the center of the bounding box of the drawing,
    \item \opt{color =} (current default color),
    \item \opt{dir =} (\{vecJ,vecK\}), basis of the plane in which the result will be located (this plane will also contain the \emph{anchor} point), these two vectors indicate the direction of writing,
    \item \opt{polyline =} (false), with the value \emph{true} the returned result will be a list of lists of 3D points and can therefore be drawn with the method \emph{g:Dpolyline3d()}, however, the information: line thickness and fill command, are lost. With the value \emph{false} the result is a list of paths, each path is a list starting with the line thickness, followed by 3D points and instructions like an ordinary 3D path, and ending with the fill command (\emph{"fill"}, or \emph{"eofill"} or \emph{"stroke"}).
\end{itemize}

With the option \opt{polyline=false} (default value), the output can be drawn using the method \textbf{g:Dcompiled\_tex3d(L, options)} where \emph{L} is the result of the method \emph{g:Compiled\_tex2path3d()}. The argument \emph{options} is an array whose fields are:

\begin{itemize}
    \item \opt{color =} (default current color),
    \item \opt{hollow =} (false), enables or disables shape fills. With the value \emph{true}, only outlines are drawn,
    \item \opt{drawbox =} (false): allows you to draw or not draw the bounding box,
    \item \opt{draw\_options =} (""): string containing the options that will be passed directly to the \emph{\backslash draw} command. 
\end{itemize}

\begin{demo}{Write on a cylinder}
\begin{luadraw}{name=compile_tex3d}
local g = graph3d:new{ window={-3,3,-4,4}, margin={0,0,0,0}, size={10,10}, viewdir={-50,60}}
require 'luadraw_compile_tex'

function curve_on_cylinder(curve,cylinder,screenNormal) 
-- curve is a 3d polyline on a cylinder,
-- cylinder = {A,r,B}
-- this function separate the visible part from the hidden part of the curve
    local A,r,B = table.unpack(cylinder)
    local U = B-A
    local visible_function = function(N)
        local I = dproj3d(N,{A,U})
        return (pt3d.dot(N-I,screenNormal) >= 0)
    end
    return split_points_by_visibility(curve,visible_function)
end

local A, r, B = -3*vecK, 2, 2.5*vecK -- the cylinder
local text = "Euler theorem: \\par \\(e^{i\\pi}=-1\\)"
local L = compile_tex(text, "essai") -- compile with shell-escape the first time to create "essai.eps" file 
local C = g:Compiled_tex2path3d(L,{scale=3, anchor=M(r,0,0), dir={vecJ,vecK}, polyline=true})
-- C is the text converted into 3d polylines, in the plane passing through anchor and basic direction dir, with a scale of 3.

local f = function(A) return Mc(r,A.y/r,A.z) end -- returns the image of a point A on the cylinder by winding
C = ftransform3d(C,f) -- plane curve -> cylindrical curve transformation
local Cv, Ch = curve_on_cylinder(C, {A,r,B}, g.Normal) -- visible part and hidden part of C, this may take some time
Ch = polyline2path(Ch) -- hidden part, conversion to path
g:Dpath3d(Ch, "draw=none,fill=red!30") -- hidden part first
g:Dcylinder(A,r,B,{color="blue",opacity=0.5}) -- cylinder
Cv = polyline2path(Cv) -- visible part, conversion to path
g:Dpath3d(Cv, "draw=none,fill=red")
g:Show()
\end{luadraw}
\end{demo}

\subsection{The \emph{luadraw\_cvx\_polyhedra\_nets} module}

\subsubsection{Basic Function}

The module \emph{luadraw\_cvx\_polyhedra\_nets} allows you to \og unfold\fg\ a \textbf{convex} polyhedron to obtain a net. The function that performs the unfolding is:\par
\hfil \textbf{unfold\_polyhedron(P, options)}\hfil\par
The argument \emph{P} must be a convex polyhedron. The argument \emph{options} is a table allowing you to adjust certain parameters. These are as follows (with their default values ​​in parentheses):

\begin{itemize}
    \item \opt{opening = 1}, a value between $0$ and $1$ representing the "opening rate". With the value $1$, the polyhedron is fully unfolded; the facets returned by the function will therefore all be in the same plane. With the value $0$, the function returns the polyhedron's faces without modification.

    \item \opt{root = 1}, the number of the polyhedron face that will serve as the root, because the function represents the polyhedron as a tree by determining, for each face, its neighbors (adjacent facets), as well as any shared edges and angles. This option allows you to choose the face that will serve as the starting point.

    \item \opt{model = nil}, a list of facet number lists to impose a pattern model, for example \emph{model=\{ \{1,6\},\{1,3\},\{1,4\},\{1,5,2\}\}}, the sublist \emph{\{1,5,2\}} means that facet $1$ is the ancestor of facet $5$, and that facet $5$ is the ancestor of facet $2$, that is to say that facets $5$ and $1$ are adjacent, and facet $5$ will rotate around its common edge with facet $1$ (same for $5$ and $2$). For the model to be consistent, all facets of the polyhedron EXCEPT one (which will be the facet \emph{root}), must have one and only one ancestor; If facets $1$ and $5$ are not adjacent in the polyhedron, the function stops and displays an error in the terminal. When the \emph{model} option is set to \emph{nil} (the default value), the algorithm calculates a consistent model itself.

    \item \opt{to2d = false}, is a boolean value that returns a 2D version of the pattern in the screen plane coordinate system. With the value \emph{true}, the \emph{opening} option automatically takes the value $1$, and the facets returned by the function will have vertices expressed as complex numbers.

    \item \opt{tabs = false}, is a boolean value that allows adding or excluding tabs from the pattern in the 2D version. With the value \emph{true}, the \emph{to2d} option automatically takes the value \emph{true} as well. The facets returned by the function will have vertices expressed as complex numbers in the screen coordinate system, and the function also returns a 2D polygonal line representing tabs for certain edges (these are determined automatically).

    \item \opt{tabs\_wd = 0.2}, a numeric value representing the thickness of the tabs when the \emph{tabs} option is set to \emph{true}.

    \item \opt{tabs\_lg = 0.5}, a numerical value between $0$ and $1$, determines the length of the shorter side of the tabs. This length is equal to the length of the edge (which is the longer side) multiplied by \emph{tabs\_lg} (when the \emph{tabs} option is set to \emph{true}).

    \item \opt{rotate = 0}, when the \emph{to2d} option is set to \emph{true}, rotates the drawing by an angle equal to \emph{rotate} (in degrees) around its center. In the 3D version, the drawing is rotated by an angle equal to \emph{rotate} (in degrees) around the axis passing through the centroid of the facet \emph{root} and oriented by a normal vector to this facet pointing outwards from the polyhedron.
\end{itemize}



The function returns a table containing the following fields:

\begin{itemize}
    \item The field \emph{facets}: which contains the list of facets, with vertices in 2D (complex numbers) if the \emph{to2d} option is \emph{true}, or vertices in 3D (3D points) otherwise.

    \item The field \emph{tree}: which is a list of the form: \par\hfil\emph{\{ \{ancestor,n1,n2,angle,vertices\}, ...\} }\hfil\par
    Each element of this list represents a facet, with the following information for each facet:
    \begin{itemize}
        \item \emph{ancestor}: the number of the ancestor facet, its position in the list \emph{tree} (the facet that served as the root has the number $0$ as its ancestor, which does not correspond to any facet).
        \item \emph{n1, n2}: the number of the vertices of the ancestor facet representing the common edge.

        \item  \emph{angle}: the angle in degrees with the ancestor facet.

        \item  \emph{vertices}: the list of vertices (3D points) of the facet.
    \end{itemize}

    \item The \emph{bounds} field: which contains, as a list, the bounding box of the facets (either 2D or 3D)
    
    \item When the \emph{tabs} option is set to \emph{true}, there are two additional fields in the result:
    \begin{itemize}
        \item The \emph{tabs} field: which contains a 2D polygonal line (a list of lists of complex numbers) representing the tabs, only when the \emph{tabs} option is set to \emph{true}.

        \item The \emph{twins} field: which contains a list of the form \emph{\{ \{\{a1,b1\},\{a2,b2\}\}, ... \}} representing the list of twin edge pairs (twin edges coincide when the polyhedron is closed). \emph{a1}, \emph{b1}, \emph{a2}, \emph{b2} are complex numbers representing the endpoints of the edges in the 2D version of the polyhedron net. This list is calculated only when the \emph{tabs} option is set to \emph{true}. 
    \end{itemize} 
\end{itemize}

\subsubsection{The Drawing Method}

This is the method \textbf{g:Dpolyhedron\_net(P, options)} where \emph{P} denotes a convex polyhedron. The options are those of the previous function, plus the following:

\begin{itemize}
    \item In the case of a 2D pattern (when the \emph{to2d} option, or the \emph{tabs} option, has the value \emph{true}):
    \begin{itemize}
        \item \opt{facet\_name = false}, with the value \emph{true} the facet number (preceded by the letter F) will be displayed in the center of each facet.

        \item \opt{edge\_name = false}, with the value \emph{true}, the edge number (preceded by the letter 'e') will be displayed in the center of each edge, allowing you to identify twin edges and therefore neighboring facets.

        \item \opt{tabs\_options = ""}, string representing TikZ drawing options for the tabs if the \emph{tabs} option has the value \emph{true}.

        \item \opt{facet\_options = ""}, string representing TikZ drawing options for the \emph{g:Dpolyline()} method that will draw the facets. 
    \end{itemize}

    \item In the case of a 3D pattern, there is only the following additional information:
    \begin{itemize}
        \item \opt{facet\_options = \{\}}, a list of drawing options for the \emph{g:Dfacet()} method that will draw the facets.
    \end{itemize}
\end{itemize}

The drawing is accompanied by a display in the terminal of its 2D bounding box.

    
\subsubsection{Examples}

In this example, we display the default 2D net of a parallelepiped $P$ with hatched tabs, the facet numbers (this number is the position in the \emph{P.facets} list), and the edge numbers to see which ones need to be glued together:

\begin{demo}{Net of a parallelepiped}
\begin{luadraw}{name=parallelep_net}
local g = graph3d:new{viewdir={30,60},window={-8.5,8,-5,5},bbox=false, size={10,10}}
require 'luadraw_cvx_polyhedra_nets'
P = parallelep(Origin, 4*vecI,5*vecJ,3*vecK)
g:Dpolyhedron_net(P, {tabs=true, tabs_options="pattern=north west lines, pattern color=gray", facet_options="fill=Orange!30", facet_name=true, edge_name=true})
g:Show()
\end{luadraw}
\end{demo}

The default pattern here would correspond to the option \emph{model=\{\{1,3\},\{1,4\},\{1,5\},\{1,6\},\{3,2\}\}}\footnote{The algorithm takes the first face, then looks for its neighbors, then the neighbors of the first neighbor, etc.}, but we might want to impose a different model, for example, with the same parallelepiped:

\begin{demo}{Imposed pattern of a parallelepiped}
\begin{luadraw}{name=parallelep_net2}
local g = graph3d:new{viewdir={30,60},window={-9,9,-5,5},bbox=false,size={10,10}}
require 'luadraw_cvx_polyhedra_nets'
P = parallelep(Origin, 4*vecI,5*vecJ,3*vecK)
g:Dpolyhedron_net(P, {model={{4,6,1,3,2,5}},tabs=true, tabs_options="pattern=north west lines, pattern color=gray", facet_options="fill=Orange!30", facet_name=true, edge_name=true, rotate=-90})
g:Show()
\end{luadraw}
\end{demo}

Here is an example with a truncated parallelepiped that is half-unfolded:

\begin{demo}{Half unfolded truncated parallelepiped}
\begin{luadraw}{name=parallelep_net3}
local g = graph3d:new{window={-9,15,-9,9,0.6,0.6},bg="lightgray", viewdir={30,60}, margin={0,0,0,0}} 
require 'luadraw_cvx_polyhedra_nets'
P = parallelep(Origin, 4*vecI,5*vecJ,3*vecK)
local A, B, C = M(4,2.5,3), M(2,5,3), M(4,5,1.5)
P = cutpoly(P, plane(A,B,C), true) -- P is truncated with a plane
g:Shift3d(M(0,-4,5))
g:Dpolynames(P,"facet") -- this function shows facet numbers of P
-- half unfolded P
g:Shift3d(M(0,0,-11))
g:Dpolyhedron_net(P,{opening=0.5, facet_options={color="Crimson", opacity=0.7, edgecolor="Gold", edgewidth=8}})
-- 2d net
g:Shift(10)
g:Dpolyhedron_net(P,{tabs=true, tabs_options="pattern=north west lines, pattern color=gray", facet_name=true, rotate=90})
g:Show()
\end{luadraw}
\end{demo}

\paragraph{NB:} The functions \textbf{unfold\_polyhedron} and \textbf{g:Dpolyhedron\_net} apply to any convex polyhedron, but they will not give the expected result with a non-convex polyhedron.

\subsubsection{The \emph{unfold\_tree()} function}

It can be useful to retrieve the tree generated by the \textbf{unfold\_polyhedron} function to avoid recalculating it multiple times, for example, during an animation. The \textbf{unfold\_tree(tree,opening,num)} function also allows you to unfold the polyhedron. The argument \emph{tree} is the tree provided by the \emph{unfold\_polyhedron} function, the optional argument \emph{opening} is a number between $0$ and $1$ that represents the opening rate ($1$ by default), the optional argument \emph{num} is the number of the facet you want to open (and all descendants of that facet will rotate in the same way), when this argument is omitted, all facets rotate.


\paragraph{Example of animation:}

\begin{Luacode}
\begin{luacode*}
nbimages = 70 -- must be global
-- images creation
local g = graph3d:new{ viewdir=perspective("central",30,60), bg="gray", size={10,10}, margin={0,0,0,0} }
-- declarations
require 'luadraw_polyhedrons'
require 'luadraw_cvx_polyhedra_nets'
local p = linspace(0,1,36)
local T = linspace(0,360,nbimages+1)
local P = dodecahedron(Origin, -2*vecI)
local net = unfold_polyhedron(P)
local tree = net.tree
-- create the image number k, this function must be global
function makeframe(k) 
    local r = k
    if k > 36 then r = 72-k end
    local P1 = rotate3d( unfold_tree(tree,p[r]), T[k], {Origin,vecK})
    g:Dfacet(P1, {color="Crimson", edgecolor="Gold", edgewidth=8})
    -- send image number k
    g:Sendtotex()  -- send the tikzpicture to TeX
    g:Cleargraph()  
end
\end{luacode*}
\end{Luacode}

The \TeX\ code (with the \emph{animate} package):

\begin{TeXcode}
\def\nb{\directlua{tex.print(nbimages)}}
\def\makeframe#1{\directlua{makeframe(#1)}}%

\begin{animateinline}[poster=first,controls,loop]{8}
\multiframe{\nb}{ik=1+1}{%
\makeframe{\ik}%
}%
\end{animateinline}
\end{TeXcode}

\begin{luacode*}
nbimages = 70
-- images creation
local g = graph3d:new{ viewdir=perspective("central",30,60), bg="gray", size={10,10}, margin={0,0,0,0} }
-- declarations
require 'luadraw_polyhedrons'
require 'luadraw_cvx_polyhedra_nets'
local p = linspace(0,1,36)
local T = linspace(0,360,nbimages+1)
local P = dodecahedron(Origin, -2*vecI)
local net = unfold_polyhedron(P)
local tree = net.tree
-- create the image number k, this function must be global
function makeframe(k) -- do not modify this line
    local r = k
    if k > 36 then r = 72-k end
    local P1 = rotate3d( unfold_tree(tree,p[r]), T[k],{Origin,vecK})
    g:Dfacet(P1, {color="Crimson", edgecolor="Gold", edgewidth=8})
    -- send image number k
    g:Sendtotex()  -- do not modify
    g:Cleargraph() -- do not modify
end
\end{luacode*}

\def\nb{\directlua{tex.print(nbimages)}}%
\def\makeframe#1{\directlua{makeframe(#1)}}%

The result :

\begin{minipage}{0.9\textwidth}
\begin{center}
\captionof{figure}{Unfolding a dodecahedron}
\begin{animateinline}[poster=first,controls,loop]{8} %palindrome
\multiframe{\nb}{ik=1+1}{%
\makeframe{\ik}%
}%
\end{animateinline}
\end{center}
\end{minipage}


\subsection{The \emph{luadraw\_fields} module}

This module contains the functions and methods introduced at the end of Chapter~$1$ for drawing vector fields and gradient fields. It includes:

\begin{itemize}
    \item The function \textbf{field(f,x1,x2,y1,y2,grid,length)}, which returns the vector field (a list of line segments). The argument \emph{f} is a function \(f\colon (x,y)\mapsto f(x,y)\in\mathbf{R}^2\) (\(f(x,y)\) is a list of two real numbers). The field is computed over the rectangle \([x_1;x_2]\times[y_1;y_2]\). The argument \emph{grid}, which defaults to \emph{\{25,25\}}, specifies the number of subdivisions of the intervals \([x_1;x_2]\) and \([y_1;y_2]\). The argument \emph{length} allows one to fix the vector length (all vectors have the same norm); by default, a suitable length is computed from the step sizes along both axes.
    
    \item The method \textbf{g:Dvectorfield(f,options)} draws the vector field associated with the function \(f\). The argument \emph{options} is a table whose fields define the parameters (with their default values):
        \begin{itemize}
            \item \opt{view = default window}: a list of the form \{x1,x2,y1,y2\} defining the rectangle \([x_1;x_2]\times[y_1;y_2]\). By default, this is the window selected when the graph was created.
            \item \opt{grid = \{25,25\}}: a list of two integers defining the number of subdivisions along each axis.
            \item \opt{length = }: allows one to impose the vector length; by default, the length is computed from the step sizes along both axes.
            \item \opt{draw\_options = ""}: a string containing the drawing options passed to \texttt{tikz}.
        \end{itemize}
        
    \item The method \textbf{g:Dgradientfield(f,options)} draws the gradient field associated with the \textbf{scalar} function \(f\colon (x,y)\mapsto f(x,y)\in\mathbf{R}\). The argument \emph{options} is the same as in the \emph{Dvectorfield} method.
\end{itemize}

An example of both methods has already been given on page~\pageref{fields}.



\subsection{The \emph{luadraw\_shadedforms} module}

This module allows you to draw polygonal lines or fill a shape using a color gradient.

This module loads the \emph{luadraw\_palette} extension.

\subsubsection{Dshadedpolyline}

The function \textbf{g:Dshadedpolyline(L, palette, options)} enables the rendering of a two-dimensional polygonal line (\emph{L}) with a continuous color gradient determined by the computational method and the selected \emph{palette}. The argument \emph{L} may be either a list of complex numbers or a list of lists of complex numbers. The \emph{palette} is a list of colors, each color being represented as a list of three real numbers between \(0\) and \(1\), corresponding respectively to the red, green, and blue components. The argument \emph{options} is a table whose fields define the parameters (with their default values) as follows:
\begin{itemize}
    \item \opt{values = "x"} — for each point in \emph{L}, a numerical value is computed, which determines the associated color according to the chosen palette. The \emph{values} option specifies the evaluation mode and may take one of the following forms:
        \begin{itemize}
            \item "x" (default): the value corresponds to the point’s abscissa;
            \item "y": the value corresponds to the point’s ordinate;
            \item a function \(f\colon(x,y)\mapsto f(x,y)\in\mathbf{R}\): the value for each point \((x,y)\) in \emph{L} is given by \(f(x,y)\).
        \end{itemize}
    \item \opt{width = current line width} — specifies the line thickness in tenths of a point (default: current line width).
    \item \opt{close = false} — a Boolean value indicating whether the polygonal line should be closed.
    \item \opt{clip = nil} — this option can be either \emph{nil} (default) or a table \emph{\{x1, x2, y1, y2\}}. In the former case, the line is clipped by the current two-dimensional window \textbf{after} applying the graph’s 2D transformation matrix; in the latter, the line is clipped by the window \([x_1, x_2]\times[y_1, y_2]\) \textbf{before} the transformation.
\end{itemize}

This procedure transforms \emph{L} into a sequence of trapezoids, which are subsequently filled using a smooth color gradient.

\begin{demo}{Shaded polyline}
\begin{luadraw}{name=shading_polyline}
local i = cpx.I
local g = graph:new{size={10,10},bg="lightgray", margin={0,0,0,0}}
require 'luadraw_shadedforms'
-- first example diff. equation y'= x^2+y^2-1 (=f(x,y))
local x1,x2,y1,y2 = -3,3,-3,3
local A = Z(0,1/2) -- initial condition
local f = function(x,y) 
    return x^2+y^2-1
end
local S = odesolve(f, A.re, A.im, x1, x2, 150) -- S is a matrix {X,Y}
local L = {} -- to convert {X,Y} into the complex numbers list L
for k = 1, #S[1] do table.insert(L, Z(S[1][k],S[2][k])) end 
L = clippolyline(L,-2.5,2.4,y1,y2)[1] -- L is the solution curve
g:Dshadedpolyline(L, palRainbow, {values=f, width=12}) -- solution drawn with rainbow color map using function f
-- second example
L = polar(function(t) return 2*math.cos(3*t) end, -math.pi, math.pi)
local f = function(x,y) return cpx.abs(Z(x,y)) end -- here the value will be the modulus
g:Shift(2-2.5*i)
g:Dshadedpolyline(L, palAutumn, {values=f, width=12})
-- third example
g:Shift(-4.5+5*i)
g:Dshadedpolyline( polyreg(0,2,8), palGasFlame, {values="y", width=24, close=true})
g:Show()
\end{luadraw}
\end{demo}

\subsubsection{Dcolorbar}

The method \textbf{g:Dcolorbar(A,pal,options)} allows you to draw a rectangle with a color gradient from a palette, optionally with a gradation. The argument \emph{A} is a complex number; it is the reference point for constructing the rectangle. The argument \emph{pal} is a color palette (a list of lists of the form \{r,g,b\} where r, g, and b are between $0$ and $1$). The argument \emph{options} is an array whose fields define the parameters, which are (with their default values):

\begin{itemize}
    \item \opt{minmax = \{0,1\}}, a list containing the minimum value (which will be assigned to the first color of the palette) and the maximum value (which will be assigned to the last color of the palette). Thus, any numeric value between \emph{min} and \emph{max} corresponds to a color in the palette.

    \item \opt{dir = cpx.I}, direction of the longer side of the rectangle (this vector is automatically normalized), so by default the rectangle is vertical.

    \item \opt{length = 8}, length of the rectangle.

    \item \opt{width = 0.5}, width of the rectangle. The vertices of the rectangle are:\par
\hfil\verb|A, A+length*dir, A+length*dir+width*cpx.I*dir, A+width*cpx.I*dir|\hfil\par

    \item \opt{values ​​= 0}, this option allows you to define either the number of numeric values ​​displayed equally within the interval \emph{minmax} (none by default), or the list of numeric values ​​displayed (in this case \emph{values} must be a list of numeric values ​​within the interval \emph{minmax}).

    \item \opt{addvalues ​​= nil}, this option allows you to define a list of numeric values ​​to display in addition to the \emph{min} and \emph{max} values. This option takes precedence over the previous one.

    \item \opt{digits = 2}, the number of decimal places for the numeric displays.

    \item \opt{labelpos = "E"} option positions the labels relative to anchor points ("N", "NE", "E", "SE", "S", "SW", "W", "NW"). The labels are positioned along the \emph{(A, dir)} axis.
\end{itemize}

\begin{demo}{Color bars}
\begin{luadraw}{name=Dcolorbar}
local g = graph:new{size={10,10}, bbox=false}
g:Labelsize("small")
require 'luadraw_shadedforms'
g:Dcolorbar(Z(-4,-4), palRainbow)
g:Dcolorbar(Z(-2,-4), palGasFlame, {minmax={0,7},values=8})
g:Dcolorbar(Z(-1,1), palAutumn, {dir=1,length=6,width=1,addvalues={0.25,0.5,0.75},labelpos="S"})
g:Dcolorbar(Z(-1,-1), palViridis, {dir=1,length=6,width=-1,addvalues={0.25,0.5,0.75},labelpos="N"})
g:Dlabel("No value", Z(-4.25,-4),{pos="S"},
  "\\parbox{1.95cm}{minmax=\\{0,7\\}\\\\values=8}", Z(-2.25,-4), {},
  "dir=1, length=6, width=1", Z(2,2), {pos="N"},
  "dir=1, length=6, width=-1", Z(2,-2),{pos="S"})
g:Show()
\end{luadraw}
\end{demo}

\subsubsection{Dshadedrectangle}

\noindent\textbf{NB}: Using this method requires the \emph{shadings} library.

The \textbf{g:Dshadedrectangle(x1,x2,y1,y2,pal,options)} method fills the rectangle [x1;x2]x[y1;y2] with a gradient of colors extracted from the \emph{pal} palette. Each point $(x,y)$ in the rectangle has a color from the palette, calculated from a value $f(x,y)$ where $f$ is a numeric function defined on the rectangle. The argument \emph{options} is a table whose fields define the parameters, which are (with their default values):

\begin{itemize}
    \item \opt{values ​​= function(x,y) return cpx.abs(Z(x,y)) end}, this option defines the function $f$ used to calculate the color of each point. The maximum value of $f$ on the rectangle will correspond to the last color in the palette, and the minimum value of $f$ will correspond to the first color in the palette.

    \item \opt{grid = \{15,15\}}, this option defines the number of subdivisions for the interval [x1;x2] and for the interval [y1;y2]. The finer the subdivision, the longer the display will take...

    \item \opt{bar = "none"} allows you to add or not add a legend using the \emph{Dcolorbar} method. This option can be: "none", "right", "bottom", "left", or "top".
    
    \item \opt{bardist = 1}, the distance between the rectangle and the legend, if there is one.

    \item \opt{baroptions = \{\}}, a list of options for the \emph{Dcolorbar} method if there is a legend.

    \item \opt{out = nil}, if a list variable is assigned to this parameter \emph{out}, then the method adds the two values ​​\emph{min} and \emph{max} of the $f$ function to this list (which allows you to retrieve these two values ​​if necessary).
\end{itemize}

\begin{demo}{Shaded rectangle}
\begin{luadraw}{name=Dshadedrectangle}
local g = graph:new{window={-4,6,-5.5,5.5}, size={10,10}, bbox=false}
require 'luadraw_shadedforms'
require 'luadraw_fields'
g:Labelsize("small")
local f = function(x,y) return {math.cos(x+y), x} end -- vector field
local Nf = function(x,y) local A = f(x,y); return cpx.abs(Z(A[1],A[2])) end -- modulus of f(x,y)
g:Dshadedrectangle(-4,4,-5,5, palPicnic, {values=Nf, bar="right", baroptions={addvalues={0.5,1.5,2.5,3.5}}})
g:Dvectorfield(f,{view={-4,4,-5,5},draw_options="-stealth"})
g:Dgradbox({Z(-4,-5),Z(4,5),1,1}, {title="vector field $f(x,y)=(\\cos(x+y),x)$"})
g:Show()
\end{luadraw}
\end{demo}

\subsubsection{Dshadedregion}

The method \textbf{g:Dshadedregion(apath,pal,options)} fills the region defined by the path \emph{apath} with a gradient of colors extracted from the palette \emph{pal}. This method uses the previous one (\emph{Dshadedrectangle}) on the rectangle defined by the bounding box of the path. Each point $(x,y)$ in this rectangle has a color from the palette, calculated from a value $f(x,y)$ where $f$ is a numeric function defined on this rectangle. The drawing is clipped to the path. The argument \emph{options} is the same as that of the previous method \emph{Dshadedrectangle}.

\begin{demo}{Shaded region}
\begin{luadraw}{name=Dshadedregion}
local g = graph:new{window={-4.5,6,-4.5,5}, size={10,10},bg="lightgray", bbox=false}
g:Labelsize("small")
require 'luadraw_shadedforms'
local L1, L2 = -2, 2
local f = function(x,y) 
    local z = Z(x,y)
    return (cpx.abs(z-L1)-cpx.abs(z-L2))^2
end
g:Dshadedregion({4,0,4,3,"e"}, getPal("Grays",{reverse=true}), {values=f, grid={20,20}})
g:Show()
\end{luadraw}
\end{demo}


\subsection{The \emph{luadraw\_povray} Module}

This module enables the creation of (relatively simple) source files for the \emph{Pov-Ray} software and allows them to be compiled on the fly, provided that the software is installed on your system and its executable path is known. Once created, the resulting image (in \emph{png} format) can be automatically included in the current graphic, allowing further drawing both underneath and on top of it.
The image is inserted with perfect alignment, meaning that the 3D reference frames of the graphic and of the image will match exactly, provided that the system operates in \textbf{orthographic projection} mode.
Source files and generated images are created in the working directory of \emph{luadraw}. The source files can of course be compiled separately by the user; the parameters to be passed to Pov-Ray are written in comments at the beginning of the source file.
The source file is divided into three parts: a preamble, the object declarations, and the rendering of those objects.

\subsubsection{Before Creating Objects}

The Pov-Ray drawing \textbf{must be initialized} using the method:
\par \hfil\textbf{g:Pov\_new(options)}.\hfil\par
The argument \emph{options} is a table whose fields (and their default values) are:
\begin{itemize}
    \item \opt{bg = ""}: this option defines the background. If it is an empty string (default), the background will be transparent (which is required if something needs to be drawn beneath the image). If it is a non-empty string, it must be the name of a color recognized by Pov-Ray. It can also be a table of the form \{r,g,b\}, representing a color with \(r\), \(g\), and \(b\) values between \(0\) and \(1\).
    \item \opt{shadow = true}: this boolean indicates whether objects should cast shadows (it can be modified locally for each object).
    \item \opt{imagescale = 1}: scales the size of the produced \emph{png} image; values greater than \(1\) will naturally increase file size.
    \item \opt{param = "-V +A +FN"}: these are the base parameters passed to Pov-Ray. Additional parameters will include image width and height, as well as "+UA" if a transparent background is required.
    \item \opt{pov\_cmd =}: the command name used to run Pov-Ray. On Unix systems, the default value is \emph{"povray"}; on Windows, it is \emph{"pvengine64.exe"}.
    \item \opt{win\_param\_ext = "/RENDER /EXIT"}: additional parameters relevant only on Windows systems.
\end{itemize}

Then Pov-Ray can be instructed to include specific \emph{*.inc} files using the method:
\par \hfil\textbf{g:Pov\_include("file1.inc", "file2.inc", ...)}.\hfil\par
For example: \verb|g:Pov_include("textures.inc", "colors.inc")|. These two files are normally distributed with Pov-Ray: the first defines textures, the second defines colors. By default, no include files are added.

\subsubsection{Creation of Objects}

Objects are created using methods following the format \textbf{g:Pov\_<command>(<data>, options)}. Each object is first declared in the Pov-Ray source file with a name (similar to a variable), and then this object is "rendered" in the third section of the source file with a texture defined from the options.

The argument \emph{options} is a table whose fields specify the parameters of the object. The following are the \textbf{parameters common to all objects}, along with their default values:
\begin{itemize}
    \item \opt{name = "object<num>"}, a string representing the name of the created object. By default, it is the word "object" followed by a number (its order of appearance). Assigning a name is useful when the object needs to be reused later.
    \item \opt{shadow = true}, a Boolean indicating whether the object casts a shadow.
    \item \opt{render = true}, a Boolean indicating whether the object should be displayed. It may be desirable not to render an object if it is only used in the construction of another one.
    \item Options defining the base texture, composed of a \emph{pigment} (color + opacity) and a \emph{finish} (ambient + diffuse + phong):
        \begin{itemize}
            \item \opt{color = White}, this option may be either a table in the form \{r,g,b\} (with $r$, $g$, and $b$ between $0$ and $1$), or a string that must represent a color known to Pov-Ray. It can also refer to a texture defined only by a \emph{pigment} (for example, \verb|color="Blue_Sky3"|, where this name is defined in the file \emph{textures.inc}).
            \item \opt{opacity = 1}, a real number between $0$ and $1$ defining the object’s opacity.
            \item \opt{ambient = 0.35}, \opt{diffuse = 0.8}, and \opt{phong = 0.5}: parameters defining the \emph{finish}.
            \item \opt{mytexture = nil}, this parameter allows specifying a texture directly as a string or referencing an existing Pov-Ray texture. In that case, the previous parameters are ignored.
        \end{itemize}
    \item \opt{matrix = nil}, a 3D transformation matrix applied locally to the object. The global 3D transformation matrix of the graphic is also taken into account.
    \item \opt{clipbox = nil}, this option defines a list (table) of objects used to clip the object being constructed. These objects may be: an existing object, referenced by its name as a string; a box, specified as a table of the form \emph{\{M(xmin, ymin, zmin), M(xmax, ymax, zmax)\}} (representing the box diagonal); or a sphere, given as a table \emph{\{center, radius\}}, where \emph{center} is a 3D point and \emph{radius} a positive number.
    \item \opt{clipplane = nil}, this option defines a list (table) of planes to clip the object being constructed. Each plane must be of the form \emph{\{A, n\}}, where \emph{A} is a point on the plane (a 3D point) and \emph{n} the normal vector to the plane. Only the part of the object lying in the half-space containing \emph{n} is preserved.
\end{itemize}

\subsubsection{List of Predefined Objects}

The following is the list of objects that can be drawn using the corresponding methods:
\begin{itemize}
    \item Implicit surfaces defined by the equation \(f(x,y,z)=0\). The corresponding method is:\par
    \hfil \textbf{g:Pov\_implicit( povfunction, luafunction, options)}\hfil

    The argument \emph{povfunction} is a string containing the expression of \(f(x,y,z)\). Pov-Ray supports standard mathematical functions; however, note that the power function is written as \emph{pow}, i.e. \(x \mapsto \mathrm{pow}(x,n)\), and that Pov-Ray does not handle numerical errors such as division by zero.

    The options are those already described, plus the specific option \opt{containedby = }, which specifies the box (or sphere) within which the computations are carried out. By default, this box is the current 3D window of the graphic. A box is given as a table of the form \emph{\{M(xinf,yinf,zinf), M(xsup,ysup,zsup)\}} (representing a diagonal of the box), and a sphere is a table of the form \emph{\{C,r\}}, where \emph{C} is the center (a 3D point) and \emph{r} the radius. Example:
    \begin{Luacode}
    local f = function(x,y,z) return x^2+y^2+z^2 - 1 end
    local r = 1.1
    g:Pov_implicit("x*x+y*y+z*z-1", f, {color=SteelBlue, containedby={M(-r,-r,-r), M(r,r,r)}})
    \end{Luacode}

    \item Parametric surfaces given by \((u,v)\mapsto (x(u,v), y(u,v), z(u,v))\). The corresponding method is:\par
    \hfil \textbf{g:Pov\_surface( xfunc, yfunc, zfunc, u1, u2, v1, v2, options)}\hfil

    The arguments \emph{xfunc}, \emph{yfunc}, and \emph{zfunc} are three strings containing the expressions of \(x(u,v)\), \(y(u,v)\), and \(z(u,v)\), respectively. The arguments \emph{u1} and \emph{u2}, and respectively \emph{v1} and \emph{v2}, define the bounds of the interval for the parameter \(u\), and respectively for the parameter \(v\). The options are those already described, plus two specific options:
    \begin{itemize}
        \item \opt{containedby = }, which specifies the box (or sphere) within which the computations are performed. By default, this box is the current 3D window of the graphic. A box is a table of the form \emph{\{M(xinf,yinf,zinf), M(xsup,ysup,zsup)\}} (representing a diagonal of the box), and a sphere is a table \emph{\{C,r\}}, where \emph{C} is the center (a 3D point) and \emph{r} the radius.
        \item \opt{max\_grad = nil}, an (optional) numerical value used to optimize the computations. Pov-Ray’s documentation describes this number as follows:
        \begin{small}
        \begin{verbatim}
The max_gradient is the maximum magnitude of all six partial derivatives 
over the specified ranges of u and v.
Take dx/du, dx/dv, dy/du, dy/dv, dz/du, and dz/dv and calculate them over 
the entire range.
The max_gradient should be at least the maximum (absolute value) of all of those values.
Choosing a too small of a value will create holes or artifacts in the object.
        \end{verbatim}
        \end{small}
    \end{itemize}
    Example:
    \begin{Luacode}
    local pi = math.pi
    local r = 1.1
    g:Pov_surface("cos(u)*sin(v)", "sin(u)*sin(v)", "cos(v)",-pi,pi,0,pi, {color=SteelBlue, containedby={M(-r,-r,-r), M(r,r,r)}})
    \end{Luacode}
    Remark: one may use \emph{"pi"} instead of \emph{pi}, since this constant is predefined in Pov-Ray. Moreover, in this example, one could add the option \emph{grad\_max=1} in view of the chosen parametrization.

    \item \textbf{Polyhedron or list of facets}. This is the method:\par
    \hfil\textbf{g:Pov\_facet(F, options)}\hfil\par
    The argument \emph{F} is either a polyhedron or a list of facets. The options include the common ones, plus the following specific options (with their default values): 
    \begin{itemize}
        \item \opt{edge = false}, boolean indicating whether edges should be drawn.
        \item \opt{edgestyle = current line style}, style of the edges.
        \item \opt{edgecolor = Black}, color of the edges.
        \item \opt{edgewidth = current line width}, width of the edges.
        \item \opt{hidden = false}, boolean indicating whether hidden edges should be drawn.
        \item \opt{hiddenstyle = Hiddenlinestyle}, style of hidden edges.
    \end{itemize}
    Example:
    \begin{Luacode}
    local T1 = tetra(M(-1,-1,-1), 3*vecI, 3*vecJ, M(1,1,3))
    g:Pov_facet(T1, {color=SteelBlue, edge=true, hidden=true})
    \end{Luacode}
    Note: drawing hidden edges is not always optimal; sometimes it is better to draw them with TikZ over the rendered image.
    
    
    \item \textbf{Polygonal line}. This is the method:\par
    \hfil\textbf{g:Pov\_polyline(L, options)}\hfil\par
    The argument \emph{L} is either a list of 3D points or a list of lists of 3D points. The options include the common ones, plus the following specific options (with their default values): 
    \begin{itemize}
        \item \opt{style = current line style}, line style.
        \item \opt{width = current line width}, line width.
        \item \opt{close = false}, boolean indicating whether the line should be closed.
        \item \opt{arrows = 0}, three possible values: $0$ (no arrow), $1$ (arrow at the end), or $2$ (arrows at both start and end).
        \item \opt{arrowscale = 1}, scale factor for arrow size.
        \item \opt{hidden = false}, boolean indicating whether hidden parts should be drawn.
        \item \opt{hiddenstyle = Hiddenlinestyle}, style of hidden parts.
    \end{itemize}
    Example: drawing the axes
    \begin{Luacode}
    g:Pov_polyline({{-5*vecI,5*vecI},{-5*vecJ,5*vecJ},{-5*vecK,5*vecK}}, {arrows=1,width=8})
    \end{Luacode}
    
    
    \item \textbf{3D points}. This is the method:\par
    \hfil\textbf{g:Pov\_dots(L, options)}\hfil\par
    The argument \emph{L} is a list of 3D points. The options include the common ones, plus the following specific options (with their default values): 
        \begin{itemize}
            \item \opt{style = "ball"}, two possible styles: "ball" (sphere) or "box" (a box with faces parallel to the 3D window).
            \item \opt{dotscale = 1}, scale factor for dot size.
        \end{itemize}
       
    \item \textbf{A plane}. This is the method:\par
        \hfil\textbf{g:Pov\_plane(P, options)}\hfil\par
    The argument \emph{P} is a table of the form \emph{\{A, n\}}, where \emph{A} is a point on the plane \(P\) (a 3D point) and \emph{n} is a vector normal to the plane. The plane is automatically clipped by the 3D window. The options are the options of \emph{Pov\_facet}, plus the specific option \opt{scale = 1}.
    
    \item \textbf{A circle}. This is the method:\par
        \hfil\textbf{g:Pov\_circle(A, R, N, options)}\hfil\par
    It draws the circle with center \emph{A}, radius \emph{R}, and normal vector \emph{N} specifying the plane of the circle. These are the common options.
    
     \item \textbf{Axes}.This is the method:\par
        \hfil\textbf{g:Pov\_axes(O,options)}\hfil\par
    It draws the axes using point $O$ as the intersection point. The options are the same as for \emph{Pov\_polyline}. There are no graduations or legend.   
    
    \item \textbf{Basic solids}. These are the methods:
        \begin{itemize}
            \item \textbf{g:Pov\_sphere(center, radius, options)}, which draws a sphere with center \emph{center} (3D point) and radius \emph{radius}. These are the common options.
    
            \item \textbf{g:Pov\_torus(center, R, r, N, options)}, which draws a torus centered at \emph{center} (3D point), with major radius \emph{R}, minor radius \emph{r}, lying in the plane normal to vector \emph{N}. These are the common options.
    
            \item \textbf{g:Pov\_cylinder(A, R, B, options)}, which draws a cylinder along the axis \emph{(AB)} from \emph{A} to \emph{B} (3D points), with radius \emph{R}. These are the common options plus the specific option \opt{hollow = false}, indicating whether the cylinder is hollow or not.
    
            \item \textbf{g:Pov\_cone(A, R, B, r, options)}, which draws a cone along the axis \emph{(AB)} from \emph{A} to \emph{B} (3D points), with radius \emph{R} at end \emph{A} and radius \emph{r} at end \emph{B}. The radius \emph{r} is optional and defaults to \(0\); in that case, \emph{B} is the apex of the cone. These are the common options plus the specific option \opt{hollow = false}, indicating whether the cone is hollow or not.
    
            \item \textbf{g:Pov\_box(A, B, options)}, which draws a box whose faces are parallel to those of the 3D window of the graphic. The 3D points \emph{A} and \emph{B} define a diagonal of the box, more precisely \emph{A = M(xinf, yinf, zinf)} and \emph{B = M(xsup, ysup, zsup)}. These are the common options.
        \end{itemize}
            
    \item \textbf{A plane}. This is the method:\par
        \hfil\textbf{g:Pov\_plane(P, options)}\hfil\par
    The argument \emph{P} is a table of the form \emph{\{A, n\}} where \emph{A} is a point on the plane \(P\) (3D point) and \emph{n} is a vector normal to the plane. The plane is automatically clipped by the 3D window. These are the common options.
    
    \item \textbf{A circle}. This is the method:\par
        \hfil\textbf{g:Pov\_circle(A, R, N, options)}\hfil\par
    It draws the circle with center \emph{A} and radius \emph{R}; the argument \emph{N} specifies a vector normal to the plane of the circle. These are the common options.
    
    \item \textbf{Basic solids}. These are the methods:
        \begin{itemize}
            \item \textbf{g:Pov\_sphere(center, radius, options)}, which draws the sphere with center \emph{center} (point3d) and radius \emph{radius}. These are the common options.
    
            \item \textbf{g:Pov\_torus(center, R, r, N, options)}, which draws the torus centered at \emph{center} (point3d), with major radius \emph{R} and minor radius \emph{r}, in the plane normal to vector \emph{N}. These are the common options.
            
            \item \textbf{g:Pov\_cylinder(A, R, B, options)}, which draws the cylinder with axis \emph{(AB)} from \emph{A} to \emph{B} (3D points), and radius \emph{R}. These are the common options plus the specific option \opt{hollow = false}, which indicates whether the cylinder is hollow or not.
    
            \item \textbf{g:Pov\_cone(A, R, B, r, options)}, which draws the cone with axis \emph{(AB)} from \emph{A} to \emph{B} (3D points), with radius \emph{R} at endpoint \emph{A} and radius \emph{r} at endpoint \emph{B}. The radius \emph{r} is optional and defaults to \(0\); in that case, \emph{B} is the apex of the cone. These are the common options plus the specific option \opt{hollow = false}, which indicates whether the cone is hollow or not.
            
            \item \textbf{g:Pov\_box(A, B, options)}, which draws a box whose faces are parallel to those of the 3D window of the graphic; the 3D points \emph{A} and \emph{B} represent a diagonal of this box, more precisely \emph{A = M(xinf, yinf, zinf)} and \emph{B = M(xsup, ysup, zsup)}. These are the common options.
        \end{itemize}
    
    \item \textbf{CSG geometry}. These are the following methods (for each of them, the options are the common options):
        \begin{itemize}
            \item \textbf{g:Pov\_union(list, options)}, where \emph{list} is a list of POV-Ray objects; these objects may be either the name of an already created object or a POV-Ray command given as a string. The result is treated as a single object.
            
            \item \textbf{g:Pov\_intersection(list, options)}, where \emph{list} is a list of POV-Ray objects; these objects may be either the name of an already created object or a POV-Ray command given as a string. The result is the common part of these objects.
            
            \item \textbf{g:Pov\_merge(list, options)}, where \emph{list} is a list of POV-Ray objects; these objects may be either the name of an already created object or a POV-Ray command given as a string. This command works like union, but removes internal surfaces (unlike union), which is useful in the case of transparency.
            
            \item \textbf{g:Pov\_difference(list, options)}, where \emph{list} is a list of \textbf{two} POV-Ray objects; these objects may be either the name of an already created object or a POV-Ray command given as a string. The result is the difference: object1 minus object2.
        \end{itemize}
    
    \item \textbf{Writing directly to the source}, with the following methods:
        \begin{itemize}
            \item \textbf{g:Pov\_comment(comment)}, which writes the string \emph{comment} to the source as a comment.
            \item \textbf{g:Pov\_special(code)}, which writes the string \emph{code} verbatim to the source; it must therefore be valid POV-Ray code. Note that a 3D point written as \emph{M(x, y, z)} in \emph{luadraw} is written in POV-Ray code as \emph{<-x, y, z>}; the POV-Ray coordinate system is thus not our usual one and is left-handed.
        \end{itemize}
\end{itemize}

\subsubsection{Save, execution, inclusion}

\begin{itemize}
    \item \textbf{Save and execution}. Once all objects have been created, saving and executing the file with Pov-Ray is done using the method:\par
    \hfil \textbf{g:Pov\_exec(filename)} \hfil\par
    The argument \emph{filename} must be a filename without path or extension, but it is optional; by default, the name of the current graphic is used. The created file will have the \emph{pov} extension and will be saved in the \emph{luadraw} working directory (this directory is stored in the \emph{cachedir} variable). The command used for execution is displayed in the terminal, along with the output from the Pov-Ray software, allowing you to see if it encountered an error. The image construction appears on screen, but the window closes as soon as rendering is complete. The image has the same name as the source, except the extension which is \emph{png} instead of \emph{pov}.
    
    \textbf{NB}: Pov-Ray execution requires compiling the document with the \emph{-shell-escape} or \emph{-enable-write18} option. Once the image is obtained, this option is no longer necessary unless the image has been modified.
    
    \item \textbf{Save only}. This is done with the method:\par
    \hfil \textbf{g:Pov\_save(filename)} \hfil\par
    With the same remarks as previously for the \emph{filename} argument.

    \item \textbf{Image inclusion}. Once obtained, the image can be included in the graphic with the method:\par
    \hfil \textbf{g:Pov\_show(filename)} \hfil\par
    If the \emph{filename} argument is not specified, it refers to the name of the current graphic; otherwise, \emph{filename} must be a complete image filename (with extension). The inclusion is done with \verb|\includegraphics[]{filename}|.
\end{itemize}

\subsubsection{Examples}

\paragraph{Intersection of two implicit surfaces}

\begin{demo}{Intersection of two implicit surfaces}
\begin{luadraw}{name=intersection_surf}
local g = graph3d:new{window3d={0,1,0,1,0,2}, window={-0.25,1.5,-0.5,2.25}, size={10,10,0}, viewdir={-50,60}}
local sqrt = math.sqrt
require "luadraw_povray"
local f = function(x,y,z) return x^3+y^3-z end
local h = function(x,y,z) return (x*sqrt(1-y^2)+y*sqrt(1-x^2))^3-z end
local L = implicit(function(x,y) return f(x,y,0)-h(x,y,0) end,0.01,1,0.01,1,{25,25})
L = map(function(z) return M(z.re,z.im,z.re^3+z.im^3) end, L[1])  -- intersection curve
-- using povray
g:Pov_exec()
g:Pov_implicit("pow(x,3)+pow(y,3)-z", f, {color=SteelBlue})
g:Pov_implicit("z-pow(x*sqrt(1-y*y)+y*sqrt(1-x*x),3)", h, {color=Crimson, containedby={M(0,0,0),M(0.999,0.999,2)}})
g:Pov_exec()
-- drawing
g:Dboxaxes3d({grid=true, gridcolor="gray",fillcolor="lightgray",xyzstep=0.5, drawbox=true})
g:Pov_show() --Pov-Ray image
g:Dpolyline3d(L, "line width=1.2pt,dotted,Navy") --we draw the curve over the image
local d = 0.1
g:Dsquare(Z(-0.25,2.25), Z(-0.25,2.25-d),1,"draw=none,fill=Crimson")
g:Dsquare(Z(-0.25,2.25-2*d), Z(-0.25,2.25-3*d),1,"draw=none,fill=SteelBlue")
g:Dlabel("$z=(x\\sqrt{1-y^2}+y\\sqrt{1-x^2})^3$", Z(-0.25+d,2.25-d/2) , {pos="E"},
    "$z=x^3+y^3$", Z(-0.25+d,2.25-5*d/2),{})
g:Show()
\end{luadraw}
\end{demo}

\paragraph{Villarceau circles}

\begin{demo}{Villarceau circles}
\begin{luadraw}{name=Villarceau_circles}
local g = graph3d:new{window={-6.5,6.5,-5,5},margin={0,0,0,0}, size={10,10}, viewdir={20,65}}
require "luadraw_povray"
local R, r = 3, 1
local N = rotate3d(vecK, math.asin(r/R)*rad, {Origin, vecJ})
local P = {Origin, -N}
-- using povray
g:Pov_new({bg=LightGray})
g:Pov_torus(Origin, R, r, vecK, {color=SteelBlue, clipplane=P})
g:Pov_plane(P,{color=SeaGreen, opacity=0.4, edge=true, scale=0.9})
g:Pov_axes(Origin,{color=Gold,arrows=1})
g:Pov_dots(Origin, {dotscale=1.5})
g:Pov_circle( M(0,r,0),R,N,{color=Crimson, width=12})
g:Pov_circle( M(0,-r,0),R,N,{color=Crimson, width=12})
g:Pov_exec()
-- drawing
g:Pov_show()
local F = g:Plane2facet(P,0.9)
g:Dpolyline3d({{-r*vecJ,-r*vecJ+vecK},{-(R+r)*vecJ,-(R+r)*vecJ+vecK}})
g:Dpolyline3d({{r*vecJ,r*vecJ+vecK},{(R+r)*vecJ,(R+r)*vecJ+vecK}})
g:Dpolyline3d({{-r*vecJ+vecK,-(R+r)*vecJ+vecK}, {r*vecJ+vecK,(R+r)*vecJ+vecK}}, "stealth-stealth")
g:Ddots3d({-r*vecJ, r*vecJ})
g:Dlabel3d("$x$",5*vecI,{pos="SW"},"$y$", 5*vecJ,{pos="SE"}, "$z$",5*vecK,{pos="N"},
"$R$", -(R/2+r)*vecJ+vecK, {}, "$R$", (R/2+r)*vecJ+vecK, {},
"bitangent plane to the torus", F[1], {pos="NW", dir={vecJ,pt3d.prod(N,vecJ)}},
"$-r$",-r*vecJ,{pos="S"}, "$r$", r*vecJ,{} )
g:Show()
\end{luadraw}
\end{demo}

\paragraph{Holes in an half sphere}

\begin{demo}{Holes in a hemisphere}
\begin{luadraw}{name=holes_in_hemisphere}
local g = graph3d:new{window={-5,5,-4,5}, size={10,10}, bg="lightgray"}
require "luadraw_povray"
local O, R = Origin, 4
local A, r = 2*R/3*vecJ, R/3
local P = {Origin, vecK}
local base = circle3d(A,r,vecK)[1] --circular base of the cylinder (list of 3d points)
local Cylborder = {}
for _, C in ipairs(base) do -- we project each point C of the base onto the half-sphere
    table.insert(Cylborder,C + math.sqrt(R^2-pt3d.abs2(C))*vecK)
end -- Cylborder is now the intersection between the half-sphere and the cylinder
-- using povray 
g:Pov_new()
g:Pov_sphere(Origin, R, {name="sph", clipplane=P, render=false}) -- only declaration
g:Pov_cylinder(A-vecK, r, A+R*vecK, {name="cyl1", render=false })
g:Pov_union({"cyl1", "cyl1 rotate 90*z"}, {name="cylext", render=false})
g:Pov_cylinder(A-vecK, r-0.001, A+R*vecK, {name="cyl2", render=false }) 
-- renderings
g:Pov_difference({"sph","cylext"}, {color=Blue, opacity=0.7})
g:Pov_union( {"cyl2", "cyl2 rotate 90*z"}, {color=LightBlue,opacity=0.8,clipbox="sph"})
g:Pov_axes(Origin,{color=Gold,arrows=1})
g:Pov_exec()
-- drawing
g:Dcircle3d(O,R,vecK,"line width=1.2pt"); g:Dcircle3d(A,r,vecK,"line width=1.2pt")
g:Dcircle3d(rotate3d(A,-90,{Origin,vecK}), r,vecK,"line width=1.2pt")
g:Pov_show()
g:Dpolyline3d( {Cylborder, rotate3d(Cylborder,-90,{Origin,vecK})}, "red, line width=1.2pt")
g:Dlabel3d("$x$",5*vecI,{pos="S"}, "$y$", 5*vecJ, {pos="SE"}, "$z$", 5*vecK, {pos="N"})
g:Show()
\end{luadraw}
\end{demo}
