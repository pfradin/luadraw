\section{Geometric Constructions}

This section groups together functions that construct geometric figures without a corresponding dedicated graphical method.

\subsection{circumcircle(), incircle()}

\begin{itemize}
\item The function \textbf{circumcircle(a,b,c)} (or \textbf{circumcircle(\{a,b,c\})}), where $a$, $b$, and $c$ are three points (three complex numbers), returns the circumcircle of the triangle formed by these three points, in the form of a sequence: $C,r$, where $C$ is the center of the circle (a complex number), and $r$ is its radius.
\item The function \textbf{incircle3d(a,b,c)} (or \textbf{incircle3d(\{a,b,c\})}), where $a$, $b$, and $c$ are three points (three complex numbers), returns the incircle of the triangle formed by these three points, as a sequence: $C,r$, where $C$ is the center of the circle (a complex number), and $r$ is its radius.
\end{itemize}

\subsection{cvx\_hull2d()}

The function \textbf{cvx\_hull2d(L)}, where $L$ is a list of complex numbers, computes and returns a list of complex numbers representing the convex hull of $L$.

\subsection{delaunay()}

The function \textbf{delaunay(L)} where \emph{L} is a list of \textbf{distinct} complex numbers, returns a list of triangles (a triangle being a list of three complex numbers) obtained by Delaunay triangulation of the points of \emph{L} (the circumcircle of each triangle does not contain any of the other points).

\begin{demo}{Delaunay Triangulation}
\begin{luadraw}{name=delaunay}
local g = graph3d:new{bbox=false, pictureoptions="scale=2"}
local i = cpx.I; g:Linewidth(6)
local L = {0.285+1.46*i,1.556-0.142*i,2.344+1.313*i,-2.38+1.218*i,1.548-0.624*i,0.969+1.819*i, -0.086-2.191*i,-0.477+1.834*i,-0.904+1.322*i,-2.892+0.025*i}
local T = delaunay(L)
local n = #T
local num = 7 -- we choose a triangle
local colors = getpalette(palGasFlame,n)
for k = 1, n do
    g:Dpolyline(T[k],true,'fill='..colors[k])
end
g:Ddots(L)
g:Dcircle( {circumcircle(T[num])}, "line width=0.4pt,gray,dashed" )
g:Ddots(T[num],"gray")
g:Show()
\end{luadraw}
\end{demo}

\subsection{voronoi()}

The function \textbf{voronoi(L, window)}, where \emph{L} is a list of distinct complex numbers, determines the Voronoi diagram of the points in the list $L$. This function returns a list of elements of the form \emph{\{A,polygon\}}, where \emph{A} is a point in the list $L$, and \emph{polygon} is a list of complex numbers representing the vertices of the cell associated with \emph{A}. Thus, there is one cell for each point in $L$. The cell for point $A$ contains the points in the plane that are closer to $A$ than to other points in $L$. This function uses Delaunay triangulation. The optional argument \emph{window}, which defaults to \emph{\{-5,5,-5,5\}}, is used to clip Voronoi cells that are unbounded; this window is automatically enlarged if necessary to contain all the points of $L$ as well as all the centers of the circles circumscribed about the Delaunay triangles (note: this does not change the 2d window of the current graph).

\begin{demo}{VoronoÃ¯ diagram}
\begin{luadraw}{name=voronoi}
local g = graph:new{ bbox=true, margin={0,0,0,0}, size={10,10}}
local i = cpx.I
local S = {0.285+1.46*i,1.556-0.142*i,2.344+1.313*i,-2.38+1.218*i,1.548-0.624*i,
    0.969+1.819*i,-0.086-2.191*i,-0.477+1.834*i,-0.904+1.322*i,-2.892+0.025*i}
local V = voronoi(S)
local colors = getpalette(rainbow,#V)
for k,T in ipairs(V) do
    local A, polygon = table.unpack(T)
    g:Dpolyline(polygon,true,"color=white, line width=1.2pt,fill="..colors[k])
    g:Ddots(A,"mark=x,white,scale=2,line width=1.2pt")-- A is one of the points of S
end
g:Dpolyline(delaunay(S),true,"dotted,line width=0.6pt") -- Delaunay triangles
g:Show()
\end{luadraw}
\end{demo}


\subsection{line2strip()}

The function \textbf{line2strip(L,width,close,ends)} where \emph{L} is a list of complex numbers, or a list of lists of complex numbers, returns a path representing a "strip" centered on \emph{L} and of width \emph{width}. The optional argument \emph{close} is a boolean that indicates whether \emph{L} should be closed (\emph{false} by default). The optional argument \emph{ends} is a boolean that indicates whether both ends of the strip should be drawn (\emph{true} by default, except when the argument \emph{close} is \emph{true}).

\begin{demo}{Example with \emph{line2strip}}
\begin{luadraw}{name=line2strip}
local g = graph:new{bbox=false, bg="lightgray"}
local i = cpx.I; g:Linewidth(8)
local p = {-3+3*i,-3,"l",0,3,3,1,"ca", 3+3*i,"l"} 
g:Setmatrix({-3+3*i,0.5,0.5*i})
local L = line2strip(path(p),1,true) -- p is first converted to polyline
g:Dpath(L,"Crimson,fill=Gold"); g:Dpath(p,"gray,dashed")
g:Dlabel("close=true",i,{})
g:Setmatrix({3+3*i,0.5,0.5*i})
local L = line2strip(path(p),1,false) -- p is first converted to polyline
g:Dpath(L,"Crimson,fill=Gold"); g:Dpath(p,"gray,dashed")
g:Dlabel("close=false",i,{}) 
g:Setmatrix({-i,0.5,0.5*i})
local L = line2strip(path(p),1,false,false) -- p is first converted to polyline
g:Dpath(L,"Crimson,fill=Gold"); g:Dpath(p,"gray,dashed")
g:Dlabel("close=false",1.5*i,{}); g:Dlabel("ends=false",0.5*i,{}) 
g:Show()
\end{luadraw}
\end{demo}

\subsection{parallel\_polyline()}

The function \textbf{parallel\_polyline(L,width,close)} where \emph{L} is a list of complex numbers, or a list of lists of complex numbers, returns a polygonal line parallel to \emph{L} and located at a "distance" equal to \emph{width}. The argument \emph{width} can be positive or negative to be on one side or the other of \emph{L} (this depends on the direction of traversal of \emph{L}). The optional argument \emph{close} is a boolean that indicates whether \emph{L} should be closed (\emph{false} by default).


\subsection{sss\_triangle()}

The function \textbf{sss\_triangle(ab,bc,ca)}, where \emph{ab}, \emph{bc}, and \emph{ca} are three lengths, computes and returns a list of three points (3 complex numbers) $\{A,B,C\}$ forming the vertices of a direct triangle whose side lengths are the arguments, i.e., $AB=ab$, $BC=bc$, and $CA=ca$, when possible. Vertex A is always the complex 0 and vertex B is always the complex ab. This triangle can be drawn with the \textbf{g:Dpolyline} method.

\subsection{sas\_triangle()}

The function \textbf{sas\_triangle(ab,alpha,ca)}, where \emph{ab} and \emph{ca} are two lengths and \emph{alpha} is an angle in degrees, calculates and returns a list of three points (3 complex numbers) A, B, C forming the vertices of a triangle such that AB=ab, CA=ca, and angle (AB, AC) has a measure of alpha, whenever possible. Vertex A is always the complex 0 and vertex B is always the complex ab. This triangle can be drawn with the \textbf{g:Dpolyline} method.

\subsection{asa\_triangle()}

The function \textbf{asa\_triangle(alpha,ab,beta)}, where \emph{ab} is a length, \emph{alpha} and \emph{beta} are two angles in degrees, calculates and returns a list of three points (3 complex numbers) $\{A,B,C\}$ forming the vertices of a triangle such that $AB=ab$, such that angle $(\vec{AB},\vec{AC})$ has measure \emph{alpha}, and such that angle $(\vec{BA},\vec{BC})$ has measure \emph{beta}, whenever possible. Vertex $A$ is always complex $0$ and vertex $B$ is always complex $ab$. This triangle can be drawn using the \textbf{g:Dpolyline} method.

\begin{demo}{sss\_triangle, sas\_triangle and asa\_triangle}
\begin{luadraw}{name=sss_triangles_and_co}
local g = graph:new{window={-5,5,-3,5},size={10,10}}
g:Labelsize("footnotesize"); g:Linewidth(8)
local i = cpx.I
local T1 = shift( sss_triangle(4,5,3), 2*i-2)
local T2 = shift( sas_triangle(4,60,2), -4-2*i)
local T3 = shift( asa_triangle(30,4,50), 0.5-i)
g:Dpolyline({T1,T2,T3}, true)
g:Linewidth(4)
g:Darc(T2[2],T2[1],T2[3],0.5,1,"->")
g:Darc(T3[2],T3[1],T3[3],0.75,1,"->")
g:Darc(T3[1],T3[2],T3[3],0.75,-1,"->")
g:Dlabel( 
    "$4$",(T1[1]+T1[2])/2,{pos="N"}, "$5$",(T1[2]+T1[3])/2,{pos="NE"},"$3$",(T1[1]+T1[3])/2,{pos="W"},
    "$4$",(T2[1]+T2[2])/2,{pos="N"}, "$60^\\circ$",T2[1]+Zp(0.9,30*deg),{pos="center"},"$2$",(T2[1]+T2[3])/2,{pos="W"},
    "$4$",(T3[1]+T3[2])/2,{pos="N"}, "$30^\\circ$",T3[1]+Zp(1.15,15*deg),{pos="center"},
    "$50^\\circ$",T3[2]+Zp(1.15,155*deg),{pos="center"},
    "sss\\_triangle(4,5,3)",(T1[1]+T1[2])/2,{pos="S"}, "sas\\_triangle(4,60,2)",(T2[1]+T2[2])/2,{}, "asa\\_triangle(30,4,50)",(T3[1]+T3[2])/2,{})
for _,T in ipairs({T1,T2,T3}) do
    g:Dlabel("$A$",T[1],{pos="SW"}, "$B$",T[2],{pos="SE"},"$C$",T[3],{pos="N"})
end
g:Show()
\end{luadraw}
\end{demo}
